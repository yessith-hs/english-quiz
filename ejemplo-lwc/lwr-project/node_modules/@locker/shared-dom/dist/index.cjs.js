/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var shared$LWS = require('@locker/shared');

const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(AttrProto$LWS, 'value');
const DocumentCtor$LWS = Document;
const {
  prototype: DocumentProto$LWS
} = DocumentCtor$LWS;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(DocumentProto$LWS, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'documentElement');
const DocumentProtoHeadGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'head');
const DocumentProtoImplementationGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'implementation');
const {
  prototype: ElementProto$LWS
} = Element;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(ElementProto$LWS, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(ElementProto$LWS, 'outerHTML');
const ElementProtoNamespaceURIGetter$LWS = shared$LWS.ObjectLookupOwnGetter(ElementProto$LWS, 'namespaceURI');
const HTMLTemplateElementProtoContentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'firstChild');
const NodeProtoNodeNameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(NodeProto$LWS, 'ownerDocument');
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */

class Validator$LWS {
  constructor(record$LWS) {
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      shared$LWS.ReflectApply(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      shared$LWS.ReflectApply(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === shared$LWS.ReflectApply(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === shared$LWS.ReflectApply(DocumentProtoBodyGetter$LWS, this._document, []) || element$LWS === shared$LWS.ReflectApply(DocumentProtoDocumentElementGetter$LWS, this._document, []);

    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isMediaSourceObject = object$LWS => // MediaSource may not be defined in some browsers
    this._constructors.MediaSource && object$LWS instanceof this._constructors.MediaSource;

    const {
      document: document$LWS,
      globalObject: {
        HTMLLinkElement: HTMLLinkElement$LWS,
        HTMLScriptElement: HTMLScriptElement$LWS,
        MediaSource: MediaSource$LWS
      }
    } = record$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: shared$LWS.ReflectApply(DocumentProtoCreateElement$LWS, this._document, ['template']),
      right: shared$LWS.ReflectApply(DocumentProtoCreateElement$LWS, this._document, ['template'])
    };
  }

}

const topValidator$LWS = new Validator$LWS( // Mock sandbox record.
{
  document,
  globalObject: window
});
const documentToValidatorMap$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor([[document, topValidator$LWS]]));
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExp(`(?:^|\\W)${shared$LWS.escapeRegExp(shared$LWS.SANDBOX_EVAL_CONTEXT_NAME)}(?:\\W|$)`);
const webpackRequireNameRegExp$LWS = new RegExp(`\\b${shared$LWS.escapeRegExp(shared$LWS.WEBPACK_REQUIRE_NAME)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExp(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? shared$LWS.ReflectApply(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? shared$LWS.ReflectApply(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;

  if (shared$LWS.ReflectApply(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = shared$LWS.ReflectApply(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = shared$LWS.ReflectApply(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}

function getValidator$LWS(record$LWS) {
  // Fast path validator lookup for top level window.
  if (record$LWS === undefined || record$LWS.globalObject === window) {
    return topValidator$LWS;
  }

  const {
    document: document$LWS
  } = record$LWS; // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.

  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(record$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }

  return validator$LWS;
}

function transformUncompiledSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }

  const destructuredBlueHelpers$LWS = []; // Input `sourceText` is uncompiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  let locationTransformed$LWS = false;
  sourceText$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, sourceText$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of global
  // regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, webpackRequireNameRegExp$LWS, [sourceText$LWS]) ? locationReferencesWithWebPackRegExp$LWS : locationReferencesRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
    locationTransformed$LWS = true;
    return assignmentOperator$LWS ? `${shared$LWS.UNCOMPILED_LOCATION_NAME}.href${assignmentOperator$LWS}` : shared$LWS.UNCOMPILED_LOCATION_NAME;
  }]);

  if (locationTransformed$LWS) {
    destructuredBlueHelpers$LWS[destructuredBlueHelpers$LWS.length] = shared$LWS.UNCOMPILED_LOCATION_NAME;
  }

  if (!destructuredBlueHelpers$LWS.length) {
    return sourceText$LWS;
  }

  const destructureSandboxEvalContextSnippet$LWS = `const {
        ${shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, destructuredBlueHelpers$LWS, [','])}} = ${shared$LWS.SANDBOX_EVAL_CONTEXT_NAME};`;
  const pragmaIndex$LWS = shared$LWS.indexOfPragma(sourceText$LWS, 'use strict');

  if (pragmaIndex$LWS === -1) {
    return destructureSandboxEvalContextSnippet$LWS + sourceText$LWS;
  } // The "use strict" pragma, including quotes, is 12 characters long.


  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12; // istanbul ignore else

  if (afterPragmaIndex$LWS < sourceText$LWS.length && sourceText$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }

  return shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, sourceText$LWS, [0, afterPragmaIndex$LWS]) + destructureSandboxEvalContextSnippet$LWS + shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, sourceText$LWS, [afterPragmaIndex$LWS]);
}

const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(BlobProto$LWS, 'type');
const SEEN_OBJECTS_MAP$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());

function cloneBoxedPrimitive$LWS(object$LWS) {
  return shared$LWS.ObjectCtor(shared$LWS.getNearMembraneSerializedValue(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new shared$LWS.MapCtor(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = shared$LWS.ReflectApply(shared$LWS.MapProtoEntries, map$LWS, []); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      shared$LWS.ReflectApply(shared$LWS.MapProtoSet, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = shared$LWS.JSONParse(shared$LWS.getNearMembraneSerializedValue(regexp$LWS));
  return new shared$LWS.RegExpCtor(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new shared$LWS.SetCtor(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = shared$LWS.ReflectApply(shared$LWS.SetProtoValues, set$LWS, []); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      shared$LWS.ReflectApply(shared$LWS.SetProtoAdd, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = shared$LWS.ObjectKeys(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = shared$LWS.ReflectApply(shared$LWS.ArrayProtoShift, queue$LWS, []); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = SEEN_OBJECTS_MAP$LWS.get(originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = shared$LWS.getBrand(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case shared$LWS.TO_STRING_BRAND_OBJECT:
        {
          const proto$LWS = shared$LWS.ReflectGetPrototypeOf(originalValue$LWS);

          if (proto$LWS === shared$LWS.ObjectProto || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case shared$LWS.TO_STRING_BRAND_ARRAY:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = shared$LWS.ArrayCtor(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case shared$LWS.TO_STRING_BRAND_MAP:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case shared$LWS.TO_STRING_BRAND_SET:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!shared$LWS.isNearMembrane(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case shared$LWS.TO_STRING_BRAND_REG_EXP:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case shared$LWS.TO_STRING_BRAND_BOOLEAN: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case shared$LWS.TO_STRING_BRAND_NUMBER: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case shared$LWS.TO_STRING_BRAND_BIG_INT: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case shared$LWS.TO_STRING_BRAND_STRING:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  SEEN_OBJECTS_MAP$LWS.clear();
  return result$LWS;
}

const {
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListProtoValueGetter$LWS = shared$LWS.ObjectLookupOwnGetter(DOMTokenList.prototype, 'value');
const EventProtoCurrentTargetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Event.prototype, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;
const HTMLAnchorElementProtoHostnameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLAnchorElement.prototype, 'protocol');
const HTMLElementProtoDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement.prototype, 'dataset');
const HTMLIFrameElementProtoSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLIFrameElement.prototype, 'src');
const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = shared$LWS.ReflectGetOwnPropertyDescriptor(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const {
  createContextualFragment: RangeProtoCreateContextualFragment$LWS
} = Range.prototype;
const RequestProtoURLGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Request.prototype, 'url');
const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement.prototype, 'dataset');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL;
const {
  setTimeout: WindowSetTimeout$LWS
} = window; // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  setInterval: WindowSetInterval$LWS
} = window;

const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = window; // istanbul ignore else

  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  } // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = shared$LWS.PromiseResolve();
    promise$LWS = shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, promise$LWS, [callback$LWS]);
    shared$LWS.ReflectApply(shared$LWS.PromiseProtoCatch, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();

const WindowDocumentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(window, 'document');
const WindowFrameElementGetter$LWS = shared$LWS.ObjectLookupOwnGetter(window, 'frameElement');
const WindowLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(window, 'length');
const WindowLocationGetter$LWS = shared$LWS.ObjectLookupOwnGetter(window, 'location');

function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && shared$LWS.ObjectHasOwn(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      shared$LWS.ReflectApply(WindowLocationGetter$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }

  return false;
} // This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.js containing the directive and subsequently being
// ignored.
// istanbul ignore next


const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = shared$LWS.ObjectLookupOwnSetter(XhrProto$LWS, 'withCredentials');
exports.AttrProtoNameGetter = AttrProtoNameGetter$LWS;
exports.AttrProtoNamespaceURIGetter = AttrProtoNamespaceURIGetter$LWS;
exports.AttrProtoOwnerElementGetter = AttrProtoOwnerElementGetter$LWS;
exports.AttrProtoValueGetter = AttrProtoValueGetter$LWS;
exports.AttrProtoValueSetter = AttrProtoValueSetter$LWS;
exports.BlobCtor = BlobCtor$LWS;
exports.BlobProtoSizeGetter = BlobProtoSizeGetter$LWS;
exports.BlobProtoSlice = BlobProtoSlice$LWS;
exports.BlobProtoTypeGetter = BlobProtoTypeGetter$LWS;
exports.DOMImplementationProtoCreateDocument = DOMImplementationProtoCreateDocument$LWS;
exports.DOMTokenListProtoValueGetter = DOMTokenListProtoValueGetter$LWS;
exports.DocumentCtor = DocumentCtor$LWS;
exports.DocumentFragmentProtoGetElementById = DocumentFragmentProtoGetElementById$LWS;
exports.DocumentProtoBodyGetter = DocumentProtoBodyGetter$LWS;
exports.DocumentProtoCookieGetter = DocumentProtoCookieGetter$LWS;
exports.DocumentProtoCookieSetter = DocumentProtoCookieSetter$LWS;
exports.DocumentProtoCreateComment = DocumentProtoCreateComment$LWS;
exports.DocumentProtoCreateElement = DocumentProtoCreateElement$LWS;
exports.DocumentProtoCreateElementNS = DocumentProtoCreateElementNS$LWS;
exports.DocumentProtoDefaultViewGetter = DocumentProtoDefaultViewGetter$LWS;
exports.DocumentProtoDocumentElementGetter = DocumentProtoDocumentElementGetter$LWS;
exports.DocumentProtoGetElementById = DocumentProtoGetElementById$LWS;
exports.DocumentProtoHeadGetter = DocumentProtoHeadGetter$LWS;
exports.DocumentProtoImplementationGetter = DocumentProtoImplementationGetter$LWS;
exports.ElementProtoClosest = ElementProtoClosest$LWS;
exports.ElementProtoGetAttribute = ElementProtoGetAttribute$LWS;
exports.ElementProtoGetAttributeNode = ElementProtoGetAttributeNode$LWS;
exports.ElementProtoGetAttributeNodeNS = ElementProtoGetAttributeNodeNS$LWS;
exports.ElementProtoHasAttribute = ElementProtoHasAttribute$LWS;
exports.ElementProtoInnerHTMLGetter = ElementProtoInnerHTMLGetter$LWS;
exports.ElementProtoInnerHTMLSetter = ElementProtoInnerHTMLSetter$LWS;
exports.ElementProtoNamespaceURIGetter = ElementProtoNamespaceURIGetter$LWS;
exports.ElementProtoOuterHTMLGetter = ElementProtoOuterHTMLGetter$LWS;
exports.ElementProtoQuerySelector = ElementProtoQuerySelector$LWS;
exports.ElementProtoRemoveAttributeNode = ElementProtoRemoveAttributeNode$LWS;
exports.ElementProtoSetAttribute = ElementProtoSetAttribute$LWS;
exports.ElementProtoSetAttributeNS = ElementProtoSetAttributeNS$LWS;
exports.EventProtoCurrentTargetGetter = EventProtoCurrentTargetGetter$LWS;
exports.EventTargetProtoAddEventListener = EventTargetProtoAddEventListener$LWS;
exports.HTMLAnchorElementProtoHostnameGetter = HTMLAnchorElementProtoHostnameGetter$LWS;
exports.HTMLAnchorElementProtoHrefGetter = HTMLAnchorElementProtoHrefGetter$LWS;
exports.HTMLAnchorElementProtoHrefSetter = HTMLAnchorElementProtoHrefSetter$LWS;
exports.HTMLAnchorElementProtoPathnameGetter = HTMLAnchorElementProtoPathnameGetter$LWS;
exports.HTMLAnchorElementProtoProtocolGetter = HTMLAnchorElementProtoProtocolGetter$LWS;
exports.HTMLElementProtoDatasetGetter = HTMLElementProtoDatasetGetter$LWS;
exports.HTMLIFrameElementProtoSrcSetter = HTMLIFrameElementProtoSrcSetter$LWS;
exports.HTMLScriptElementProtoSrcGetter = HTMLScriptElementProtoSrcGetter$LWS;
exports.HTMLScriptElementProtoSrcSetter = HTMLScriptElementProtoSrcSetter$LWS;
exports.HTMLTemplateElementProtoContentGetter = HTMLTemplateElementProtoContentGetter$LWS;
exports.NAMESPACE_DEFAULT = NAMESPACE_DEFAULT$LWS;
exports.NAMESPACE_SVG = NAMESPACE_SVG$LWS;
exports.NAMESPACE_XHTML = NAMESPACE_XHTML$LWS;
exports.NAMESPACE_XLINK = NAMESPACE_XLINK$LWS;
exports.NodeProtoAppendChild = NodeProtoAppendChild$LWS;
exports.NodeProtoChildNodesGetter = NodeProtoChildNodesGetter$LWS;
exports.NodeProtoCloneNode = NodeProtoCloneNode$LWS;
exports.NodeProtoFirstChildGetter = NodeProtoFirstChildGetter$LWS;
exports.NodeProtoIsEqualNode = NodeProtoIsEqualNode$LWS;
exports.NodeProtoNodeNameGetter = NodeProtoNodeNameGetter$LWS;
exports.NodeProtoOwnerDocumentGetter = NodeProtoOwnerDocumentGetter$LWS;
exports.RangeProtoCreateContextualFragment = RangeProtoCreateContextualFragment$LWS;
exports.RequestProtoURLGetter = RequestProtoURLGetter$LWS;
exports.SVGElementProtoDatasetGetter = SVGElementProtoDatasetGetter$LWS;
exports.StorageProtoGetItem = StorageProtoGetItem$LWS;
exports.StorageProtoKey = StorageProtoKey$LWS;
exports.StorageProtoRemoveItem = StorageProtoRemoveItem$LWS;
exports.StorageProtoSetItem = StorageProtoSetItem$LWS;
exports.URLCreateObjectURL = URLCreateObjectURL$LWS;
exports.URLRevokeObjectURL = URLRevokeObjectURL$LWS;
exports.WindowClearInterval = WindowClearInterval$LWS;
exports.WindowDecodeURIComponent = WindowDecodeURIComponent$LWS;
exports.WindowDocumentGetter = WindowDocumentGetter$LWS;
exports.WindowEncodeURIComponent = WindowEncodeURIComponent$LWS;
exports.WindowFrameElementGetter = WindowFrameElementGetter$LWS;
exports.WindowLengthGetter = WindowLengthGetter$LWS;
exports.WindowLocationGetter = WindowLocationGetter$LWS;
exports.WindowQueueMicrotask = WindowQueueMicrotask$LWS;
exports.WindowSetInterval = WindowSetInterval$LWS;
exports.XhrCtor = XhrCtor$LWS;
exports.XhrProtoOpen = XhrProtoOpen$LWS;
exports.XhrProtoResponseTextGetter = XhrProtoResponseTextGetter$LWS;
exports.XhrProtoSend = XhrProtoSend$LWS;
exports.XhrProtoStatusGetter = XhrProtoStatusGetter$LWS;
exports.XhrProtoWithCredentialsSetter = XhrProtoWithCredentialsSetter$LWS;
exports.getValidator = getValidator$LWS;
exports.isWindow = isWindow$LWS;
exports.partialStructuredClone = partialStructuredClone$LWS;
exports.transformUncompiledSourceText = transformUncompiledSourceText$LWS;
/*! version: 0.16.27 */
