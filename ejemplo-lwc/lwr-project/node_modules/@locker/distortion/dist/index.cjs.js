/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var shared$LWS = require('@locker/shared');

var sharedDom$LWS = require('@locker/shared-dom');

var htmlSanitizer$LWS = require('@locker/html-sanitizer');

var sharedUrl$LWS = require('@locker/shared-url');

const CustomElementRegistryBlockedProperties$LWS = shared$LWS.ObjectFreeze(['define']);
const documentToSandboxAttributeDistortionRegistry$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
const recordToAttributeDistortionFactories$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());

function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = sharedDom$LWS.NAMESPACE_DEFAULT) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS); // istanbul ignore if: currently unreachable via tests

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS]; // istanbul ignore if: currently unreachable via tests

  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, attrName$LWS, [])];

  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }

  const mapIterator$LWS = elementCtorMap$LWS.entries();

  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function createAttributeDistortions$LWS(record$LWS, entries$LWS = []) {
  const factories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS); // istanbul ignore else: currently unreachable via tests

  if (factories$LWS === undefined) {
    return entries$LWS;
  }

  recordToAttributeDistortionFactories$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS);

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxAttributeDistortionRegistry$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }

  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  let {
    length: entriesOffset$LWS
  } = entries$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(attributeDistortionRegistry$LWS); // istanbul ignore if: currently unreachable via tests

    if (entry$LWS) {
      entries$LWS[entriesOffset$LWS++] = entry$LWS;
    }
  }

  return entries$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? sharedDom$LWS.NAMESPACE_DEFAULT : ns$LWS;
}

function registerElementSetDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let factories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS);

  if (factories$LWS === undefined) {
    factories$LWS = [];
    recordToAttributeDistortionFactories$LWS.set(record$LWS, factories$LWS);
  }

  const loweredAttributeName$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, attributeName$LWS, []);

  factories$LWS[factories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];

    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }

    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }

    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
    return null;
  };
}

function distortionAttrValueSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS
    }
  } = record$LWS;
  const originalAttrValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Attr$LWS.prototype, 'value');

  function value$LWS(val$LWS) {
    const ownerElement$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []); // istanbul ignore else: needs default platform behavior test

    if (ownerElement$LWS) {
      const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
      const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
      /* istanbul ignore if: coverage missing, needs investigation */

      if (distortion$LWS) {
        shared$LWS.ReflectApply(distortion$LWS, ownerElement$LWS, [val$LWS]);
        return;
      }
    }

    shared$LWS.ReflectApply(originalAttrValueSetter$LWS, this, [val$LWS]);
  }

  return [originalAttrValueSetter$LWS, value$LWS];
}

function distortionAuraUtilGlobalEval$LWS(record$LWS) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;

  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: globalObject$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval; // istanbul ignore else: external is the default sandbox type for coverage runs

  if (typeof originalGlobalEval$LWS !== 'function') {
    return null;
  } // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  const globalEval$LWS = function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
    let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;

    if (typeof descriptor$LWS === 'string') {
      const split$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, descriptor$LWS, ['://']);
      const {
        length: length$LWS
      } = split$LWS;
      const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
      wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, name$LWS, ['.', '/'])}` : `/components/${shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, name$LWS, [':', '/'])}.js`);
    }

    return sandboxEvaluator$LWS(sharedDom$LWS.transformUncompiledSourceText(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
  }; // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  return [originalGlobalEval$LWS, globalEval$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageDelete$LWS(record$LWS) {
  var _CacheStorage$prototy$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const patchedDelete$LWS = function patchedDelete$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = shared$LWS.prefixNamespace(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, patchedDelete$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageHas$LWS(record$LWS) {
  var _CacheStorage$prototy2$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return null;
  }

  const has$LWS = function has$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = shared$LWS.prefixNamespace(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalHas$LWS, this, args$LWS);
  };

  return [originalHas$LWS, has$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageKeys$LWS(record$LWS) {
  var _CacheStorage$prototy3$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return null;
  }

  const keys$LWS = function keys$LWS() {
    const keysResultPromise$LWS = shared$LWS.ReflectApply(originalKeys$LWS, this, []);
    return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, keysResultPromise$LWS, [result$LWS => {
      const sandboxedCacheNames$LWS = [];

      for (let i$LWS = 0, j$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cacheName$LWS = result$LWS[i$LWS];

        if (shared$LWS.isNamespacePrefixed(cacheName$LWS, key$LWS)) {
          sandboxedCacheNames$LWS[j$LWS++] = shared$LWS.unprefixNamespace(cacheName$LWS, key$LWS);
        }
      }

      return sandboxedCacheNames$LWS;
    }]);
  };

  return [originalKeys$LWS, keys$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageMatch$LWS(record$LWS) {
  var _CacheStorage$prototy4$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return null;
  }

  const match$LWS = function match$LWS( // @ts-ignore: Prevent 'TS1003: Identifier expected' error.
  ...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Let the native method handle missing parameters.

    if (!length$LWS) {
      return shared$LWS.ReflectApply(originalMatch$LWS, this, args$LWS);
    } // Next we check `length` is at least 2, which means options are present.


    const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the
    // `options.cacheName` value. The value of `options.cacheName` must
    // also be safely convertible to a string.

    if (shared$LWS.isObjectLike(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
      const {
        cacheName: cacheName$LWS
      } = matchOptions$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        const clonedOptions$LWS = shared$LWS.shallowCloneOptions(matchOptions$LWS);
        clonedOptions$LWS.cacheName = shared$LWS.prefixNamespace(cacheName$LWS, key$LWS);
        args$LWS[1] = clonedOptions$LWS;
        return shared$LWS.ReflectApply(originalMatch$LWS, this, args$LWS);
      }
    }

    return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError("caches.match() expects 'options.cacheName' to be present."));
  };

  return [originalMatch$LWS, match$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageOpen$LWS(record$LWS) {
  var _CacheStorage$prototy5$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return null;
  }

  const open$LWS = function open$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (shared$LWS.isConvertibleToString(cacheName$LWS)) {
        args$LWS[0] = shared$LWS.prefixNamespace(cacheName$LWS, key$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
  };

  return [originalOpen$LWS, open$LWS];
}

const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */

function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS) {
  if (shared$LWS.isObjectLike(detailsOrName$LWS)) {
    const clonedDetails$LWS = shared$LWS.shallowCloneOptions(detailsOrName$LWS);
    clonedDetails$LWS.name = shared$LWS.prefixNamespace(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = shared$LWS.prefixNamespace(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookie$LWS(cookieEntry$LWS, key$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!shared$LWS.isNamespacePrefixed(cookieEntry$LWS, key$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key.


  const prefix$LWS = shared$LWS.getNamespacePrefix(key$LWS);
  const {
    length: prefixLength$LWS
  } = prefix$LWS;
  const pos$LWS = cookieEntry$LWS.length > prefixLength$LWS && cookieEntry$LWS[prefixLength$LWS] === '=' ? prefixLength$LWS + 1 : prefixLength$LWS;
  return shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, cookieEntry$LWS, [pos$LWS]);
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreDelete$LWS(record$LWS) {
  var _CookieStore$prototyp$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const deleteValue$LWS = function deleteValue$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
    }

    return shared$LWS.ReflectApply(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, deleteValue$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGet$LWS(record$LWS) {
  var _CookieStore$prototyp2$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
    }

    const getResultPromise$LWS = shared$LWS.ReflectApply(originalGet$LWS, this, args$LWS);
    return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, getResultPromise$LWS, [cookieListItem$LWS => {
      if (cookieListItem$LWS) {
        const {
          name: name$LWS
        } = cookieListItem$LWS;

        if (shared$LWS.isNamespacePrefixed(name$LWS, key$LWS)) {
          cookieListItem$LWS.name = shared$LWS.unprefixNamespace(name$LWS, key$LWS);
          return cookieListItem$LWS;
        }
      }

      return null;
    }]);
  };

  return [originalGet$LWS, get$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGetAll$LWS(record$LWS) {
  var _CookieStore$prototyp3$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return null;
  }

  const getAll$LWS = function getAll$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
    }

    const getAllResultPromise$LWS = shared$LWS.ReflectApply(originalGetAll$LWS, this, args$LWS);
    return shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, getAllResultPromise$LWS, [result$LWS => {
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookieListItem$LWS = result$LWS[i$LWS];

        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;

          if (shared$LWS.isNamespacePrefixed(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = shared$LWS.unprefixNamespace(name$LWS, key$LWS);
            sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
          }
        }
      }

      return sandboxedCookies$LWS;
    }]);
  };

  return [originalGetAll$LWS, getAll$LWS];
}

const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;

  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
}

function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }

  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = shared$LWS.toSafeWeakSet(new shared$LWS.WeakSetCtor())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreOnChange$LWS(record$LWS) {
  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  } = record$LWS;
  const originalOnChangeSetter$LWS = shared$LWS.ObjectLookupOwnSetter(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return null;
  }

  const onchange$LWS = function onchange$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set cookieStore.onchange.');
  };

  registerEventTargetRestriction$LWS(record$LWS, CookieStore$LWS, 'change');
  return [originalOnChangeSetter$LWS, onchange$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreSet$LWS(record$LWS) {
  var _CookieStore$prototyp4$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return null;
  }

  const set$LWS = function set$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      args$LWS[0] = shared$LWS.prefixNamespace(args$LWS[0], key$LWS);
    } else if (length$LWS) {
      const {
        0: details$LWS
      } = args$LWS;

      if (shared$LWS.isObjectLike(details$LWS)) {
        const clonedDetails$LWS = shared$LWS.shallowCloneOptions(details$LWS);
        clonedDetails$LWS.name = shared$LWS.prefixNamespace(clonedDetails$LWS.name, key$LWS);
        args$LWS[0] = clonedDetails$LWS;
      }
    }

    return shared$LWS.ReflectApply(originalSet$LWS, this, args$LWS);
  };

  return [originalSet$LWS, set$LWS];
}

function distortionCSSStyleRuleStyleGetter$LWS(record$LWS) {
  const {
    globalObject: {
      CSSStyleRule: CSSStyleRule$LWS
    }
  } = record$LWS;
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(CSSStyleRule$LWS.prototype, 'style');

  function style$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionCustomElementRegistryGet$LWS(record$LWS) {
  var _CustomElementRegistr$LWS;

  const {
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS
    },
    key: key$LWS
  } = record$LWS;
  const LOWERED_NS$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, key$LWS, []); // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const sanitizedName$LWS = shared$LWS.toString(args$LWS[0]);
      const loweredName$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, sanitizedName$LWS, []);

      if (!shared$LWS.ReflectApply(shared$LWS.StringProtoStartsWith, loweredName$LWS, [`${LOWERED_NS$LWS}-`])) {
        return undefined;
      }

      args$LWS[0] = sanitizedName$LWS;
    }

    return shared$LWS.ReflectApply(originalGet$LWS, this, args$LWS);
  };

  return [originalGet$LWS, get$LWS];
}
/**
 * Factory patched cookie getter. Must be invoked with namespace argument.
 * Will return a patched cookie getter bound to the namespace.
 * @param key
 * @returns Distortion: string
 */


function distortionDocumentCookieGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalCookieGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Document$LWS.prototype, 'cookie');

  function get$LWS() {
    const documentCookieValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCookieGetter, this, []);
    const cookies$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
    const sandboxedCookies$LWS = [];
    let sandboxedCookiesOffset$LWS = 0;

    for (let i$LWS = 0, {
      length: length$LWS
    } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);

      if (cookie$LWS) {
        sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
      }
    }

    return shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
  }

  return [originalCookieGetter$LWS, get$LWS];
}
/**
 * Factory patched cookie setter. Must be invoked with namespace argument.
 * Returns a distortion function bound to the namespace.
 */


function distortionDocumentCookieSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalCookieSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'cookie');

  function set$LWS(value$LWS) {
    const cookieEntries$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, value$LWS, [COOKIE_DELIMITER$LWS]);
    let {
      0: newCookieEntry$LWS
    } = cookieEntries$LWS;

    if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
      newCookieEntry$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSlice, newCookieEntry$LWS, [1]);
    }

    cookieEntries$LWS[0] = shared$LWS.prefixNamespace(newCookieEntry$LWS, key$LWS);
    const cookie$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
    shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCookieSetter, this, [cookie$LWS]);
  }

  return [originalCookieSetter$LWS, set$LWS];
}

function distortionDocumentDomainSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const originalDomainSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Document$LWS.prototype, 'domain');

  function domain$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set document.domain.');
  }

  return [originalDomainSetter$LWS, domain$LWS];
}

function distortionDocumentExecCommand$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS,
      HTMLElement: HTMLElement$LWS
    },
    type: type$LWS
  } = record$LWS;
  const {
    prototype: DocumentProto$LWS
  } = Document$LWS;
  const {
    execCommand: originalExecCommand$LWS
  } = DocumentProto$LWS;
  const originalActiveElement$LWS = shared$LWS.ObjectLookupOwnGetter(DocumentProto$LWS, 'activeElement');
  const originalIsContentEditable$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'isContentEditable'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function execCommand$LWS(...args$LWS) {
    if (args$LWS.length > 2) {
      const {
        2: unsanitizedValue$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
        const command$LWS = shared$LWS.toString(args$LWS[0]); // istanbul ignore else: LWS does not test for all possible commands

        if (shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, command$LWS, []) === 'inserthtml') {
          // istanbul ignore else: external is the default sandbox type for coverage runs
          if (type$LWS === 0
          /* External */
          ) {
            const activeElement$LWS = shared$LWS.ReflectApply(originalActiveElement$LWS, this, []);

            if (isSharedElement$LWS(activeElement$LWS) && shared$LWS.ReflectApply(originalIsContentEditable$LWS, activeElement$LWS, [])) {
              throw new shared$LWS.LockerSecurityError(`Cannot execute command '${command$LWS}' on ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, activeElement$LWS, []))}.`);
            }
          }

          args$LWS[0] = command$LWS;
          args$LWS[2] = htmlSanitizer$LWS.sanitize(unsanitizedValue$LWS);
        }
      }
    }

    return shared$LWS.ReflectApply(originalExecCommand$LWS, this, args$LWS);
  }

  return [originalExecCommand$LWS, execCommand$LWS];
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shared$LWS.shallowCloneArray(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    const windowFeatures$LWS = shared$LWS.toString(sanitizedArgs$LWS[2]);
    let loweredWindowFeatures$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, windowFeatures$LWS, []); // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

    if (shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, noopenerRegExp$LWS, [windowFeatures$LWS])) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      loweredWindowFeatures$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, loweredWindowFeatures$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
    }

    sanitizedArgs$LWS[2] = loweredWindowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function distortionDocumentOpen$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const {
    open: originalDocumentOpen$LWS
  } = Document$LWS.prototype;

  function open$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      return shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalDocumentOpen$LWS, this, args$LWS);
  }

  return [originalDocumentOpen$LWS, open$LWS];
}

function distortionDocumentReplaceChildren$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const {
    replaceChildren: originalReplaceChild$LWS
  } = Document$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check if
    // its `head` property is a shared element. This will allow magenta window
    // documents to call replaceChildren successfully.
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoHeadGetter, this, []))) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of document.`);
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChildren$LWS];
}

function distortionDOMParserParseFromString$LWS(record$LWS) {
  const {
    globalObject: {
      DOMParser: DOMParser$LWS
    }
  } = record$LWS;
  const {
    parseFromString: originalParseFromString$LWS
  } = DOMParser$LWS.prototype;

  function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with exactly
    // two arguments. If it receives one argument, it will fail. Some implementations
    // will also fail if it receives more than two arguments. Since any call that does
    // not have at least two arguments will fail no matter what, we only need to
    // expend effort to sanitize when we know that the operation is definitely
    // NOT going to fail.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = shared$LWS.toString(args$LWS[0]);
      const mimeType$LWS = shared$LWS.toString(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? htmlSanitizer$LWS.sanitizeSvgInnerHtml(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : htmlSanitizer$LWS.sanitize(string$LWS);
    }

    return shared$LWS.ReflectApply(originalParseFromString$LWS, this, args$LWS);
  }

  return [originalParseFromString$LWS, parseFromString$LWS];
}

function distortionElementAfter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    after: originalAfter$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} after ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalAfter$LWS, this, args$LWS);
  }

  return [originalAfter$LWS, after$LWS];
}

function distortionElementAppend$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    append: originalAppend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot append ${nodeNameOrString$LWS} to ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalAppend$LWS, this, args$LWS);
  }

  return [originalAppend$LWS, append$LWS];
}

function distortionElementAttachShadow$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    attachShadow: originalAttachShadow$LWS
  } = Element$LWS.prototype;

  function attachShadow$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new shared$LWS.LockerSecurityError("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit because
        // attachShadow() accepts inherited shadowRootInit properties.


        const shadowRootInit$LWS = shared$LWS.ObjectAssign({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment of mode
        // to avoid complications with inherited non-configurable/non-writable
        // mode properties.

        const originalShadowRootInitProto$LWS = shared$LWS.ReflectGetPrototypeOf(originalShadowRootInit$LWS);
        shared$LWS.ReflectSetPrototypeOf(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return shared$LWS.ReflectApply(originalAttachShadow$LWS, this, args$LWS);
  }

  return [originalAttachShadow$LWS, attachShadow$LWS];
}

const namedNodeMapToElementRegistry$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementRegistry$LWS.set(attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementRegistry$LWS.get(nodeNameMap$LWS); // istanbul ignore else: nothing to do if there's no element

  if (element$LWS) {
    const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []);
    const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: nothing to do if there's no distortion

    if (distortion$LWS) {
      const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
      return shared$LWS.ReflectApply(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  } // istanbul ignore next: needs default platform behavior test


  return shared$LWS.ReflectApply(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function distortionElementAttributesGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalAttributesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'attributes');

  function attributes$LWS() {
    const attrs$LWS = shared$LWS.ReflectApply(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }

  return [originalAttributesGetter$LWS, attributes$LWS];
}

function distortionElementBefore$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    before: originalBefore$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // istanbul ignore else: needs default platform behavior test

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot insert ${nodeNameOrString$LWS} before ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalBefore$LWS, this, args$LWS);
  }

  return [originalBefore$LWS, before$LWS];
}

function distortionElementInnerHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      SVGElement: SVGElement$LWS,
      XMLDocument: XMLDocument$LWS
    }
  } = record$LWS;
  const originalInnerHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Element$LWS.prototype, 'innerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function innerHTML$LWS(value$LWS) {
    const isOwnerXMLDocument$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, this, []) instanceof XMLDocument$LWS;

    if (!isOwnerXMLDocument$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$LWS(this)) {
        throw new shared$LWS.LockerSecurityError(`Cannot set innerHTML of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
      }

      value$LWS = this instanceof SVGElement$LWS ? htmlSanitizer$LWS.sanitizeSvgInnerHtml(this, value$LWS) : htmlSanitizer$LWS.sanitize(value$LWS);
    }

    shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [value$LWS]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionElementInsertAdjacentElement$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    insertAdjacentElement: originalInsertAdjacentElement$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(element$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, element$LWS, [])} adjacent to ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, [])}.`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertAdjacentElement$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentElement$LWS, insertAdjacentElement$LWS];
}

function distortionElementInsertAdjacentHTML$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    insertAdjacentHTML: originalInsertAdjacentHTML$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot insert adjacent HTML to ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}`);
    } // istanbul ignore else: needs default platform behavior test


    if (args$LWS.length > 1) {
      args$LWS[1] = htmlSanitizer$LWS.sanitize(args$LWS[1]);
    }

    shared$LWS.ReflectApply(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentHTML$LWS, insertAdjacentHTML$LWS];
}

function distortionElementOuterHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalOuterHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Element$LWS.prototype, 'outerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function outerHTML$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set outerHTML of ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    shared$LWS.ReflectApply(originalOuterHTMLSetter$LWS, this, [htmlSanitizer$LWS.sanitize(value$LWS)]);
  }

  return [originalOuterHTMLSetter$LWS, outerHTML$LWS];
}

function distortionElementPrepend$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    prepend: originalPrepend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = shared$LWS.toString(argValue$LWS instanceof Node$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new shared$LWS.LockerSecurityError(`Cannot prepend ${nodeNameOrString$LWS} to ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
        }
      }
    }

    return shared$LWS.ReflectApply(originalPrepend$LWS, this, args$LWS);
  }

  return [originalPrepend$LWS, prepend$LWS];
}

function distortionElementRemove$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    remove: originalRemove$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    shared$LWS.ReflectApply(originalRemove$LWS, this, []);
  }

  return [originalRemove$LWS, remove$LWS];
}

function distortionElementReplaceChildren$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    replaceChildren: originalReplaceChildren$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace children of ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    return shared$LWS.ReflectApply(originalReplaceChildren$LWS, this, args$LWS);
  }

  return [originalReplaceChildren$LWS, replaceChildren$LWS];
}

function distortionElementReplaceWith$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    replaceWith: originalReplaceWith$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    return shared$LWS.ReflectApply(originalReplaceWith$LWS, this, args$LWS);
  }

  return [originalReplaceWith$LWS, replaceWith$LWS];
}

function distortionElementSetAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element$LWS.prototype;

  function setAttribute$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const attrName$LWS = shared$LWS.toString(args$LWS[0]);
      const attrValue$LWS = shared$LWS.toString(args$LWS[1]);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);

      if (distortion$LWS) {
        shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
        return;
      } // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"


      args$LWS[0] = attrName$LWS;
      args$LWS[1] = attrValue$LWS;
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, args$LWS);
  }

  return [originalSetAttribute$LWS, setAttribute$LWS];
}

function distortionElementSetAttributeNode$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNode: originalSetAttributeNode$LWS
  } = Element$LWS.prototype;

  function setAttributeNode$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.
    // istanbul ignore if: needs default platform behavior test


    if (shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, attr$LWS, [])) {
      return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
    }

    const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []);
    const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNode, this, [attrName$LWS]);

      if (oldAttr$LWS) {
        // Disconnect old attribute.
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [oldAttr$LWS]);
      }

      const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNode, this, [attrName$LWS]);

      if (newAttr$LWS) {
        // Remove distorted attribute.
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [newAttr$LWS]);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, newAttr$LWS, []); // Set the distorted attr value.

        shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueSetter, attr$LWS, [newValue$LWS]); // Replace old attr.

        return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, [attr$LWS]);
      }

      return undefined;
    }

    return shared$LWS.ReflectApply(originalSetAttributeNode$LWS, this, args$LWS);
  }

  return [originalSetAttributeNode$LWS, setAttributeNode$LWS];
}

function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNodeNS: originalSetAttributeNodeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNodeNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.
    // istanbul ignore if: needs default platform behavior test


    if (shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, attr$LWS, [])) {
      return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, args$LWS);
    }

    const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, attr$LWS, []);
    const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNodeNS, this, [attrNamespace$LWS, attrName$LWS]);

      if (oldAttr$LWS) {
        // Disconnect the old attribute.
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [oldAttr$LWS]);
      }

      const attrValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, attr$LWS, []);
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttributeNodeNS, this, [attrNamespace$LWS, attrName$LWS]);

      if (newAttr$LWS) {
        // Remove the distorted attribute.
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoRemoveAttributeNode, this, [newAttr$LWS]);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueGetter, newAttr$LWS, []); // Set the distorted attr value.

        shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoValueSetter, attr$LWS, [newValue$LWS]); // Replace old attr.

        return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }

      return null;
    }

    return shared$LWS.ReflectApply(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
  }

  return [originalSetAttributeNodeNS$LWS, setAttributeNodeNS$LWS];
}

function distortionElementSetAttributeNS$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNS: originalSetAttributeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNS$LWS(...args$LWS) {
    // istanbul ignore next: needs default platform behavior test
    if (args$LWS.length < 3) {
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
      return;
    }

    let {
      0: attrNamespace$LWS
    } = args$LWS;

    if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
      attrNamespace$LWS = shared$LWS.toString(attrNamespace$LWS);
    }

    const attrName$LWS = shared$LWS.toString(args$LWS[1]);
    const attrValue$LWS = shared$LWS.toString(args$LWS[2]);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

    if (distortion$LWS) {
      shared$LWS.ReflectApply(distortion$LWS, this, [attrValue$LWS]);
      return;
    } // istanbul ignore next: needs default platform behavior test
    // eslint-disable-next-line no-lone-blocks


    {
      // This is in a block to avoid requiring an "instanbul ignore next" for all for lines.
      // We could avoid this entirely by testing the default platform behavior.
      args$LWS[0] = attrNamespace$LWS; // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"

      args$LWS[1] = attrName$LWS;
      args$LWS[2] = attrValue$LWS;
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, args$LWS);
    }
  }

  return [originalSetAttributeNS$LWS, setAttributeNS$LWS];
}

function distortionElementShadowRootGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalShadowRootGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Element$LWS.prototype, 'shadowRoot');

  function shadowRoot$LWS() {
    return null;
  }

  return [originalShadowRootGetter$LWS, shadowRoot$LWS];
}

function distortionElementToggleAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    hasAttribute: ElementProtoHasAttribute$LWS,
    toggleAttribute: originalToggleAttribute$LWS
  } = Element$LWS.prototype;

  const toggleAttribute$LWS = function toggleAttribute$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 0) {
      const attrName$LWS = shared$LWS.toString(args$LWS[0]);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely, if the distortion throws.

        shared$LWS.ReflectApply(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to return true | false, based on
        // the presence or absence of this attribute.

        return shared$LWS.ReflectApply(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
      } // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"
      // istanbul ignore next: needs default platform behavior test


      args$LWS[0] = attrName$LWS;
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalToggleAttribute$LWS, this, args$LWS);
  };

  return [originalToggleAttribute$LWS, toggleAttribute$LWS];
}

function distortionEval$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      eval: originalEval$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function Eval$LWS(sourceText$LWS) {
    return sandboxEvaluator$LWS(sharedDom$LWS.transformUncompiledSourceText(shared$LWS.toString(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS);
  }

  return [originalEval$LWS, Eval$LWS];
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = shared$LWS.ReflectApply(sharedDom$LWS.EventProtoCurrentTargetGetter, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = shared$LWS.ReflectApply(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoIndexOf, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoSlice, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }

  return distortedComposedPath$LWS;
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function distortionEventComposedPath$LWS(record$LWS) {
  const {
    globalObject: {
      Event: Event$LWS
    }
  } = record$LWS;
  const {
    composedPath: originalComposedPath$LWS
  } = Event$LWS.prototype;

  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }

  return [originalComposedPath$LWS, composedPath$LWS];
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function distortionEventPathGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Event: Event$LWS
    }
  } = record$LWS;
  const originalPathGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return null;
  }

  const path$LWS = function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  };

  return [originalPathGetter$LWS, path$LWS];
}

function distortionEventTargetAddEventListener$LWS(record$LWS) {
  const {
    globalObject: {
      EventTarget: EventTarget$LWS
    }
  } = record$LWS;
  const {
    addEventListener: originalAddEventListener$LWS
  } = EventTarget$LWS.prototype;

  function addEventListener$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Ensure that we fallback to the default platform behavior which
    // should fail if less than 2 arguments are provided.
    // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const eventName$LWS = shared$LWS.toString(args$LWS[0]);

      if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
        var _safeDesc$LWS;

        const unsafeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(this.constructor, 'name');
        let safeDesc$LWS; // istanbul ignore else: needs default platform behavior test

        if (unsafeDesc$LWS) {
          safeDesc$LWS = shared$LWS.toSafeDescriptor(unsafeDesc$LWS);
        }

        const name$LWS = (_safeDesc$LWS = safeDesc$LWS) == null ? void 0 : _safeDesc$LWS.value;
        let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`; // istanbul ignore else: needs default platform behavior test

        if (typeof name$LWS === 'string') {
          exceptionMessage$LWS += ` to ${name$LWS} object`;
        }

        throw new shared$LWS.LockerSecurityError(`${exceptionMessage$LWS}.`);
      }

      args$LWS[0] = eventName$LWS;
    }

    return shared$LWS.ReflectApply(originalAddEventListener$LWS, this, args$LWS);
  }

  return [originalAddEventListener$LWS, addEventListener$LWS];
}

function distortionFunction$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      Function: originalFunction$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function Function$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS) {
      const lastIndex$LWS = length$LWS - 1;
      args$LWS[lastIndex$LWS] = sharedDom$LWS.transformUncompiledSourceText(shared$LWS.toString(args$LWS[lastIndex$LWS]));
    } // NOTE: Function constructor and eval are controlled by the same CSP rules,
    // which means we can rely on eval to fulfill the behavior of the Function
    // constructor.


    const fn$LWS = sandboxEvaluator$LWS(`(...args) => Function(...args)`, UNCOMPILED_CONTEXT$LWS);
    return shared$LWS.ReflectApply(fn$LWS, this, args$LWS);
  }

  return [originalFunction$LWS, Function$LWS];
}

function distortionHistoryPushState$LWS(record$LWS) {
  const {
    globalObject: {
      History: History$LWS
    }
  } = record$LWS;
  const {
    pushState: originalPushState$LWS
  } = History$LWS.prototype;

  function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalPushState$LWS, this, args$LWS);
  }

  return [originalPushState$LWS, pushState$LWS];
}

function distortionHistoryReplaceState$LWS(record$LWS) {
  const {
    globalObject: {
      History: History$LWS
    }
  } = record$LWS;
  const {
    replaceState: originalReplaceState$LWS
  } = History$LWS.prototype;

  function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalReplaceState$LWS, this, args$LWS);
  }

  return [originalReplaceState$LWS, replaceState$LWS];
}

function distortionHTMLElementDatasetGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionHTMLElementInnerTextSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalInnerTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'innerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  const innerText$LWS = function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set innerText of ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    shared$LWS.ReflectApply(originalInnerTextSetter$LWS, this, [value$LWS]);
  };

  return [originalInnerTextSetter$LWS, innerText$LWS];
} // outerText is not a standard property, so the descriptor could be undefined, like in the case
// of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility


function distortionHTMLElementOuterTextSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalOuterTextSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLElement$LWS.prototype, 'outerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  const outerText$LWS = function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set outerText of ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))}.`);
    }

    shared$LWS.ReflectApply(originalOuterTextSetter$LWS, this, [value$LWS]);
  };

  return [originalOuterTextSetter$LWS, outerText$LWS];
}

function distortionHTMLElementStyleGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalStyleGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLElement$LWS.prototype, 'style');

  function style$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  } = record$LWS;
  const originalSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLIFrameElement$LWS.prototype, 'src');

  function src$LWS(value$LWS) {
    const urlString$LWS = sharedUrl$LWS.sanitizeURLForElement(value$LWS);

    if (!sharedUrl$LWS.isValidURLScheme(urlString$LWS)) {
      throw new shared$LWS.LockerSecurityError('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
    }

    shared$LWS.ReflectApply(sharedDom$LWS.HTMLIFrameElementProtoSrcSetter, this, [urlString$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', sharedDom$LWS.NAMESPACE_DEFAULT, src$LWS);
  return [originalSrcSetter$LWS, src$LWS];
}

const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, importRegExp$LWS, [value$LWS]);
}

function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  } = record$LWS;
  const originalRelSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const string$LWS = shared$LWS.toString(value$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      shared$LWS.ReflectApply(originalRelSetter$LWS, this, [string$LWS]);
      return;
    }

    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', sharedDom$LWS.NAMESPACE_DEFAULT, rel$LWS);
  return [originalRelSetter$LWS, rel$LWS];
}

function distortionHTMLLinkElementRelListSetter$LWS(record$LWS) {
  const {
    globalObject: {
      DOMTokenList: DOMTokenList$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  } = record$LWS;
  const originalRelListSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLLinkElement$LWS.prototype, 'relList');

  function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ?
    /* istanbul ignore next: needs default platform behavior test */
    shared$LWS.ReflectApply(sharedDom$LWS.DOMTokenListProtoValueGetter, relListValue$LWS, []) : shared$LWS.toString(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      shared$LWS.ReflectApply(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    shared$LWS.consoleWarn(WARN_MESSAGE$LWS);
  }

  return [originalRelListSetter$LWS, relList$LWS];
}

function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLObjectElement: HTMLObjectElement$LWS
    }
  } = record$LWS;
  const originalDataSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLObjectElement$LWS.prototype, 'data');

  function data$LWS(value$LWS) {
    const urlString$LWS = sharedUrl$LWS.sanitizeURLForElement(value$LWS);

    if (!sharedUrl$LWS.isValidURLScheme(urlString$LWS)) {
      throw new shared$LWS.LockerSecurityError('HTMLObjectElement.data supports http://, https:// schemes and relative urls.');
    }

    const parsedURL$LWS = sharedUrl$LWS.parseURL(urlString$LWS);

    if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
      throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }

    shared$LWS.ReflectApply(originalDataSetter$LWS, this, [urlString$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', sharedDom$LWS.NAMESPACE_DEFAULT, data$LWS);
  return [originalDataSetter$LWS, data$LWS];
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = shared$LWS.ReflectApply(sharedDom$LWS.HTMLElementProtoDatasetGetter, el$LWS, []);
  const distortedSrc$LWS = shared$LWS.ObjectLookupOwnValue(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function distortionHTMLScriptElementSrcGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  } = record$LWS;
  const originalSrcGetter$LWS = shared$LWS.ObjectLookupOwnGetter(HTMLScriptElement$LWS.prototype, 'src');

  function src$LWS() {
    return getDatasetSrcValue$LWS(this) || shared$LWS.ReflectApply(originalSrcGetter$LWS, this, []);
  }

  return [originalSrcGetter$LWS, src$LWS];
}

const SCRIPT_PAYLOAD_NAME$LWS = '$payload$';
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_BLOB_OPTIONS$LWS = {
  __proto__: null,
  type: 'text/javascript'
};
const SCRIPT_BLOB_TEMPLATE$LWS = `document.currentScript[${shared$LWS.enquote(SCRIPT_EVALUATOR_PROPERTY_NAME$LWS)}](decodeURIComponent(${// Enquote with double quotes because `WindowEncodeURIComponent()` encodes
// double quotes (") as (%22).
shared$LWS.enquote(SCRIPT_PAYLOAD_NAME$LWS, shared$LWS.CHAR_QUOTE_DOUBLE)}))`;

function abstractFactoryValueThrower$LWS(proto$LWS, propName$LWS) {
  return function valueThrowerDistortionFactory$LWS(_record$LWS) {
    const {
      [propName$LWS]: originalValue$LWS
    } = proto$LWS;

    function value$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalValue$LWS, value$LWS];
  };
}

function abstractFactoryGetThrower$LWS(proto$LWS, propName$LWS) {
  return function getThrowerDistortionFactory$LWS(_record$LWS) {
    const originalGet$LWS = shared$LWS.ObjectLookupOwnGetter(proto$LWS, propName$LWS);

    function get$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalGet$LWS, get$LWS];
  };
}

function abstractFactorySetThrower$LWS(proto$LWS, propName$LWS) {
  return function setThrowerDistortionFactory$LWS(_record$LWS) {
    const originalSet$LWS = shared$LWS.ObjectLookupOwnSetter(proto$LWS, propName$LWS);

    function set$LWS() {
      throw new shared$LWS.LockerSecurityError(`Cannot access ${propName$LWS}.`);
    }

    return [originalSet$LWS, set$LWS];
  };
}
/**
 * Wraps the source content of a script tag in the evaluator
 * Creates a blob: url with the wrapped content
 */


function createScriptUrl$LWS(sourceText$LWS) {
  return sharedDom$LWS.URLCreateObjectURL(new sharedDom$LWS.BlobCtor([shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, SCRIPT_BLOB_TEMPLATE$LWS, [SCRIPT_PAYLOAD_NAME$LWS, sharedDom$LWS.WindowEncodeURIComponent(sourceText$LWS)])], SCRIPT_BLOB_OPTIONS$LWS));
}

function createBlockedPropertyDistortionFactories$LWS(proto$LWS, propertyList$LWS, factories$LWS = []) {
  let {
    length: factoriesOffset$LWS
  } = factories$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = propertyList$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = propertyList$LWS[i$LWS];
    const unsafeDesc$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(proto$LWS, prop$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = shared$LWS.toSafeDescriptor(unsafeDesc$LWS);
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS; // istanbul ignore else

        if (getter$LWS) {
          factories$LWS[factoriesOffset$LWS++] = abstractFactoryGetThrower$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          factories$LWS[factoriesOffset$LWS++] = abstractFactorySetThrower$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {} because prettier
        // won't allow a multi-line comment between "else" and "if", which is where the
        // istanbul ignore directive must go to be effective.
        // istanbul ignore else: currently unreachable via tests
        if (typeof value$LWS === 'function') {
          factories$LWS[factoriesOffset$LWS++] = abstractFactoryValueThrower$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }

  return factories$LWS;
}

function createScriptDistortion$LWS(record$LWS, attributeName$LWS, datasetGetter$LWS) {
  const {
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;
  const distortionName$LWS = `script${shared$LWS.capitalizeFirstChar(attributeName$LWS)}`;
  const normalizerAnchor$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElement, document, ['a']); // Use a computed property to dynamically set the distortion function name
  // without using Reflect.defineProperty().

  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](value$LWS) {
      const originalValue$LWS = value$LWS;
      const elementNamespaceURI$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoNamespaceURIGetter, this, []);
      const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === sharedDom$LWS.NAMESPACE_XHTML ? '' : sharedDom$LWS.NAMESPACE_XLINK;

      if (value$LWS === '') {
        shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttributeNS, this, [attributeNamespaceURI$LWS, attributeName$LWS, value$LWS]);
        return;
      } // Normalize Value


      shared$LWS.ReflectApply(sharedDom$LWS.HTMLAnchorElementProtoHrefSetter, normalizerAnchor$LWS, [value$LWS]);
      value$LWS = shared$LWS.ReflectApply(sharedDom$LWS.HTMLAnchorElementProtoHrefGetter, normalizerAnchor$LWS, []); // Create Synthetic Attribute

      const dataset$LWS = shared$LWS.ReflectApply(datasetGetter$LWS, this, []);
      dataset$LWS[`distorted${shared$LWS.capitalizeFirstChar(attributeName$LWS)}`] = originalValue$LWS; // Create XHR

      const hostname$LWS = shared$LWS.ReflectApply(sharedDom$LWS.HTMLAnchorElementProtoHostnameGetter, normalizerAnchor$LWS, []);
      const xhr$LWS = new sharedDom$LWS.XhrCtor(); // istanbul ignore if: currently unreachable via tests

      if (shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, sharedUrl$LWS.TRUSTED_DOMAINS_REG_EXP, [hostname$LWS])) {
        shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoWithCredentialsSetter, xhr$LWS, [true]);
      }

      shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, xhr$LWS, ['load', () => {
        const status$LWS = shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoStatusGetter, xhr$LWS, []);

        if (status$LWS === 200) {
          const responseText$LWS = shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoResponseTextGetter, xhr$LWS, []);
          shared$LWS.ReflectDefineProperty(this, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
            __proto__: null,
            configurable: true,
            // Create a bound function to obscure the getter
            // source as "[native code]".
            get: shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, () => {
              shared$LWS.ReflectDeleteProperty(this, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
              const ownerDoc$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, this, []);
              const defaultView$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDefaultViewGetter, ownerDoc$LWS, []); // We don't need to use something like
              // `WindowLocationGetter()` because the
              // 'location' property is non-configurable.

              const context$LWS = {
                [shared$LWS.UNCOMPILED_LOCATION_NAME]: defaultView$LWS.location
              };
              return sourceText$LWS => sandboxEvaluator$LWS(sharedDom$LWS.transformUncompiledSourceText(shared$LWS.toString(sourceText$LWS)), context$LWS, defaultView$LWS, ownerDoc$LWS);
            }, [this])
          });
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttributeNS, this, [attributeNamespaceURI$LWS, attributeName$LWS, createScriptUrl$LWS(responseText$LWS)]);
        } else {
          // The following if statement is enclosed in a dedicated
          // else {} because prettier won't allow a multi-line comment
          // between "else" and "if", which is where the istanbul
          // ignore directive must go to be effective.
          // istanbul ignore else: cannot produce codes beyond 200, 404 in tests
          if (status$LWS === 404) {
            shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttributeNS, this, [attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found']);
          }
        }
      }]);
      shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoOpen, xhr$LWS, ['GET', value$LWS]);
      shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoSend, xhr$LWS, []);
    }

  };
  return distortion$LWS;
}

function distortBlockedAttributes$LWS(record$LWS, Ctor$LWS, attributes$LWS, elNamespace$LWS = sharedDom$LWS.NAMESPACE_DEFAULT) {
  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attributeName$LWS = attributes$LWS[i$LWS];
    const enquotedAttributeName$LWS = shared$LWS.enquote(attributeName$LWS);
    const safeCtorName$LWS = shared$LWS.toSafeTemplateStringValue(Ctor$LWS.name);
    const distortionName$LWS = `blocked${shared$LWS.capitalizeFirstChar(attributeName$LWS)}Attribute`; // Use a computed property to dynamically set the distortion function
    // name without using Reflect.defineProperty().

    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new shared$LWS.LockerSecurityError(`Attribute ${enquotedAttributeName$LWS} not allowed on ${safeCtorName$LWS}.`);
      }
    };
    registerElementSetDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, elNamespace$LWS, distortion$LWS);
  }
}

function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  } = record$LWS;
  const originalSrcSetter$LWS = shared$LWS.ObjectLookupOwnSetter(HTMLScriptElement$LWS.prototype, 'src');
  const src$LWS = createScriptDistortion$LWS(record$LWS, 'src', sharedDom$LWS.HTMLElementProtoDatasetGetter);
  registerElementSetDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', sharedDom$LWS.NAMESPACE_DEFAULT, src$LWS);
  return [originalSrcSetter$LWS, src$LWS];
}

function distortionIDBObjectStoreAdd$LWS(record$LWS) {
  const {
    globalObject: {
      IDBObjectStore: IDBObjectStore$LWS
    }
  } = record$LWS;
  const {
    add: originalAdd$LWS
  } = IDBObjectStore$LWS.prototype;

  function add$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalAdd$LWS, this, args$LWS);
  }

  return [originalAdd$LWS, add$LWS];
}

function distortionIDBObjectStorePut$LWS(record$LWS) {
  const {
    globalObject: {
      IDBObjectStore: IDBObjectStore$LWS
    }
  } = record$LWS;
  const {
    put: originalPut$LWS
  } = IDBObjectStore$LWS.prototype;

  function put$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = sharedDom$LWS.partialStructuredClone(args$LWS[0]);
    }

    return shared$LWS.ReflectApply(originalPut$LWS, this, args$LWS);
  }

  return [originalPut$LWS, put$LWS];
}

function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: NamedNodeMap$LWS
    }
  } = record$LWS;
  const {
    setNamedItem: originalSetNamedItem$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItem$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (attr$LWS && attr$LWS instanceof Attr$LWS) {
      return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
    }

    return shared$LWS.ReflectApply(originalSetNamedItem$LWS, this, args$LWS);
  }

  return [originalSetNamedItem$LWS, setNamedItem$LWS];
}

function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: NamedNodeMap$LWS
    }
  } = record$LWS;
  const {
    setNamedItemNS: originalSetNamedItemNS$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItemNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (attr$LWS && attr$LWS instanceof Attr$LWS) {
      return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
    }

    return shared$LWS.ReflectApply(originalSetNamedItemNS$LWS, this, args$LWS);
  }

  return [originalSetNamedItemNS$LWS, setNamedItemNS$LWS];
}

function distortionNavigatorSendBeacon$LWS(record$LWS) {
  const {
    globalObject: {
      Navigator: Navigator$LWS
    }
  } = record$LWS;
  const {
    sendBeacon: originalSendBeacon$LWS
  } = Navigator$LWS.prototype;

  function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(args$LWS[0]));

      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return shared$LWS.ReflectApply(originalSendBeacon$LWS, this, args$LWS);
  }

  return [originalSendBeacon$LWS, sendBeacon$LWS];
}

function distortionNavigatorServiceWorkerGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Navigator: Navigator$LWS
    }
  } = record$LWS;
  const originalServiceWorkerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Navigator$LWS.prototype, 'serviceWorker'); // istanbul ignore if: needs default platform behavior test

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return null;
  }

  const get$LWS = () => undefined;

  return [originalServiceWorkerGetter$LWS, get$LWS];
}

function distortionNodeInsertBefore$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    insertBefore: originalInsertBefore$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(node$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert child ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, node$LWS, []))} into ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))},`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertBefore$LWS, this, args$LWS);
  }

  return [originalInsertBefore$LWS, insertBefore$LWS];
}

function distortionNodeValueSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const originalNodeValueSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Node$LWS.prototype, 'nodeValue');

  function nodeValue$LWS(value$LWS) {
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the nodeValue property.
    // istanbul ignore else: needs default platform behavior test
    if (this instanceof Attr$LWS) {
      const ownerEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []); // istanbul ignore if: needs default platform behavior test

      if (ownerEl$LWS === null) {
        return shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
      }

      const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
      const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        return shared$LWS.ReflectApply(distortion$LWS, ownerEl$LWS, [value$LWS]);
      }
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalNodeValueSetter$LWS, this, [value$LWS]);
  }

  return [originalNodeValueSetter$LWS, nodeValue$LWS];
}

function distortionNodeRemoveChild$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    removeChild: originalRemoveChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(child$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot remove ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, child$LWS, []))}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalRemoveChild$LWS, this, args$LWS);
  }

  return [originalRemoveChild$LWS, removeChild$LWS];
}

function distortionNodeReplaceChild$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    replaceChild: originalReplaceChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments. If the "old element"
    // argument is a valid shared element, an exception is thrown.
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(child$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot replace ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, child$LWS, []))}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChild$LWS];
}

const EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const RAW_VALUE_PROPERTY_NAME$LWS = '$$raw$$';
const SANDBOXED_PROPERTY_NAME$LWS = '$$sandboxed$$';

const inlineEvaluatorCall$LWS = () => `document.currentScript['${EVALUATOR_PROPERTY_NAME$LWS}']();`;
/**
 *
 * @param host: Host element for the evaluator
 * @param src: Raw code to be evaluated
 * @param evaluator: No argument function to be returned to the caller.
 * @returns boolean: False if the getter has been accessed previously. True if only redefined
 */


function setEvaluatorFn$LWS(host$LWS, src$LWS, evaluator$LWS) {
  if (shared$LWS.ReflectHas(host$LWS, SANDBOXED_PROPERTY_NAME$LWS)) {
    return false;
  }

  shared$LWS.ReflectDefineProperty(host$LWS, RAW_VALUE_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    value: src$LWS
  });
  shared$LWS.ReflectDefineProperty(host$LWS, EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter
    // source as "[native code]".
    get: shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, () => {
      shared$LWS.ReflectDeleteProperty(host$LWS, EVALUATOR_PROPERTY_NAME$LWS);
      shared$LWS.ReflectDefineProperty(host$LWS, SANDBOXED_PROPERTY_NAME$LWS, {
        __proto__: null
      });
      const ownerDoc$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoOwnerDocumentGetter, host$LWS, []);
      const globalObject$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDefaultViewGetter, ownerDoc$LWS, []);
      return () => evaluator$LWS(globalObject$LWS);
    }, [host$LWS])
  });
  return true;
}

function rawValue$LWS(host$LWS) {
  // @ts-ignore
  return host$LWS[RAW_VALUE_PROPERTY_NAME$LWS];
}

function distortionNodeTextContentGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const originalTextContentGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Node$LWS.prototype, 'textContent');
  const {
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;

  function textContent$LWS() {
    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      const rawSource$LWS = rawValue$LWS(this);

      if (rawSource$LWS !== undefined) {
        return rawSource$LWS;
      }
    }

    return shared$LWS.ReflectApply(originalTextContentGetter$LWS, this, []);
  }

  return [originalTextContentGetter$LWS, textContent$LWS];
}

function distortionNodeTextContentSetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;
  const {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;
  const originalTextContentSetter$LWS = shared$LWS.ObjectLookupOwnSetter(Node$LWS.prototype, 'textContent'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function textContent$LWS(value$LWS) {
    const valueAsString$LWS = shared$LWS.toString(value$LWS); // There are two existence of the attribute textContent, one on Attr and one on Node.
    // This first if statement is checking to figure out which distortion should be applied.
    // The instanceof operator tests to see if the current global object, this, is of the type Attr,
    // while also taking inheritance into consideration.
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the textContent property.
    // istanbul ignore else: needs default platform behavior test

    if (this instanceof Attr$LWS) {
      const ownerEl$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoOwnerElementGetter, this, []); // istanbul ignore if: needs default platform behavior test

      if (ownerEl$LWS === null) {
        return shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      }

      const attrName$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNameGetter, this, []);
      const attrNamespace$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AttrProtoNamespaceURIGetter, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        return shared$LWS.ReflectApply(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
      }
    }

    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      const didAttach$LWS = setEvaluatorFn$LWS(this, valueAsString$LWS, globalObject$LWS => {
        sandboxEvaluator$LWS(valueAsString$LWS, globalObject$LWS);
        shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      });

      if (didAttach$LWS) {
        const overrideContent$LWS = inlineEvaluatorCall$LWS();
        return shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [overrideContent$LWS]);
      }
    } // istanbul ignore else: needs default platform behavior test


    if (isSharedElement$LWS(this)) {
      throw new shared$LWS.LockerSecurityError(`Cannot set textContent of ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, this, []))} elements.`);
    }

    return shared$LWS.ReflectApply(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
  }

  return [originalTextContentSetter$LWS, textContent$LWS];
}

function distortionNotificationCtor$LWS(record$LWS) {
  const {
    globalObject: {
      Notification: originalNotificationCtor$LWS
    }
  } = record$LWS; // istanbul ignore if: needs default platform behavior test

  if (typeof originalNotificationCtor$LWS !== 'function') {
    return null;
  }

  const Notification$LWS = function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = sharedDom$LWS.partialStructuredClone(args$LWS[1]);
    }

    return shared$LWS.ReflectApply(originalNotificationCtor$LWS, this, args$LWS);
  };

  return [originalNotificationCtor$LWS, Notification$LWS];
}

function distortionRangeCreateContextualFragment$LWS(record$LWS) {
  const {
    globalObject: {
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    createContextualFragment: originalCreateContextualFragment$LWS
  } = Range$LWS.prototype;

  function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = htmlSanitizer$LWS.sanitize(tagString$LWS);
      }
    }

    return shared$LWS.ReflectApply(originalCreateContextualFragment$LWS, this, args$LWS);
  }

  return [originalCreateContextualFragment$LWS, createContextualFragment$LWS];
}

function distortionRangeDeleteContents$LWS(record$LWS) {
  const {
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    deleteContents: originalDeleteContents$LWS
  } = Range$LWS.prototype; // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  //
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.

  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range$LWS;
  const originalEndContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'startContainer'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [shared$LWS.ReflectApply(originalEndContainerGetter$LWS, this, []), shared$LWS.ReflectApply(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$LWS(container$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot delete contents of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, container$LWS, [])}.`);
      }
    }

    return shared$LWS.ReflectApply(originalDeleteContents$LWS, this, args$LWS);
  }

  return [originalDeleteContents$LWS, deleteContents$LWS];
}

function distortionRangeExtractContents$LWS(record$LWS) {
  const {
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    extractContents: originalExtractContents$LWS
  } = Range$LWS.prototype; // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  //
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.

  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range$LWS;
  const originalEndContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(AbstractRangeProto$LWS, 'startContainer'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);

  function extractContents$LWS(...args$LWS) {
    const containers$LWS = [shared$LWS.ReflectApply(originalEndContainerGetter$LWS, this, []), shared$LWS.ReflectApply(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$LWS(container$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot extract contents of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, container$LWS, [])}.`);
      }
    }

    return shared$LWS.ReflectApply(originalExtractContents$LWS, this, args$LWS);
  }

  return [originalExtractContents$LWS, extractContents$LWS];
}

function distortionRangeInsertNode$LWS(record$LWS) {
  // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = sharedDom$LWS.getValidator(record$LWS.top);
  const {
    globalObject: {
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    insertNode: originalInsertNode$LWS
  } = Range$LWS.prototype;
  const originalCommonAncestorContainerGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Range$LWS.prototype, 'commonAncestorContainer');

  function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      const commonAncestorContainer$LWS = shared$LWS.ReflectApply(originalCommonAncestorContainerGetter$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(node$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot insert a new child node of ${shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, commonAncestorContainer$LWS, [])}.`);
      }
    }

    return shared$LWS.ReflectApply(originalInsertNode$LWS, this, args$LWS);
  }

  return [originalInsertNode$LWS, insertNode$LWS];
}

function createRangeProtoMethodDistortionFactory$LWS(methodName$LWS) {
  return function distortionContentWindowGetter$LWS(record$LWS) {
    const {
      globalObject: {
        Range: Range$LWS
      }
    } = record$LWS;
    const {
      prototype: RangeProto$LWS
    } = Range$LWS;
    const {
      [methodName$LWS]: originalMethod$LWS
    } = RangeProto$LWS; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
    // "globalObject" because magenta objects (arbitrary user-code created global objects)
    // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
    // content window). Using the provided "globalObject" here would result in receiving a validator
    // bound to the magenta global object, which would erroneously prevent code from interacting
    // with that document's <html>, <head> and <body>.

    const {
      isSharedElement: isSharedElement$LWS
    } = sharedDom$LWS.getValidator(record$LWS.top);

    function method$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS; // istanbul ignore else: needs default platform behavior test

        if (isSharedElement$LWS(node$LWS)) {
          throw new shared$LWS.LockerSecurityError(`Cannot call ${methodName$LWS} with ${shared$LWS.toSafeTemplateStringValue(shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoNodeNameGetter, node$LWS, []))}.`);
        }
      }

      return shared$LWS.ReflectApply(originalMethod$LWS, this, args$LWS);
    }

    return [originalMethod$LWS, method$LWS];
  };
}

const distortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactory$LWS('setEnd');
const distortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactory$LWS('selectNode');
const distortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactory$LWS('selectNodeContents');
const distortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactory$LWS('setEndAfter');
const distortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactory$LWS('setEndBefore');
const distortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactory$LWS('setStart');
const distortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactory$LWS('setStartAfter');
const distortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactory$LWS('setStartBefore');
const distortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactory$LWS('surroundContents');

function distortionServiceWorkerContainer$LWS(record$LWS) {
  const {
    globalObject: {
      ServiceWorkerContainer: ServiceWorkerContainer$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function distortionShadowRootInnerHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  } = record$LWS;
  const originalInnerHTMLSetter$LWS = shared$LWS.ObjectLookupOwnSetter(ShadowRoot$LWS.prototype, 'innerHTML');

  function innerHTML$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalInnerHTMLSetter$LWS, this, [htmlSanitizer$LWS.sanitize(value$LWS)]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionShadowRootModeGetter$LWS(record$LWS) {
  const {
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  } = record$LWS;
  const originalModeGetter$LWS = shared$LWS.ObjectLookupOwnGetter(ShadowRoot$LWS.prototype, 'mode');

  function mode$LWS() {
    return 'closed';
  }

  return [originalModeGetter$LWS, mode$LWS];
}

function distortionSharedWorkerCtor$LWS(record$LWS) {
  const {
    globalObject: {
      SharedWorker: originalSharedWorkerCtor$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return null;
  }

  const SharedWorker$LWS = function SharedWorker$LWS(scriptURL$LWS) {
    throw new shared$LWS.LockerSecurityError(`Cannot create SharedWorker with ${shared$LWS.toSafeTemplateStringValue(scriptURL$LWS)}.`);
  };

  return [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
}

function distortionSharedWorkerProto$LWS(record$LWS) {
  const {
    globalObject: {
      SharedWorker: SharedWorker$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof SharedWorker$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = shared$LWS.ObjectKeys(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (shared$LWS.ReflectApply(shared$LWS.StringProtoStartsWith, key$LWS, [storageRootKey$LWS])) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = shared$LWS.ArrayCtor(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, key$LWS, [storageRootKey$LWS, '']);
  }

  return keys$LWS;
}

const storageToMetaMap$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS); // istanbul ignore if: currently unreachable via tests

  if (storageMeta$LWS === undefined) {
    throw new shared$LWS.LockerSecurityError('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(s$LWS) {
  return new Proxy(s$LWS, {
    get(target$LWS, key$LWS, receiver$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (shared$LWS.ObjectHasOwn(storage$LWS, keyForNamespace$LWS)) {
        return shared$LWS.ReflectGet(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);
      return proto$LWS === null ? undefined : shared$LWS.ReflectGet(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectSet(target$LWS, key$LWS, value$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, descriptor$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const safeDesc$LWS = shared$LWS.toSafeDescriptor(descriptor$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDefineProperty(target$LWS, key$LWS, safeDesc$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectDefineProperty(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectDeleteProperty(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectDeleteProperty(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectGetOwnPropertyDescriptor(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return shared$LWS.ReflectGetOwnPropertyDescriptor(storage$LWS, keyForNamespace$LWS);
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = shared$LWS.ObjectGetOwnPropertySymbols(target$LWS);
      return shared$LWS.ArrayConcat(storageKeys$LWS, localSymbolKeys$LWS);
    },

    has(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return shared$LWS.ReflectHas(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (shared$LWS.ObjectHasOwn(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = shared$LWS.ReflectGetPrototypeOf(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return shared$LWS.ReflectHas(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
}

class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new shared$LWS.LockerSecurityError('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, resolvedKey$LWS, [storageRootKey$LWS, '']);
    }

    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoKey, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
    }

    return shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoGetItem, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
      args$LWS[1] = shared$LWS.toString(args$LWS[1]);
    }

    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoSetItem, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, shared$LWS.toString(args$LWS[0]));
    }

    shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      shared$LWS.ReflectApply(sharedDom$LWS.StorageProtoRemoveItem, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const target$LWS = {
    __proto__: PatchedStorage$LWS.prototype
  };
  shared$LWS.markLiveObject(target$LWS);
  const proxy$LWS = createStorageProxy$LWS(target$LWS);
  const storageMeta$LWS = {
    proxy: proxy$LWS,
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  };
  storageToMetaMap$LWS.set(proxy$LWS, storageMeta$LWS);
  storageToMetaMap$LWS.set(target$LWS, storageMeta$LWS);
  return proxy$LWS;
}

const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(PatchedStorageProto$LWS, 'length');

function createDistortionStorageFactory$LWS(storageName$LWS) {
  return function distortionStorageFactory$LWS(record$LWS) {
    const {
      globalObject: globalObject$LWS,
      key: key$LWS
    } = record$LWS; // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.

    let originalStorageObject$LWS;

    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS]; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {} // istanbul ignore if: currently unreachable via tests


    if (!shared$LWS.isObject(originalStorageObject$LWS)) {
      return null;
    }

    const patchedStorageObject$LWS = createStorage$LWS(originalStorageObject$LWS, getStorageRootKey$LWS(key$LWS));
    return [originalStorageObject$LWS, patchedStorageObject$LWS];
  };
}

function distortionStorageLength$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(Storage$LWS.prototype, 'length');
  return [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
}

function distortionStorageGetItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    getItem: originalStorageGetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
}

function distortionStorageSetItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    setItem: originalStorageSetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
}

function distortionStorageKey$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    key: originalStorageKey$LWS
  } = Storage$LWS.prototype;
  return [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
}

function distortionStorageRemoveItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    removeItem: originalStorageRemoveItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
}

function distortionStorageClear$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    clear: originalStorageClear$LWS
  } = Storage$LWS.prototype;
  return [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
}

function distortionStorage$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  return [Storage$LWS, PatchedStorage$LWS];
}

const distortionLocalStorage$LWS = createDistortionStorageFactory$LWS('localStorage');
const distortionSessionStorage$LWS = createDistortionStorageFactory$LWS('sessionStorage');

function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, el$LWS, [attrName$LWS])) {
      const originalAttributeValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, el$LWS, [attrName$LWS]);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);

        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'from');
      distortAttribute$LWS(this, 'to');
      distortAttribute$LWS(this, 'values');
    }
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', sharedDom$LWS.NAMESPACE_DEFAULT, attributeName$LWS);
  return null;
}

function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function from$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', sharedDom$LWS.NAMESPACE_DEFAULT, from$LWS);
  return null;
}

function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', sharedDom$LWS.NAMESPACE_DEFAULT, to$LWS);
  return null;
}

function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoSplit, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = htmlSanitizer$LWS.sanitizeSvgHref(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = shared$LWS.ReflectApply(shared$LWS.ArrayProtoJoin, valuesSplit$LWS, [';']);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', sharedDom$LWS.NAMESPACE_DEFAULT, values$LWS);
  return null;
}

function distortionSVGElementDatasetGetter$LWS(record$LWS) {
  const {
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  } = record$LWS;
  const originalDatasetGetter$LWS = shared$LWS.ObjectLookupOwnGetter(SVGElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionSVGScriptElementHrefAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGScriptElement: SVGScriptElement$LWS
    }
  } = record$LWS;
  registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', sharedDom$LWS.NAMESPACE_XLINK, createScriptDistortion$LWS(record$LWS, 'href', sharedDom$LWS.SVGElementProtoDatasetGetter));
  registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', sharedDom$LWS.NAMESPACE_XLINK, createScriptDistortion$LWS(record$LWS, 'xlink:href', sharedDom$LWS.SVGElementProtoDatasetGetter));
  return null;
}

function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGSetElement: SVGSetElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, el$LWS, [attrName$LWS])) {
      const originalAttributeValue$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, el$LWS, [attrName$LWS]); // istanbul ignore else: needs default platform behavior test

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          shared$LWS.ReflectApply(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'to');
    }
  }

  registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', sharedDom$LWS.NAMESPACE_DEFAULT, attributeName$LWS);
  return null;
}

function distortionSVGSetElementToAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGSetElement: SVGSetElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, this, ['attributeName']) === 'href') {
      value$LWS = htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
    }

    shared$LWS.ReflectApply(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', sharedDom$LWS.NAMESPACE_DEFAULT, to$LWS);
  return null;
}

function createDistortionHrefAttributeFactory$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactory$LWS(record$LWS) {
    const {
      globalObject: {
        SVGUseElement: SVGUseElement$LWS
      }
    } = record$LWS;
    const {
      setAttribute: originalSetAttribute$LWS,
      setAttributeNS: originalSetAttributeNS$LWS
    } = Element.prototype;

    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
      /* istanbul ignore next: needs default platform behavior test */
      value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
      shared$LWS.ReflectApply(originalSetAttributeNS$LWS, this, [sharedDom$LWS.NAMESPACE_XLINK, attributeName$LWS, returnValue$LWS]);
    }

    registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, sharedDom$LWS.NAMESPACE_XLINK, xlinkNamespaceDistortion$LWS);

    if (attributeName$LWS === 'href') {
      const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
        /* istanbul ignore next: needs default platform behavior test */
        value$LWS : htmlSanitizer$LWS.sanitizeSvgHref(value$LWS);
        shared$LWS.ReflectApply(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
      };

      registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, sharedDom$LWS.NAMESPACE_DEFAULT, defaultNamespaceDistortion$LWS);
    }

    return null;
  };
}

const distortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('href');
const distortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('xlink:href');

function distortionTrustedTypePolicyFactoryCreatePolicy$LWS(record$LWS) {
  const {
    globalObject: {
      TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof TrustedTypePolicyFactory$LWS !== 'function') {
    return null;
  }

  const {
    createPolicy: originalCreatePolicy$LWS
  } = TrustedTypePolicyFactory$LWS.prototype;

  const createPolicy$LWS = function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] :
    /* istanbul ignore next: needs default platform behavior test */
    undefined; // istanbul ignore else: needs default platform behavior test

    if (name$LWS === 'default') {
      throw new shared$LWS.LockerSecurityError(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    } // istanbul ignore next: needs default platform behavior test


    return shared$LWS.ReflectApply(originalCreatePolicy$LWS, this, args$LWS);
  };

  return [originalCreatePolicy$LWS, createPolicy$LWS];
}

const HTML_MIME_TYPES_LIST$LWS = shared$LWS.toSafeArray(['text/html', 'image/svg+xml', 'text/xml']);

function distortionURLCreateObjectURL$LWS(record$LWS) {
  const {
    globalObject: {
      URL: URL$LWS
    }
  } = record$LWS;
  const {
    createObjectURL: originalCreateObjectURL$LWS
  } = URL$LWS;
  const {
    isEqualDomString: isEqualDomString$LWS,
    isMediaSourceObject: isMediaSourceObject$LWS
  } = sharedDom$LWS.getValidator(record$LWS);

  function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [blobObject$LWS]); // MediaSource does not share the same proto object as Blob or File.
    // It can still be used with createObjectURL however we need to treat it separately.
    // MediaSource does not accept plain text input as Blob and File and does not have a MIME type.

    if (isMediaSourceObject$LWS(blobObject$LWS)) {
      return outURL$LWS;
    }

    const blobType$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoTypeGetter, blobObject$LWS, []);

    if (blobType$LWS === '') {
      // Browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      const plainTextBlob$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSlice, blobObject$LWS, [0, undefined, 'text/plain']);
      return shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
    }

    const loweredBlobType$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, blobType$LWS, []);

    if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
      const blobSize$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSizeGetter, blobObject$LWS, []);
      const normalizedBlob$LWS = shared$LWS.ReflectApply(sharedDom$LWS.BlobProtoSlice, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
      sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
      outURL$LWS = shared$LWS.ReflectApply(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new sharedDom$LWS.XhrCtor();
      shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoOpen, xhr$LWS, ['GET', outURL$LWS, false]);
      shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoSend, xhr$LWS, []);
      const sanitizer$LWS = htmlSanitizer$LWS.blobSanitizer();
      const responseText$LWS = shared$LWS.ReflectApply(sharedDom$LWS.XhrProtoResponseTextGetter, xhr$LWS, []);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
        throw new shared$LWS.LockerSecurityError(`Cannot 'createObjectURL' using a unsecure ${shared$LWS.toSafeTemplateStringValue(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (sharedUrl$LWS.isMIMETypeAllowed(loweredBlobType$LWS)) {
      return outURL$LWS;
    }

    sharedDom$LWS.URLRevokeObjectURL(outURL$LWS);
    throw new shared$LWS.LockerSecurityError('Unsupported MIME type.');
  }

  return [originalCreateObjectURL$LWS, createObjectURL$LWS];
}

function distortionWindowFetch$LWS(record$LWS) {
  const {
    globalObject: {
      fetch: originalFetch$LWS
    }
  } = record$LWS;

  function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.ReflectApply(sharedDom$LWS.RequestProtoURLGetter, url$LWS, []));
      } else {
        parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return shared$LWS.PromiseReject(new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${shared$LWS.toSafeTemplateStringValue(normalizedURL$LWS)}`));
      }
    }

    return shared$LWS.ReflectApply(originalFetch$LWS, this, args$LWS);
  }

  return [originalFetch$LWS, fetch$LWS];
}
/* eslint-disable class-methods-use-this, max-classes-per-file */
// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target


class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }

  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }

  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }

  isExtensible(_target$LWS) {
    return true;
  }

  ownKeys(_target$LWS) {
    return [];
  }

  preventExtensions(_target$LWS) {
    return true;
  }

  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }

  setPrototypeOf(_target$LWS) {
    return false;
  }

}

shared$LWS.ReflectSetPrototypeOf(BaseFrameHandler$LWS.prototype, null);
shared$LWS.ObjectFreeze(BaseFrameHandler$LWS.prototype);

class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

shared$LWS.ObjectFreeze(ShadowFramesPrototypeHandler$LWS.prototype);

function distortionWindowFramesGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const originalWindowFramesGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'frames'); // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return null;
  }

  let framesProxy$LWS;

  const frames$LWS = function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      const WindowPrototype$LWS = shared$LWS.ReflectGetPrototypeOf(globalObject$LWS);
      const WindowProperties$LWS = shared$LWS.ReflectGetPrototypeOf(WindowPrototype$LWS); // Wrap `WindowLengthGetter` in bound function to obscure the getter
      // source as "[native code]".

      const framesLengthGetter$LWS = shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, sharedDom$LWS.WindowLengthGetter, [globalObject$LWS]); // Wrap `noop` in bound function to obscure the setter source as
      // "[native code]".

      const framesLengthSetter$LWS = shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, shared$LWS.noop, []);

      const getFrameByIndexKey$LWS = key$LWS => {
        const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;

        if (possibleIndex$LWS > -1 && shared$LWS.NumberIsInteger(possibleIndex$LWS) && possibleIndex$LWS < shared$LWS.ReflectApply(sharedDom$LWS.WindowLengthGetter, globalObject$LWS, [])) {
          const value$LWS = shared$LWS.ObjectLookupOwnValue(globalObject$LWS, key$LWS);

          if (sharedDom$LWS.isWindow(value$LWS)) {
            return value$LWS;
          }
        }

        return undefined;
      };

      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
        !shared$LWS.ObjectHasOwn(globalObject$LWS, key$LWS) && // ...Or its prototype.
        !shared$LWS.ObjectHasOwn(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = shared$LWS.ObjectLookupOwnValue(WindowProperties$LWS, key$LWS);

          if (sharedDom$LWS.isWindow(value$LWS)) {
            return value$LWS;
          }
        }

        return undefined;
      };

      const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? shared$LWS.ReflectApply(sharedDom$LWS.WindowLengthGetter, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);

      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getValueByKey$LWS(key$LWS);
          return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
          shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS) : // window.frames.length
          // window.frames[n]
          // window.frames['n']
          value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              get: framesLengthGetter$LWS,
              set: framesLengthSetter$LWS
            };
          }

          const value$LWS = getFrameByIndexKey$LWS(key$LWS);

          if (value$LWS) {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return shared$LWS.ReflectHas(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
        }

        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = shared$LWS.ArrayCtor(length$LWS + 1);

          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }

          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }

      }

      shared$LWS.ObjectFreeze(ShadowFrameHandler$LWS.prototype);

      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
          shared$LWS.ReflectGet(target$LWS, key$LWS, receiver$LWS) :
          /* istanbul ignore next: needs default platform behavior test */
          value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);

          if (value$LWS === undefined) {
            return value$LWS;
          }

          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }

        has(target$LWS, key$LWS) {
          return shared$LWS.ReflectHas(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
        }

        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const descMap$LWS = shared$LWS.ObjectGetOwnPropertyDescriptors(WindowProperties$LWS);
          shared$LWS.ReflectSetPrototypeOf(descMap$LWS, null);

          for (const key$LWS in descMap$LWS) {
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = descMap$LWS[key$LWS];

              if (shared$LWS.ObjectHasOwn(unsafeDesc$LWS, 'value') && sharedDom$LWS.isWindow(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }

          return keys$LWS;
        }

      }

      shared$LWS.ObjectFreeze(ShadowWindowPropertiesHandler$LWS.prototype); // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.

      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = shared$LWS.ObjectFreeze(new ShadowFrameHandler$LWS());
      const shadowFramesPrototypeHandler$LWS = shared$LWS.ObjectFreeze(new ShadowFramesPrototypeHandler$LWS());
      const shadowWindowPropertiesHandler$LWS = shared$LWS.ObjectFreeze(new ShadowWindowPropertiesHandler$LWS());
      const framesPrototypeProxy$LWS = new shared$LWS.ProxyCtor(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new shared$LWS.ProxyCtor(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      shared$LWS.ReflectSetPrototypeOf(shadowFrames$LWS, framesPrototypeProxy$LWS);
      shared$LWS.ReflectSetPrototypeOf(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      framesProxy$LWS = new shared$LWS.ProxyCtor(shadowFrames$LWS, shadowFramesHandler$LWS);
    }

    return framesProxy$LWS;
  };

  return [originalWindowFramesGetter$LWS, frames$LWS];
}

function distortionWindowGetComputedStyle$LWS(record$LWS) {
  const {
    globalObject: {
      getComputedStyle: originalGetComputedStyle$LWS
    }
  } = record$LWS;

  function getComputedStyle$LWS(...args$LWS) {
    return shared$LWS.toLiveValue(shared$LWS.ReflectApply(originalGetComputedStyle$LWS, this, args$LWS));
  }

  return [originalGetComputedStyle$LWS, getComputedStyle$LWS];
}

function distortionWindowLengthGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const originalLengthGetter$LWS = shared$LWS.ObjectLookupOwnGetter(globalObject$LWS, 'length'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalLengthGetter$LWS !== 'function') {
    return null;
  }

  const length$LWS = function length$LWS() {
    return 0;
  };

  return [originalLengthGetter$LWS, length$LWS];
}

function distortionWindowOnstorage$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const {
    Window: Window$LWS
  } = globalObject$LWS;
  const originalOnstorageSetter$LWS = shared$LWS.ObjectLookupOwnSetter(globalObject$LWS, 'onstorage'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return null;
  }

  const onstorage$LWS = function onstorage$LWS() {
    throw new shared$LWS.LockerSecurityError('Cannot set window.onstorage.');
  };

  registerEventTargetRestriction$LWS(record$LWS, Window$LWS, 'storage');
  return [originalOnstorageSetter$LWS, onstorage$LWS];
}

function distortionWindowOpen$LWS(record$LWS) {
  const {
    globalObject: {
      open: originalWindowOpen$LWS
    }
  } = record$LWS;

  function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    return shared$LWS.ReflectApply(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
  }

  return [originalWindowOpen$LWS, open$LWS];
}

function distortionWindowPostMessage$LWS(record$LWS) {
  const {
    globalObject: {
      postMessage: originalPostMessage$LWS
    }
  } = record$LWS;

  function postMessage$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = sharedDom$LWS.partialStructuredClone(args$LWS);
    }

    return shared$LWS.ReflectApply(originalPostMessage$LWS, this, args$LWS);
  }

  return [originalPostMessage$LWS, postMessage$LWS];
}

function distortionWindowSetInterval$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setInterval: originalSetInterval$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function setInterval$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const sourceText$LWS = sharedDom$LWS.transformUncompiledSourceText(shared$LWS.toString(callback$LWS)); // Replace callback parameter.

        args$LWS[0] = () => {
          sandboxEvaluator$LWS(sourceText$LWS, UNCOMPILED_CONTEXT$LWS);
        };
      }
    }

    return shared$LWS.ReflectApply(originalSetInterval$LWS, this, args$LWS);
  }

  return [originalSetInterval$LWS, setInterval$LWS];
}

function distortionWindowSetTimeout$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setTimeout: originalSetTimeout$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function setTimeout$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const sourceText$LWS = sharedDom$LWS.transformUncompiledSourceText(shared$LWS.toString(callback$LWS)); // Replace callback parameter.

        args$LWS[0] = () => {
          sandboxEvaluator$LWS(sourceText$LWS, UNCOMPILED_CONTEXT$LWS);
        };
      }
    }

    return shared$LWS.ReflectApply(originalSetTimeout$LWS, this, args$LWS);
  }

  return [originalSetTimeout$LWS, setTimeout$LWS];
}

function distortionWindowStructuredClone$LWS(record$LWS) {
  const {
    globalObject: {
      structuredClone: originalStructuredClone$LWS
    }
  } = record$LWS; // istanbul ignore if: currently unreachable via tests

  if (typeof originalStructuredClone$LWS !== 'function') {
    return null;
  }

  const structuredClone$LWS = function structuredClone$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = sharedDom$LWS.partialStructuredClone(args$LWS);
    }

    return shared$LWS.ReflectApply(originalStructuredClone$LWS, this, args$LWS);
  };

  return [originalStructuredClone$LWS, structuredClone$LWS];
}

function distortionWorkerCtor$LWS(record$LWS) {
  const {
    globalObject: {
      Worker: originalWorkerCtor$LWS
    }
  } = record$LWS;

  function Worker$LWS(scriptURL$LWS) {
    throw new shared$LWS.LockerSecurityError(`Cannot create Worker with ${shared$LWS.toSafeTemplateStringValue(scriptURL$LWS)}.`);
  }

  return [originalWorkerCtor$LWS, Worker$LWS];
}

function distortionWorkerProto$LWS(record$LWS) {
  const {
    globalObject: {
      Worker: {
        prototype: originalPrototype$LWS
      }
    }
  } = record$LWS;
  return [originalPrototype$LWS, shared$LWS.createRevokedProxy(originalPrototype$LWS)];
}

function distortionXMLHttpRequestOpen$LWS(record$LWS) {
  const {
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const {
    open: originalOpen$LWS
  } = XMLHttpRequest$LWS.prototype;

  function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = sharedUrl$LWS.parseURL(shared$LWS.toString(url$LWS));

      if (!sharedUrl$LWS.isValidURL(parsedURL$LWS)) {
        throw new shared$LWS.LockerSecurityError(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    shared$LWS.ReflectApply(originalOpen$LWS, this, args$LWS);
  }

  return [originalOpen$LWS, open$LWS];
}

function distortionXMLHttpRequestResponseGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS,
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const originalResponseGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'response');

  function response$LWS() {
    const rawResponse$LWS = shared$LWS.ReflectApply(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? htmlSanitizer$LWS.sanitizeDocument(rawResponse$LWS) :
    /* istanbul ignore next: needs default platform behavior test */
    rawResponse$LWS;
  }

  return [originalResponseGetter$LWS, response$LWS];
}

function distortionXMLHttpRequestResponseXMLGetter$LWS(record$LWS) {
  const {
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const originalResponseXMLGetter$LWS = shared$LWS.ObjectLookupOwnGetter(XMLHttpRequest$LWS.prototype, 'responseXML');

  function responseXML$LWS() {
    const rawResponseXML$LWS = shared$LWS.ReflectApply(originalResponseXMLGetter$LWS, this, []);
    return htmlSanitizer$LWS.sanitizeDocument(rawResponseXML$LWS);
  }

  return [originalResponseXMLGetter$LWS, responseXML$LWS];
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const internalDistortionFactories$LWS = shared$LWS.ObjectFreeze([// CSSStyleRule
distortionCSSStyleRuleStyleGetter$LWS, // Document
distortionDocumentDomainSetter$LWS, distortionDocumentExecCommand$LWS, distortionDocumentOpen$LWS, // DOMParser
distortionDOMParserParseFromString$LWS, // Element
distortionElementAttachShadow$LWS, distortionElementAttributesGetter$LWS, distortionElementInnerHTMLSetter$LWS, distortionElementOuterHTMLSetter$LWS, distortionElementInsertAdjacentHTML$LWS, distortionElementRemove$LWS, distortionElementReplaceChildren$LWS, distortionElementReplaceWith$LWS, // Event
distortionEventComposedPath$LWS, distortionEventPathGetter$LWS, // Function
distortionFunction$LWS, // History
distortionHistoryPushState$LWS, distortionHistoryReplaceState$LWS, // HTMLElement
distortionHTMLElementDatasetGetter$LWS, distortionHTMLElementInnerTextSetter$LWS, distortionHTMLElementOuterTextSetter$LWS, distortionHTMLElementStyleGetter$LWS, // HTMLIFrameElement
distortionHTMLIFrameElementSrcSetter$LWS, // HTMLLinkElement
distortionHTMLLinkElementRelSetter$LWS, distortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
distortionHTMLObjectElementDataSetter$LWS, // HTMLScriptElement
distortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
distortionIDBObjectStoreAdd$LWS, distortionIDBObjectStorePut$LWS, // Navigator
distortionNavigatorSendBeacon$LWS, distortionNavigatorServiceWorkerGetter$LWS, // Node
distortionNodeRemoveChild$LWS, distortionNodeReplaceChild$LWS, // Notification
distortionNotificationCtor$LWS, // Range
distortionRangeCreateContextualFragment$LWS, distortionRangeDeleteContents$LWS, distortionRangeExtractContents$LWS, distortionRangeInsertNode$LWS, distortionRangeSelectNode$LWS, distortionRangeSelectNodeContents$LWS, distortionRangeSetEnd$LWS, distortionRangeSetEndAfter$LWS, distortionRangeSetEndBefore$LWS, distortionRangeSetStart$LWS, distortionRangeSetStartAfter$LWS, distortionRangeSetStartBefore$LWS, distortionRangeSurroundContents$LWS, // ServiceWorkerContainer
distortionServiceWorkerContainer$LWS, // ShadowRoot
distortionShadowRootInnerHTMLSetter$LWS, distortionShadowRootModeGetter$LWS, // SharedWorker
distortionSharedWorkerCtor$LWS, distortionSharedWorkerProto$LWS, // Storage
distortionStorageLength$LWS, distortionStorageGetItem$LWS, distortionStorageSetItem$LWS, distortionStorageKey$LWS, distortionStorageRemoveItem$LWS, distortionStorageClear$LWS, distortionStorage$LWS, // SVGAnimateElement
distortionSVGAnimateElementFromAttribute$LWS, distortionSVGAnimateElementToAttribute$LWS, distortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
distortionSVGElementDatasetGetter$LWS, // SVGSetElement
distortionSVGSetElementToAttribute$LWS, // SVGUseElement
distortionSVGUseElementHrefAttribute$LWS, distortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
distortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
distortionURLCreateObjectURL$LWS, // Window
distortionWindowFetch$LWS, distortionWindowFramesGetter$LWS, distortionWindowGetComputedStyle$LWS, distortionWindowLengthGetter$LWS, distortionWindowOpen$LWS, distortionWindowPostMessage$LWS, distortionWindowStructuredClone$LWS, // Worker
distortionWorkerCtor$LWS, distortionWorkerProto$LWS, // XHR
distortionXMLHttpRequestOpen$LWS, distortionXMLHttpRequestResponseGetter$LWS, distortionXMLHttpRequestResponseXMLGetter$LWS]);
const internalKeyedDistortionFactories$LWS = shared$LWS.ObjectFreeze([// Attr
distortionAttrValueSetter$LWS, // Aura
distortionAuraUtilGlobalEval$LWS, // CacheStorage
distortionCacheStorageDelete$LWS, distortionCacheStorageHas$LWS, distortionCacheStorageKeys$LWS, distortionCacheStorageMatch$LWS, distortionCacheStorageOpen$LWS, // CookieStore
distortionCookieStoreDelete$LWS, distortionCookieStoreGet$LWS, distortionCookieStoreGetAll$LWS, distortionCookieStoreOnChange$LWS, distortionCookieStoreSet$LWS, // Document
distortionDocumentCookieGetter$LWS, distortionDocumentCookieSetter$LWS, distortionDocumentReplaceChildren$LWS, // CustomElementRegistry
distortionCustomElementRegistryGet$LWS, // Element
distortionElementSetAttribute$LWS, distortionElementSetAttributeNode$LWS, distortionElementSetAttributeNodeNS$LWS, distortionElementSetAttributeNS$LWS, distortionElementToggleAttribute$LWS, // EventTarget
distortionEventTargetAddEventListener$LWS, // HTMLScriptElement,
distortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
distortionNamedNodeMapSetNamedItem$LWS, distortionNamedNodeMapSetNamedItemNS$LWS, // Node
distortionNodeValueSetter$LWS, distortionNodeTextContentGetter$LWS, distortionNodeTextContentSetter$LWS, // Storage
distortionLocalStorage$LWS, distortionSessionStorage$LWS, // SVGAnimationElement
distortionSVGAnimateElementAttributeNameAttribute$LWS, // SVGScriptElement
distortionSVGScriptElementHrefAttribute$LWS, // SVGSetElement
distortionSVGSetElementAttributeNameAttribute$LWS, // Window
distortionWindowOnstorage$LWS, distortionWindowSetInterval$LWS, distortionWindowSetTimeout$LWS]);
const externalDistortionFactories$LWS = shared$LWS.ObjectFreeze(shared$LWS.ArrayConcat(internalDistortionFactories$LWS, [// Element
distortionElementAfter$LWS, distortionElementAppend$LWS, distortionElementBefore$LWS, distortionElementInsertAdjacentElement$LWS, distortionElementPrepend$LWS, distortionElementShadowRootGetter$LWS, // Node
// The distortionNodeAppendChild distortion is temporarily disabled until W-10409618 is resolved
// distortionNodeAppendChild,
distortionNodeInsertBefore$LWS]));
const externalKeyedDistortionFactories$LWS = internalKeyedDistortionFactories$LWS;
const evaluationDistortionFactories$LWS = shared$LWS.ObjectFreeze([// eval
distortionEval$LWS]);
const opaqueDistortionFactories$LWS = shared$LWS.ObjectFreeze([// Window
distortionWindowPostMessage$LWS]);
const DocumentBlockedProperties$LWS = shared$LWS.ObjectFreeze(['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln']);
const ElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen']);
const HTMLElementBlockedAttributes$LWS = shared$LWS.ObjectFreeze(['nonce']);
const HTMLElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['nonce', 'onrejectionhandled', 'onunhandledrejection']);
const HTMLEmbedElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['getSVGDocument']); // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = shared$LWS.ObjectFreeze(['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc']);
const HTMLIFrameElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc']);
const HTMLObjectElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['getSVGDocument']);
const HTMLScriptElementBlockedAttributes$LWS = shared$LWS.ObjectFreeze(['nonce']);
const HTMLScriptElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['nonce']);
const SVGElementBlockedAttributes$LWS = shared$LWS.ObjectFreeze(['nonce']);
const SVGElementBlockedProperties$LWS = shared$LWS.ObjectFreeze(['nonce']);
const XSLTProcessorBlockedProperties$LWS = shared$LWS.ObjectFreeze(['transformToDocument', 'transformToFragment']);
exports.CustomElementRegistryBlockedProperties = CustomElementRegistryBlockedProperties$LWS;
exports.DocumentBlockedProperties = DocumentBlockedProperties$LWS;
exports.ElementBlockedProperties = ElementBlockedProperties$LWS;
exports.HTMLElementBlockedAttributes = HTMLElementBlockedAttributes$LWS;
exports.HTMLElementBlockedProperties = HTMLElementBlockedProperties$LWS;
exports.HTMLEmbedElementBlockedProperties = HTMLEmbedElementBlockedProperties$LWS;
exports.HTMLIFrameElementBlockedAttributes = HTMLIFrameElementBlockedAttributes$LWS;
exports.HTMLIFrameElementBlockedProperties = HTMLIFrameElementBlockedProperties$LWS;
exports.HTMLObjectElementBlockedProperties = HTMLObjectElementBlockedProperties$LWS;
exports.HTMLScriptElementBlockedAttributes = HTMLScriptElementBlockedAttributes$LWS;
exports.HTMLScriptElementBlockedProperties = HTMLScriptElementBlockedProperties$LWS;
exports.SVGElementBlockedAttributes = SVGElementBlockedAttributes$LWS;
exports.SVGElementBlockedProperties = SVGElementBlockedProperties$LWS;
exports.XSLTProcessorBlockedProperties = XSLTProcessorBlockedProperties$LWS;
exports.createAttributeDistortions = createAttributeDistortions$LWS;
exports.createBlockedPropertyDistortionFactories = createBlockedPropertyDistortionFactories$LWS;
exports.distortBlockedAttributes = distortBlockedAttributes$LWS;
exports.evaluationDistortionFactories = evaluationDistortionFactories$LWS;
exports.externalDistortionFactories = externalDistortionFactories$LWS;
exports.externalKeyedDistortionFactories = externalKeyedDistortionFactories$LWS;
exports.internalDistortionFactories = internalDistortionFactories$LWS;
exports.internalKeyedDistortionFactories = internalKeyedDistortionFactories$LWS;
exports.opaqueDistortionFactories = opaqueDistortionFactories$LWS;
/*! version: 0.16.27 */
