# Server-side rendering (SSR) in LWR

## Overview

### What is SSR?

[Lightning Web Components (LWC)](https://lwc.dev/) is a framework for creating client-side applications. However, these components can also be rendered as an HTML string on the **server**. LWR sends these strings to the client, where they can be ["hydrated"](#client-hydration) to create an interactive web app.

### Why use SSR?

With SSR, the browser does not need to wait for all the JavaScript to download and execute before displaying component markup. This results in faster time-to-content, especially on slower devices or internet connections. It also makes the content accessible to search engine crawlers, improving SEO.

That said, SSR is best used for apps where time-to-content is important, such as B2C websites. The benefits of SSR should be weighed against the costs: higher server load, increased build & deployment complexity, developing server-compatible component code.

## Using SSR with LWR

Learn how to use SSR in your LWR apps.

### Turn on SSR

SSR is activated on a per-route basis by changing `bootstrap.experimentalSSR` to `true`:

```json
// my-app/lwr.config.json
{
    "routes": [
        {
            "id": "ssr-page",
            // parameterized path
            "path": "/category/:category",
            // content template
            "contentTemplate": "$contentDir/page.html",
            "bootstrap": {
                // turn on SSR for the page here
                "experimentalSSR": true
            }
        }
    ]
}
```

### Building SSR pages

When a route with `experimentalSSR` is requested, LWR will use [LWC'S `renderComponent()` function](https://rfcs.lwc.dev/rfcs/lwc/0112-server-engine) to SSR each root component on the page. This is done whether the page is generated at runtime, or pre-built using `generateStaticSite()`.

> A "root component" is any lwc in an app route's [content template, layout template](https://github.com/salesforce/lwr-recipes/tree/main/packages/templating#templates), or [`rootComponent` configuration](https://github.com/salesforce/lwr-recipes/blob/main/doc/config.md#routes).

LWR will automatically pass any root component attributes from a [template](https://github.com/salesforce/lwr-recipes/tree/main/packages/templating#templates) as [public properties](https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reactivity_public) during SSR. For example, `my/root` will receive `{ limit: '10' }`.

```html
<!-- my-app/src/content/page.html -->
<section>
    <!-- "limit" is a template attribute property -->
    <my-root limit="10"></my-root>
</section>
```

#### Limitations

There are restrictions on component code for it to successfully render on the server. The `renderComponent()` function executes the [`constructor` and `connectedCallback`](https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reference_lifecycle_hooks) of each component. These functions must be free of browser-specific code, such as DOM manipulation, eventing, and fetching data.

Because of this, the [`@lwrjs/router`](https://github.com/salesforce/lwr-recipes/blob/main/doc/navigation.md) is not supported with SSR.

### Preloading data during SSR

Many components depend on external data. LWR provides a `getProps()` hook for developers to fetch that data on the server. LWR passes the data to the component during SSR as [properties](<(https://developer.salesforce.com/docs/component-library/documentation/en/lwc/reactivity_public)>).

> **Important**: This hook is **only** run for root components.

The `getProps()` hook is exported as a function from a root component module:

```ts
// my-app/src/modules/my/root/root.ts
import { LightningElement, api } from 'lwc';
import type { PropsRequestContext, PropsResponse } from '@lwrjs/types';

export default class MyRoot extends LightningElement {
    @api data: SomeDataType[] = [];
}

export async function getProps(context: PropsRequestContext): Promise<PropsResponse> {
    // "/category/books" => context.params = { category: 'books' }
    const category = context.params.category;
    // page.html template => context.props = { limit: '10' }
    const num = context.props.limit || '25';
    const res = await context.fetch(`https://www.some-api.com/${category}?lang=${context.locale}&num=${num}`);
    const data = await res.json();
    return {
        props: {
            // will be passed to the root component as props
            data,
            ...context.props, // pass the template props through, if desired
        },
    };
}
```

```ts
type GetPropsHook = (context: PropsRequestContext) => Promise<PropsResponse>;

interface PropsRequestContext {
    // existing props from template attributes
    props: Json;
    // values from a parameterized route defined in lwr.config.json
    params: { [key: string]: string };
    // search parameters from the request URL
    query: { [key: string]: string };
    // locale string for the request, eg: 'en-US'
    locale: string;
    // server-friendly fetch() function for accessing data
    fetch: Function;
}

interface PropsResponse {
    // serializable props for the root component
    props: Json;
}

type Json = undefined | null | boolean | number | string | Json[] | { [prop: string]: Json };
```

Notes:

-   The `getProps()` hook can choose to merge the properties from `PropsRequestContext.props` into its return object, or it can ignore/discard them.
-   The author of `getProps()` is responsible for validating the `params` and `query` from `PropsRequestContext` before using them.
-   The **same** `props` returned by `getProps()` are passed to the component during server rendering **and** client hydration.

### Client hydration

When SSRed component HTML reaches the browser, each root component is automatically hydrated. LWR uses the [LWC `hydrateComponent()` API](https://rfcs.lwc.dev/rfcs/lwc/0117-ssr-rehydration) to do so. Hydrating a component starts its component lifecycle and makes it interactive.
