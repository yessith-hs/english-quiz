import { kebabCaseToModuleSpecifer } from '@lwrjs/shared-utils';
import { LWC_SSR_PREFIX, SSR_PROPS_ATTR, SSR_PROPS_KEY, getPropsId } from '../identity.js';
import { ssrElement } from './ssr-element.js';
/**
 * This is a view transformer run by the view registry during linking of a page document/route (configured in lwr.config.json[routes]).
 * If the "experimentalSSR" bootstrap flag is on for the route, it will server-side render (SSR) each custom element found in the page HTML.
 *
 * SSR Flow:
 *  1. There is a request to generate a view (ie: page document) via the UI middleware or static site generation
 *  2. During view generation, the view registry runs all the registered view transformers (including this one)
 *  3. This view transformer links the SSRed string for EVERY custom element (ie: root component) found in the page document:
 *      a) It requests a module which SSRs a given custom element, generated by "lwc-ssr/moduleProvider"
 *      b) A bundle is created for the generated SSR module (see "./ssr-element")
 *      c) The bundle code is run inside a worker (see "./ssr-element"), with context stored in "workerData"
 *      d) RootComponent.getProps() is run to preload data, if available
 *      e) The generated SSR module (running the worker) passes the SSRed code string back to the main thread
 *      f) The SSRed string is used to overwrite/link each custom element (eg: "<c-app></c-app>") in the document (see "stringBuilder.overwrite")
 *      g) A script containing all the serialized properties is added for hydration
 * 4. The view/page document now contains SSRed components, which will be sent to the client
 * 5. During bootstrap on the client, the "lwr/initSsr" module will hydrate ALL the custom elements on the page
 */
export default function lwcSsrViewTranformer(options, { moduleBundler }) {
    return {
        name: 'ssr-lwc-transformer',
        async link(stringBuilder, viewContext, { customElements }) {
            // SSR currently does not support locker because the module constructor returns undefined
            // and the call to renderComponent would fail
            if (process.env.LOCKER === 'true') {
                return;
            }
            if (viewContext.view.bootstrap?.experimentalSSR) {
                // Gather all the SSRable custom elements (ie: root components) into 1 list
                const ssrModules = [];
                for (const { tagName, location, props } of customElements) {
                    if (location) {
                        const { startOffset, endOffset } = location;
                        const moduleSpecifier = kebabCaseToModuleSpecifer(tagName);
                        ssrModules.push({
                            startOffset,
                            endOffset,
                            props,
                            tagName,
                            specifier: `${LWC_SSR_PREFIX}${moduleSpecifier}`,
                        });
                    }
                }
                // SSR and gather the properties for each eligible custom element, in parallel
                const ssrProps = {};
                await Promise.all(ssrModules.map(({ specifier, tagName, props, startOffset, endOffset }) => {
                    return ssrElement({ specifier, props }, moduleBundler, viewContext).then(({ html, props }) => {
                        if (props) {
                            // Add the props id to the HTML for the custom element
                            // eg: <some-cmp> -> <some-cmp data-lwr-props-id="1234">
                            const propsId = getPropsId();
                            ssrProps[propsId] = props;
                            const [, remain] = html.split(`<${tagName}`);
                            html = [`<${tagName}`, ` ${SSR_PROPS_ATTR}="${propsId}"`, remain].join('');
                        }
                        // Overwrite the custom element with the SSRed component string
                        stringBuilder.overwrite(startOffset, endOffset, html);
                    });
                }));
                if (Object.keys(ssrProps).length) {
                    // Serialize all root component properties into a single script for the page
                    // Append the script before the custom elements; it MUST appear before the AMD shim to avoid timing issues
                    stringBuilder.prependLeft(ssrModules[0].startOffset, `<script type="application/javascript">globalThis.LWR = globalThis.LWR || {};globalThis.LWR.${SSR_PROPS_KEY} = ${JSON.stringify(ssrProps)};</script>`);
                }
            }
        },
    };
}
//# sourceMappingURL=index.js.map