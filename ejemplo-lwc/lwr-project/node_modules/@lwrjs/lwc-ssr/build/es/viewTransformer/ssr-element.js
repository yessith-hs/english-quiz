import getCode from './amd-utils.js';
import runCode from './sandbox.js';
const bundleConfigOverrides = {
    exclude: [],
    alias: {
        lwc: '@lwc/engine-server', // override the default "@lwc/engine-dom" package
    },
};
/**
 * Create a bundle for the given SSR module and run the code in a sandbox.
 * @param moduleInfo - specifier: The ID of the module, generated by "lwc-ssr/moduleProvider", which SSRs a component
 *                     props: A map of the key:value property pairs parsed from the custom element attributes (ie: all string values)
 * @param moduleBundler
 * @param runtimeEnvironment
 * @returns a promise to the SSRed code string
 */
export async function ssrElement({ specifier, props: templateProps }, moduleBundler, { runtimeEnvironment, runtimeParams }) {
    const { bundleRecord, code, specifier: bundleSpecifier, version, } = await moduleBundler.getModuleBundle({ specifier }, 
    // Ensure the bundle flag is always off,
    // otherwise TOO much gets bundled in the module registry
    // in ESM, resulting lwc clashes/duplication
    { ...runtimeEnvironment, bundle: false }, undefined, bundleConfigOverrides);
    // Gather context to send into the SSR sandbox
    const context = {
        props: templateProps,
        params: runtimeParams.params || {},
        query: runtimeParams.query || {},
        locale: runtimeParams.locale || runtimeEnvironment.defaultLocale,
    };
    // Get the SSR string and properties bag
    const { error, result, props } = runtimeEnvironment.format === 'amd'
        ? await runCode([
            ...(await getCode(runtimeEnvironment, version.replace(/\./g, '_'), bundleRecord.includedModules.find((m) => m.startsWith('lwc/v')), bundleSpecifier)),
            code,
        ], context)
        : await runCode([code], context);
    if (error) {
        throw new Error(error);
    }
    else {
        return { html: result, props };
    }
}
//# sourceMappingURL=ssr-element.js.map