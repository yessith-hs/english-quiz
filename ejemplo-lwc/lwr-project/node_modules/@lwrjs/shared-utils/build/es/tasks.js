class Task {
    constructor(taskFunction, caller, resolve, reject) {
        this.taskFunction = taskFunction;
        this.caller = caller;
        this.resolve = resolve;
        this.reject = reject;
    }
}
/**
 * A pool is created of a given size
 * If more tasks than that are asked to execute they are put in a queue until there is space in the pool
 */
export class TaskPool {
    constructor(size) {
        this.queue = [];
        this.running = 0;
        this.size = size || 15;
    }
    /**
     * Add a function that takes no arguments
     * It will run as soon as there is room in the pool
     *
     * @param taskFunction - Function to run when there is space in the pool
     * @param caller - The closer to use when calling the constructor
     **/
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async execute(taskFunction, caller) {
        return new Promise((resolve, reject) => {
            const task = new Task(taskFunction, caller || this, resolve, reject);
            if (this.running >= this.size) {
                this.queue.push(task);
                // TODO add to profiling
                // console.log('[DEBUG] TaskPool Queue Size: ' + this.queue.length);
            }
            else {
                this.start(task);
            }
        });
    }
    async start(task) {
        // Add run next
        this.running++;
        try {
            const ret = await task.taskFunction.bind(task.caller)();
            task.resolve(ret);
        }
        catch (err) {
            task.reject(err);
        }
        finally {
            this.running--;
            this.runNext();
        }
    }
    runNext() {
        const next = this.queue.shift();
        if (next) {
            // TODO add to profiling
            // console.log('[DEBUG] TaskPool Queue Size: ' + this.queue.length);
            this.start(next);
        }
    }
}
/**
 * Contains a map of tasks that are in progress
 * Calls to execute with the id of a task in progress returns the running tasks
 * If no task of that id is running a new task is created
 */
export class InflightTasks {
    constructor() {
        this.tasks = new Map();
    }
    /**
     * Return a promise per id.  If one is already in flight return the promise.
     * If not use the constructor to create a new
     *
     * @param id - Unique id for promise in question
     * @param taskCtor - Function that create a promise for the id if needed
     * @param caller - The closer to use when calling the constructor
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    execute(id, taskCtor, caller) {
        if (this.tasks.has(id)) {
            return this.tasks.get(id);
        }
        else {
            const job = taskCtor
                .bind(caller || this)()
                .finally(() => {
                // Once fulfilled remove form active jobs
                this.tasks.delete(id);
            });
            this.tasks.set(id, job);
            return job;
        }
    }
}
//# sourceMappingURL=tasks.js.map