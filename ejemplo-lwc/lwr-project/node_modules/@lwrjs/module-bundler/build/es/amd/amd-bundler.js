import { getModuleGraphs, GraphDepth } from '@lwrjs/shared-utils';
export async function amdBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams = {}, { bundleConfig, amdLoader }, bundleConfigOverride) {
    const { exclude, external } = bundleConfigOverride ?? bundleConfig;
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const visited = new Map();
    const moduleGraphs = await getModuleGraphs(moduleId.specifier, {
        includeLinkedDefinitions: true,
        depth: {
            static: GraphDepth.ALL,
            dynamic: 0,
            includeId: (moduleRef) => {
                if ((exclude && exclude.includes(moduleRef.specifier)) ||
                    // loader should be auto bundled with shim already
                    moduleRef.specifier === amdLoader) {
                    requiredImports.set(`${moduleId.specifier}_${moduleId.version}`, moduleRef);
                    return false;
                }
                return true;
            },
        },
    }, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams, visited);
    const rootModule = moduleGraphs.graphs[0];
    // type cast to LinkedModuleDefinition because only the moduleRegistry is used
    const rootModuleDef = moduleGraphs.linkedDefinitions[rootModule.specifier];
    const { id, name, namespace, version, specifier } = rootModuleDef;
    // Collect dynamic imports
    // Add dynamic imports from the root module
    rootModuleDef?.linkedModuleRecord.dynamicImports?.forEach((e) => {
        dynamicImports.set(`${e.specifier}_${e.version}`, e);
    });
    // Add any dynamic imports from each of the linked static imports in the moduleGraph
    moduleGraphs.graphs[0].static.forEach((m) => {
        // type cast to LinkedModuleDefinition because only the moduleRegistry is used
        const d = moduleGraphs.linkedDefinitions[m];
        // D would be null if excluded from the bundle
        d?.linkedModuleRecord.dynamicImports?.forEach((e) => {
            dynamicImports.set(`${e.specifier}_${e.version}`, e);
        });
    });
    // loop in reverse for correct order
    const code = [];
    const moduleSpecifiers = [];
    for (let i = rootModule.static.length - 1; i >= 0; i--) {
        const s = rootModule.static[i];
        // only included modules will be present in the linkedDefinitions
        if (moduleGraphs.linkedDefinitions[s]) {
            moduleSpecifiers.push(s);
            // type cast to LinkedModuleDefinition becuase only the moduleRegistry is used
            code.push(moduleGraphs.linkedDefinitions[s].linkedSource.trimEnd());
        }
    }
    code.push(rootModuleDef.linkedSource.trimEnd());
    return {
        id,
        name,
        namespace,
        version,
        specifier,
        code: code.join(''),
        config: { external, exclude },
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules: moduleSpecifiers,
        },
    };
}
//# sourceMappingURL=amd-bundler.js.map