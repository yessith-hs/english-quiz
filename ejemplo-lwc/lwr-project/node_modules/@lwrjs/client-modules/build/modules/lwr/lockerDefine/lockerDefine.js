/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
var _URLCtor$prototype$LWS;

const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  has: ReflectHas$LWS,
  get: ReflectGet$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  ownKeys: ReflectOwnKeys$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;

function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}

function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}

const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS :
/* istanbul ignore next: currently unreachable via tests */
function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
};

function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, object$LWS, [key$LWS]);
}

function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
}

const SymbolCtor$LWS = Symbol;
const {
  prototype: SymbolProto$LWS
} = SymbolCtor$LWS;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = SymbolCtor$LWS;
const {
  toString: SymbolProtoToString$LWS,
  valueOf: SymbolProtoValueOf$LWS
} = SymbolProto$LWS;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  find: ArrayProtoFind$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  some: ArrayProtoSome$LWS,
  splice: ArrayProtoSplice$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  filter: ArrayProtoFilter$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  push: ArrayProtoPush$LWS,
  shift: ArrayProtoShift$LWS,
  slice: ArrayProtoSlice$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;

function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);

  for (let i$LWS = 0, {
    length: length$LWS
  } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];

    if (ArrayIsArray$LWS(value$LWS)) {
      ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, value$LWS);
    } else {
      result$LWS[result$LWS.length] = value$LWS;
    }
  }

  return result$LWS;
}

function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS; // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.

  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}

const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength'); // https://caniuse.com/bigint

const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf :
/* istanbul ignore next: currently unreachable via tests */
undefined;
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;
const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS'; // This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore next

const LOCKER_UNMINIFIED_FLAG$LWS = `${() =>
/* $LWS */
1}`.includes(LOCKER_IDENTIFIER_MARKER$LWS);
const CHAR_ELLIPSIS$LWS = '\u2026';
const CHAR_QUOTE_DOUBLE$LWS = '"';
const CHAR_QUOTE_SINGLE$LWS = "'";
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
const DateCtor$LWS = Date;
const {
  now: DateNow$LWS
} = DateCtor$LWS;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;
const {
  bind: FunctionProtoBind$LWS,
  toString: FunctionProtoToString$LWS
} = Function.prototype;

function noop$LWS() {// No operation performed.
}

const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');

function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
  return map$LWS;
}

const NumberCtor$LWS = Number;
const {
  prototype: NumberProto$LWS
} = NumberCtor$LWS;
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS
} = NumberCtor$LWS;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberProto$LWS;
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  endsWith: StringProtoEndsWith$LWS,
  includes: StringProtoIncludes$LWS,
  indexOf: StringProtoIndexOf$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const QUOTE_CHAR_REG_EXP_MAP$LWS = {
  __proto__: null,
  [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
  [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
};
const URLCtor$LWS = typeof URL === 'function' ? URL :
/* istanbul ignore next: unreachable in test env */
undefined; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

const URLProtoToString$LWS = URLCtor$LWS == null ? void 0 : (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString; // To extract the function body start the match from the beginning of the
// source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
// matches everything including newlines where as `.` matches everything except
// newlines. Next, continue matching past the opening left curly bracket of the
// function and beyond optional whitespace and newline. Finally, capture the
// function body up to, but not including, optional newline and whitespace by
// the closing right curly bracket at the end of the source code. The alternate
// pattern matches arrow functions without brackets.

const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;

function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;

  if (length$LWS) {
    const upper$LWS = ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS[0], []);
    return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [1]);
  }

  return '';
}

function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
  return quoteChar$LWS + ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [QUOTE_CHAR_REG_EXP_MAP$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
}

function extractFunctionBodySource$LWS(func$LWS) {
  var _ref$LWS, _match$$LWS;

  const source$LWS = ReflectApply$LWS(FunctionProtoToString$LWS, func$LWS, []);
  const match$LWS = ReflectApply$LWS(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]); // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

  return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
}

function isConvertibleToString$LWS(value$LWS) {
  if (typeof value$LWS !== 'symbol') {
    try {
      // Attempt to coerce `value` to a string with the ToString operation.
      // Section 7.1.17 ToString ( argument )
      // https://tc39.es/ecma262/#sec-tostring
      return `${value$LWS}` !== undefined; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }

  return false;
} // Use `toString()` to coerce values using the default string concatenation
// operation.


function toString$LWS(value$LWS) {
  return typeof value$LWS === 'string' ? value$LWS : // Attempt to coerce `value` to a string with the ToString operation.
  // Section 7.1.17 ToString ( argument )
  // https://tc39.es/ecma262/#sec-tostring
  `${value$LWS}`;
} // Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.


function toSafeTemplateStringValue$LWS(value$LWS) {
  if (typeof value$LWS === 'string') {
    return value$LWS;
  }

  try {
    if (typeof value$LWS === 'function') {
      return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
    }

    if (typeof value$LWS === 'object' && value$LWS !== null) {
      if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
        return ReflectApply$LWS(URLProtoToString$LWS, value$LWS, []);
      }

      const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
      return result$LWS === TO_STRING_BRAND_SYMBOL$LWS ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
    }

    if (typeof value$LWS === 'symbol') {
      return ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []);
    } // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value


    return StringCtor$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}

  return '[object Unknown]';
}

const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  exec: RegExpProtoExec$LWS,
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;

function escapeRegExp$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
}

const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  clear: SetProtoClear$LWS,
  delete: SetProtoDelete$LWS,
  entries: SetProtoEntries$LWS,
  forEach: SetProtoForEach$LWS,
  has: SetProtoHas$LWS,
  keys: SetProtoKeys$LWS,
  [SymbolIterator$LWS]: SetProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: SetProtoSymbolToStringTag$LWS
} = SetProto$LWS;
const {
  add: SetProtoAdd$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');

function toSafeSet$LWS(set$LWS) {
  ReflectSetPrototypeOf$LWS(set$LWS, null);
  set$LWS.add = SetProtoAdd$LWS;
  set$LWS.clear = SetProtoClear$LWS;
  set$LWS.delete = SetProtoDelete$LWS;
  set$LWS.entries = SetProtoEntries$LWS;
  set$LWS.forEach = SetProtoForEach$LWS;
  set$LWS.has = SetProtoHas$LWS;
  set$LWS.keys = SetProtoKeys$LWS;
  ReflectDefineProperty$LWS(set$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: SetProtoSizeGetter$LWS,
    set: undefined
  });
  set$LWS.values = SetProtoValues$LWS;
  set$LWS[SymbolIterator$LWS] = SetProtoSymbolIterator$LWS;
  set$LWS[SymbolToStringTag$LWS] = SetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(set$LWS, SetProto$LWS);
  return set$LWS;
}

const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  has: WeakMapProtoHas$LWS
} = WeakMapProto$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;

function toSafeWeakMap$LWS$1(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}

const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;

function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}

const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol; // Regular expressions from Acorn:
//     acorn/src/parseutil.js
//     acorn/src/whitespace.js

const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;

function getBrandByTrialAndError$LWS(value$LWS) {
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  //
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value$LWS) {
      ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused3$LWS) {} // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.


  try {
    if ('toLocaleDateString' in value$LWS) {
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_DATE$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused4$LWS) {} // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).


  try {
    if ('get' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused5$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.


  try {
    if (ObjectHasOwn$LWS(value$LWS, 'lastIndex')) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_REG_EXP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused6$LWS) {} // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).


  try {
    if ('add' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused7$LWS) {} // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).


  try {
    if ('get' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_MAP$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused8$LWS) {} // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).


  try {
    if ('add' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_SET$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused9$LWS) {} // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.


  try {
    if ('toPrecision' in value$LWS) {
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_NUMBER$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused10$LWS) {} // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.


  try {
    if (ObjectHasOwn$LWS(value$LWS, 'length')) {
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_STRING$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused11$LWS) {} // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.


  try {
    if ('description' in value$LWS) {
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_SYMBOL$LWS;
    } // eslint-disable-next-line no-empty

  } catch (_unused12$LWS) {} // istanbul ignore else: All platforms that LWS runs tests in support BigInt


  if (SUPPORTS_BIG_INT$LWS) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BIG_INT$LWS; // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
  }

  try {
    // Section 20.3.3 Properties of the Boolean Prototype Object
    // https://tc39.es/ecma262/#thisbooleanvalue
    // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
    //     a. Let b be value.[[BooleanData]].
    //     b. Assert: Type(b) is Boolean.
    ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
    return TO_STRING_BRAND_BOOLEAN$LWS; // eslint-disable-next-line no-empty
  } catch (_unused14$LWS) {} // Cannot detect brands for Arguments and Error objects.


  return TO_STRING_BRAND_OBJECT$LWS;
}

function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }

  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  } // eslint-disable-next-line default-case


  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;

    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;

    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;

    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;

    case 'string':
      return TO_STRING_BRAND_STRING$LWS;

    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }

  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }

  return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
}

const getTimestamp$LWS = typeof performance === 'undefined' ?
/* istanbul ignore next: unreachable in test env */
DateNow$LWS : ReflectApply$LWS(FunctionProtoBind$LWS, performance.now, [performance]); // Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js

function indexOfPragma$LWS(source$LWS, pragma$LWS) {
  let pos$LWS = 0; // eslint-disable-next-line no-constant-condition

  while (true) {
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    const stringLiteralMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS(StringProtoSlice$LWS, source$LWS, [pos$LWS])]);

    if (stringLiteralMatch$LWS === null) {
      return -1;
    }

    if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
      const spaceAfterMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
      const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
      const nextChar$LWS = source$LWS[end$LWS];

      if (nextChar$LWS === ';' || nextChar$LWS === '}') {
        return pos$LWS;
      }

      const indexAfterNext$LWS = end$LWS + 1;

      if (ReflectApply$LWS(RegExpProtoTest$LWS, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS(RegExpProtoTest$LWS, expressionCharRegExp$LWS, [nextChar$LWS]))) {
        return pos$LWS;
      }
    }

    pos$LWS += stringLiteralMatch$LWS[0].length; // Skip semicolon, if any.

    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;

    if (source$LWS[pos$LWS] === ';') {
      pos$LWS += 1;
    }
  }
}

function toSafeDescriptor$LWS(desc$LWS) {
  ReflectSetPrototypeOf$LWS(desc$LWS, null);
  return desc$LWS;
}

function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}

function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };

  for (let i$LWS = 0, {
    length: length$LWS
  } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }

  return clone$LWS;
}

const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;

function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}

class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }

}

const {
  parse: JSONParse$LWS,
  stringify: JSONStringify$LWS
} = JSON;
const LOCKER_LIVE_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerLiveValue'); // This is used by packages/locker-core-engine/src/LockerFilter.js

function isLiveObject$LWS(value$LWS) {
  // Based on the isTargetLive() function of
  // salesforce/near-membrane/packages/near-membrane-base/src/membrane.ts.
  if (value$LWS === null || value$LWS === undefined || value$LWS === ObjectProto$LWS || value$LWS === RegExpProto$LWS) {
    return false;
  }

  if (typeof value$LWS === 'function') {
    try {
      return ObjectHasOwn$LWS(value$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS); // eslint-disable-next-line no-empty
    } catch (_unused15$LWS) {}

    return false;
  }

  if (typeof value$LWS === 'object') {
    let constructor$LWS;

    try {
      ({
        constructor: constructor$LWS
      } = value$LWS);

      if (constructor$LWS === ObjectCtor$LWS) {
        // If the constructor, own or inherited, points to `Object`
        // then `value` is not likely a prototype object.
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused16$LWS) {}

    try {
      if (ObjectHasOwn$LWS(value$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused17$LWS) {}

    try {
      if (ReflectGetPrototypeOf$LWS(value$LWS) === null && ( // Ensure `value` is not an `Object.prototype` from an iframe.
      typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== value$LWS)) {
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused18$LWS) {}

    try {
      if (ArrayIsArray$LWS(value$LWS)) {
        return true;
      }
    } catch (_unused19$LWS) {
      // The value is a revoked proxy.
      return false;
    }

    if (ArrayBufferIsView$LWS(value$LWS)) {
      return true;
    } // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.


    try {
      if (ObjectHasOwn$LWS(value$LWS, 'lastIndex')) {
        ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused20$LWS) {} // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).


    try {
      if ('byteLength' in value$LWS) {
        ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
        return true;
      } // eslint-disable-next-line no-empty

    } catch (_unused21$LWS) {}
  }

  return false;
}

function markLiveObject$LWS(target$LWS) {
  ReflectDefineProperty$LWS(target$LWS, LOCKER_LIVE_VALUE_SYMBOL$LWS, {
    __proto__: null,
    value: undefined
  });
  return target$LWS;
}

function toLiveValue$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    return isLiveObject$LWS(value$LWS) ? value$LWS : markLiveObject$LWS(value$LWS);
  }

  return value$LWS;
}

const {
  min: MathMin$LWS
} = Math;
const PREFIX_HEAD$LWS = 'LSKey-';
const PREFIX_TAIL$LWS = '$';

function getNamespacePrefix$LWS(namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
}

function isNamespacePrefixed$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [`${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`]);
}

function prefixNamespace$LWS(key$LWS, namespace$LWS) {
  return `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}${key$LWS}`;
}

function unprefixNamespace$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const prefix$LWS = `${PREFIX_HEAD$LWS}${namespace$LWS}${PREFIX_TAIL$LWS}`;
    return ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [prefix$LWS]) ? ReflectApply$LWS(StringProtoSlice$LWS, key$LWS, [prefix$LWS.length]) : key$LWS;
  }

  return '';
}

const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');

function getNearMembraneSerializedValue$LWS(object$LWS) {
  return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
}

function isNearMembrane$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }

  return false;
}

const PromiseCtor$LWS = Promise;
const {
  catch: PromiseProtoCatch$LWS,
  then: PromiseProtoThen$LWS
} = PromiseCtor$LWS.prototype;
const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
const ProxyCtor$LWS = Proxy;
const {
  revocable: ProxyRevocable$LWS
} = ProxyCtor$LWS;

function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}
/*! version: 0.16.27 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
const DocumentCtor$LWS = Document;
const {
  prototype: DocumentProto$LWS
} = DocumentCtor$LWS;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'implementation');
const {
  prototype: ElementProto$LWS
} = Element;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(ElementProto$LWS, 'namespaceURI');
const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'firstChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'ownerDocument');
/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */

class Validator$LWS {
  constructor(record$LWS) {
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };

    this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoBodyGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, this._document, []);

    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement;

    this.isMediaSourceObject = object$LWS => // MediaSource may not be defined in some browsers
    this._constructors.MediaSource && object$LWS instanceof this._constructors.MediaSource;

    const {
      document: document$LWS,
      globalObject: {
        HTMLLinkElement: HTMLLinkElement$LWS,
        HTMLScriptElement: HTMLScriptElement$LWS,
        MediaSource: MediaSource$LWS
      }
    } = record$LWS;
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      MediaSource: MediaSource$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template']),
      right: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template'])
    };
  }

}

const topValidator$LWS = new Validator$LWS( // Mock sandbox record.
{
  document,
  globalObject: window
});
const documentToValidatorMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS([[document, topValidator$LWS]]));
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebPackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExp(`(?:^|\\W)${escapeRegExp$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
const webpackRequireNameRegExp$LWS = new RegExp(`\\b${escapeRegExp$LWS(WEBPACK_REQUIRE_NAME$LWS)}\\b`);

function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExp(`\\b(?:${objectPattern$LWS})\\.${key$LWS}(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}

function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;

  if (ReflectApply$LWS(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;

    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);

      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }

    return true;
  }

  return false;
}

function getValidator$LWS(record$LWS) {
  // Fast path validator lookup for top level window.
  if (record$LWS === undefined || record$LWS.globalObject === window) {
    return topValidator$LWS;
  }

  const {
    document: document$LWS
  } = record$LWS; // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.

  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);

  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(record$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }

  return validator$LWS;
}

function transformUncompiledSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (ReflectApply$LWS(RegExpProtoTest$LWS, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }

  const destructuredBlueHelpers$LWS = []; // Input `sourceText` is uncompiled, so `window.location` returns `null` inside
  // the detached iframe sandbox. Our compiler solves this problem by transforming
  // the red `location` reference into a blue `location` reference. The solution
  // below emulates what our compiler does, but using a simple string replacement.

  let locationTransformed$LWS = false;
  sourceText$LWS = ReflectApply$LWS(StringProtoReplace$LWS, sourceText$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of global
  // regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  ReflectApply$LWS(RegExpProtoTest$LWS, webpackRequireNameRegExp$LWS, [sourceText$LWS]) ? locationReferencesWithWebPackRegExp$LWS : locationReferencesRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => {
    locationTransformed$LWS = true;
    return assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS;
  }]);

  if (locationTransformed$LWS) {
    destructuredBlueHelpers$LWS[destructuredBlueHelpers$LWS.length] = UNCOMPILED_LOCATION_NAME$LWS;
  }

  if (!destructuredBlueHelpers$LWS.length) {
    return sourceText$LWS;
  }

  const destructureSandboxEvalContextSnippet$LWS = `const {
        ${ReflectApply$LWS(ArrayProtoJoin$LWS, destructuredBlueHelpers$LWS, [','])}} = ${SANDBOX_EVAL_CONTEXT_NAME$LWS};`;
  const pragmaIndex$LWS = indexOfPragma$LWS(sourceText$LWS, 'use strict');

  if (pragmaIndex$LWS === -1) {
    return destructureSandboxEvalContextSnippet$LWS + sourceText$LWS;
  } // The "use strict" pragma, including quotes, is 12 characters long.


  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12; // istanbul ignore else

  if (afterPragmaIndex$LWS < sourceText$LWS.length && sourceText$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }

  return ReflectApply$LWS(StringProtoSlice$LWS, sourceText$LWS, [0, afterPragmaIndex$LWS]) + destructureSandboxEvalContextSnippet$LWS + ReflectApply$LWS(StringProtoSlice$LWS, sourceText$LWS, [afterPragmaIndex$LWS]);
}

const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'type');
const SEEN_OBJECTS_MAP$LWS = toSafeMap$LWS(new MapCtor$LWS());

function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS(getNearMembraneSerializedValue$LWS(object$LWS));
}

function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS(); // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...

  const entriesIterable$LWS = ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []); // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();

    if (done$LWS) {
      break;
    }

    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS; // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS]; // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).

    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(MapProtoSet$LWS, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneSerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}

function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS(); // Step 26.2.2: For each entry of value.[[SetData]]...

  const valuesIterable$LWS = ReflectApply$LWS(SetProtoValues$LWS, set$LWS, []); // Step 26.2.3: For each entry of copiedList:

  let {
    length: queueOffset$LWS
  } = queue$LWS; // eslint-disable-next-line no-constant-condition

  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();

    if (done$LWS) {
      break;
    } // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).


    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(SetProtoAdd$LWS, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }

  return clone$LWS;
}

function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
} // This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.


function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]]; // eslint-disable-next-line no-labels

  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ReflectApply$LWS(ArrayProtoShift$LWS, queue$LWS, []); // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String

    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.


    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    } // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.


    let cloneValue$LWS = SEEN_OBJECTS_MAP$LWS.get(originalValue$LWS);

    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS); // eslint-disable-next-line no-continue, no-extra-label, no-labels

      continue queueLoop;
    } // Perform a brand check on originalValue.


    const brand$LWS = getBrand$LWS(originalValue$LWS); // eslint-disable-next-line default-case

    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS(originalValue$LWS);

          if (proto$LWS === ObjectProto$LWS || proto$LWS === null) {
            cloneValue$LWS = {}; // Step 19.4: Set deep to true.

            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }

          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...

      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = ArrayCtor$LWS(originalValue$LWS.length); // Step 18.4: Set deep to true.

        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.

      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.

      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }

    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!isNearMembrane$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

        continue queueLoop;
      } // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case


      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...

        case TO_STRING_BRAND_BOOLEAN$LWS: // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_NUMBER$LWS: // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_BIG_INT$LWS: // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough

        case TO_STRING_BRAND_STRING$LWS:
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          break;
      }
    } // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'


    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS); // eslint-disable-next-line no-extra-label, no-labels

      break queueLoop;
    }

    SEEN_OBJECTS_MAP$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }

  return result$LWS;
}

function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;

  try {
    result$LWS = partialStructuredCloneInternal$LWS(value$LWS); // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}

  SEEN_OBJECTS_MAP$LWS.clear();
  return result$LWS;
}

const {
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenList.prototype, 'value');
const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS(Event.prototype, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS
} = EventTarget.prototype;
const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElement.prototype, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElement.prototype, 'protocol');
const HTMLElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'dataset');
const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement.prototype, 'src');
ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement.prototype, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS(Request.prototype, 'url');
const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const SVGElementProtoDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement.prototype, 'dataset');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URL;
const {
  setTimeout: WindowSetTimeout$LWS
} = window; // These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope

const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  setInterval: WindowSetInterval$LWS
} = window;

const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = window; // istanbul ignore else

  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  } // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow


  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = PromiseResolve$LWS();
    promise$LWS = ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
    ReflectApply$LWS(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();

const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'document');
const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'frameElement');
const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'length');
const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS(window, 'location');

function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      ReflectApply$LWS(WindowLocationGetter$LWS, value$LWS, []);
      return true; // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }

  return false;
} // This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.js containing the directive and subsequently being
// ignored.
// istanbul ignore next


const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
/*! version: 0.16.27 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar']; // Allow only alphanumeric, '-', '+', and '.' characters.

const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;

function isMIMETypeAllowed$LWS(mimeType$LWS) {
  // avoid MIME types which try to escape using special characters
  // Reason: W-4896359
  if (ReflectApply$LWS(RegExpProtoTest$LWS, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
    for (let i$LWS = 0, {
      length: length$LWS
    } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (ReflectApply$LWS(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
        return true;
      }
    }
  }

  return false;
}

const DISALLOWED_ENDPOINTS_LIST$LWS = ['/aura', '/webruntime'];
const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
const normalizerAnchor$LWS$1 = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['a']);
const TRUSTED_DOMAINS_REG_EXP$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/;
const URL_SCHEMES_LIST$LWS = toSafeArray$LWS(['http:', 'https:']); // @TODO W-7302311 Make paths and domains configurable

function isValidURL$LWS(parsedURL$LWS) {
  const loweredPathname$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);

  for (let i$LWS = 0, {
    length: length$LWS
  } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS; i$LWS += 1) {
    if (ReflectApply$LWS(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$LWS(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
      return false;
    }
  }

  return true;
}

function isValidURLScheme$LWS(url$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS$1, [url$LWS]);
  return URL_SCHEMES_LIST$LWS.includes(ReflectApply$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS$1, []));
}

function parseURL$LWS(url$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS$1, [sanitizeURLString$LWS(url$LWS)]);
  return {
    normalizedURL: ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS$1, []),
    hostname: ReflectApply$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS$1, []),
    pathname: WindowDecodeURIComponent$LWS(ReflectApply$LWS(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS$1, []))
  };
}

function sanitizeURLForElement$LWS(url$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS$1, [url$LWS]);
  return sanitizeURLString$LWS(ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS$1, []));
}

function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : ReflectApply$LWS(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, '']);
}
/*! version: 0.16.27 */

/*! @license DOMPurify 2.3.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.6/LICENSE */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);

var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

var text = freeze(['#text']);

var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.3.6';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      HTMLFormElement = window.HTMLFormElement,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      createDocumentFragment = _document.createDocumentFragment,
      getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;

  /* Parsing of strict XHTML documents */
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  var transformCaseFunc = void 0;

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  var isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }

    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }

    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
      return x;
    } : stringToLowerCase;

    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }

      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erronously deleted from
      // HTML namespace.
      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }

    var body = doc.body || doc.documentElement;

    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }

    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = transformCaseFunc(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Mitigate a problem with templates inside select */
    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }

      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
      content = stringReplace(content, ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _basicCustomElementCheck
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   * @param {string} tagName name of the tag of the node to sanitize
   */
  var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    return tagName.indexOf('-') > 0;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = stringTrim(attr.value);
      lcName = transformCaseFunc(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
        value = stringReplace(value, ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (ALLOWED_ATTR.shadowroot) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const ariaAttributes$LWS = ['aria-activedescendant', 'aria-atomic', 'aria-autocomplete', 'aria-busy', 'aria-checked', 'aria-controls', 'aria-describedby', 'aria-disabled', 'aria-readonly', 'aria-dropeffect', 'aria-expanded', 'aria-flowto', 'aria-grabbed', 'aria-haspopup', 'aria-hidden', 'aria-disabled', 'aria-invalid', 'aria-label', 'aria-labelledby', 'aria-level', 'aria-live', 'aria-multiline', 'aria-multiselectable', 'aria-orientation', 'aria-owns', 'aria-posinset', 'aria-pressed', 'aria-readonly', 'aria-relevant', 'aria-required', 'aria-selected', 'aria-setsize', 'aria-sort', 'aria-valuemax', 'aria-valuemin', 'aria-valuenow', 'aria-valuetext', 'role', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS);
const CUSTOM_ELEMENT_HANDLING$LWS = {
  attributeNameCheck: /.+/,
  allowCustomizedBuiltInElements: false,
  // The regexp is based on the WHATWG spec:
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  // However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.
  tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
}; // A generic config in which the sanitizer attempts in place sanitization and
// returns node.

const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  // Add '#document-fragment' to ALLOWED_TAGS to avoid a forbidden root node
  // exception.
  // https://github.com/cure53/DOMPurify/issues/664
  ALLOWED_TAGS: ArrayConcat$LWS(allTags$LWS, '#document-fragment'),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  IN_PLACE: true
}; // A config to use only svg tags in which the sanitizer returns a document
// fragment.

const NODE_SVG$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  ALLOWED_TAGS: shallowCloneArray$LWS(svgTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false
}; // A config to use only tags allowed for blob and file.

const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(ariaAttributes$LWS),
  ALLOWED_TAGS: ReflectApply$LWS(ArrayProtoFilter$LWS, allTags$LWS, [tag$LWS => tag$LWS !== 'iframe']),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  SANITIZE_DOM: false
};
const instances$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS());

function sanitizer$LWS(config$LWS, hooksRegistry$LWS) {
  let dompurify$LWS = instances$LWS.get(config$LWS);

  if (dompurify$LWS === undefined) {
    dompurify$LWS = purify();
    dompurify$LWS.setConfig(config$LWS);

    for (const hookName$LWS in hooksRegistry$LWS) {
      // istanbul ignore else
      if (hooksRegistry$LWS) {
        dompurify$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
      }
    }

    instances$LWS.set(config$LWS, dompurify$LWS);
  }

  return dompurify$LWS;
}

const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS(['href', 'xlink:href']);
const SANITIZER_HOOKS_REGISTRY$LWS = {
  __proto__: null,
  uponSanitizeAttribute: sanitizeHrefAttributeHook$LWS
};
const htmlTemplate$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['template']);
const normalizerAnchor$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['a']); // Queue for managing pending xhr requests.

const queue$LWS = toSafeSet$LWS(new SetCtor$LWS()); // A regexp to find all non lowercase alphanumeric.

const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;

function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (queue$LWS.has(normalizedHref$LWS.normalizedUrl)) {
    // Wait for request to finish, then update content.
    const interval$LWS = WindowSetInterval$LWS(() => {
      // istanbul ignore else
      if (!queue$LWS.has(normalizedHref$LWS.normalizedUrl)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(interval$LWS);
      }
    }, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}

function createUrlContainer$LWS(url$LWS) {
  const container$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['div']);
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, container$LWS, ['style', 'display:none']);
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, container$LWS, ['id', url$LWS]);
  const body$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, document, []);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, body$LWS, [container$LWS]);
  return container$LWS;
}

function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedUrl); // Put the URL we're fetching in a queue.

  queue$LWS.add(normalizedHref$LWS.normalizedUrl); // Initiate an XHR to fetch the resource.

  const xhr$LWS = new XhrCtor$LWS();
  ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
    const status$LWS = ReflectApply$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []); // istanbul ignore next: the following is well tested via integration-karma

    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const responseText$LWS = ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS); // Look for the container again in case other requests have finished
      // earlier for the same URL.

      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = ReflectApply$LWS(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);

        if (el$LWS) {
          ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, ['id', normalizedHref$LWS.normalizedFragment]);
        }
      }

      ReflectApply$LWS(NodeProtoAppendChild$LWS, container$LWS, [fragment$LWS]);
      queue$LWS.delete(normalizedHref$LWS.normalizedUrl);
    }
  }]);
  ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', normalizedHref$LWS.requestedUrl]);
  ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
}

function parseHref$LWS(url$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  const href$LWS = ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
  const protocol$LWS = ReflectApply$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []);
  const {
    0: requestedUrl$LWS,
    1: requestedFragment$LWS
  } = ReflectApply$LWS(StringProtoSplit$LWS, href$LWS, ['#']); // RegExp.prototype[Symbol.replace] resets the lastIndex of global regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

  const loweredUrl$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, requestedUrl$LWS, []);
  const normalizedUrl$LWS = ReflectApply$LWS(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, '']);
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedUrl$LWS}_${ReflectApply$LWS(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ''])}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedUrl: normalizedUrl$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedUrl: requestedUrl$LWS
  };
}

function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]); // istanbul ignore else

  if (el$LWS === null) {
    try {
      el$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
      ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, ['id', normalizedFragment$LWS]);
    } catch (_unused$LWS) {// Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers may
      // have the same ids for svg elements.
    }
  }
}

function blobSanitizer$LWS() {
  return sanitizer$LWS(STRING_BLOB_HTML$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
}

function svgSanitizer$LWS() {
  return sanitizer$LWS(NODE_SVG$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
}

function sanitize$LWS(dirty$LWS) {
  ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [dirty$LWS]);
  const content$LWS = ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
  const sanitizer$1$LWS = sanitizer$LWS(NODE_ALL_IN_PLACE$LWS, SANITIZER_HOOKS_REGISTRY$LWS);
  sanitizer$1$LWS.sanitize(content$LWS);
  return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
}

function sanitizeDocument$LWS(doc$LWS) {
  const docEl$LWS = ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, doc$LWS, []);
  const content$LWS = ReflectApply$LWS(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
  const docImpl$LWS = ReflectApply$LWS(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
  const newDoc$LWS = ReflectApply$LWS(DOMImplementationProtoCreateDocument$LWS, docImpl$LWS, [NAMESPACE_XHTML$LWS, 'html']);
  const newDocEl$LWS = ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, newDoc$LWS, []);
  ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, newDocEl$LWS, [sanitize$LWS(content$LWS)]);
  return newDoc$LWS;
} // Sanitize a URL representing a SVG href attribute value.


function sanitizeHrefAttributeHook$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;

  if (attrValue$LWS && ReflectApply$LWS(StringProtoToUpperCase$LWS, ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === 'USE' && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }

  return data$LWS;
}

function sanitizeSvgHref$LWS(url$LWS) {
  const urlAsString$LWS = toString$LWS(url$LWS);

  if (ReflectApply$LWS(StringProtoStartsWith$LWS, urlAsString$LWS, ['#'])) {
    return url$LWS;
  }

  const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS); // Sanitize only for supported URL_SCHEMES_LIST.

  if (URL_SCHEMES_LIST$LWS.includes(normalizedHref$LWS.protocol)) {
    const container$LWS = ReflectApply$LWS(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedUrl]); // Have we sanitized this URL already?

    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    } // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.


    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedUrl}`;
  }

  return url$LWS;
}

function createSvgContainer$LWS(ownerDoc$LWS) {
  return ReflectApply$LWS(DocumentProtoCreateElementNS$LWS, ownerDoc$LWS, [NAMESPACE_SVG$LWS, 'svg']);
}

function sanitizeSvgInnerHtml$LWS(stringOrSvg$LWS, dirty$LWS = '') {
  const ownerDoc$LWS = typeof stringOrSvg$LWS === 'string' ? document : ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, stringOrSvg$LWS, []);
  let container$LWS;

  if (typeof stringOrSvg$LWS === 'string') {
    dirty$LWS = stringOrSvg$LWS;
    container$LWS = createSvgContainer$LWS(ownerDoc$LWS);
  } else {
    const closestSvg$LWS = ReflectApply$LWS(ElementProtoClosest$LWS, stringOrSvg$LWS, ['svg']);
    container$LWS = closestSvg$LWS ? ReflectApply$LWS(NodeProtoCloneNode$LWS, closestSvg$LWS, [false]) : createSvgContainer$LWS(ownerDoc$LWS);
  }

  const comment$LWS = ReflectApply$LWS(DocumentProtoCreateComment$LWS, ownerDoc$LWS, ['']);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, container$LWS, [comment$LWS]);
  const outerHTML$LWS = ReflectApply$LWS(ElementProtoOuterHTMLGetter$LWS, container$LWS, []);
  const replacedOuterHTML$LWS = ReflectApply$LWS(StringProtoReplace$LWS, outerHTML$LWS, ['<!---->', dirty$LWS]);
  const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(replacedOuterHTML$LWS);
  const firstChild$LWS = ReflectApply$LWS(NodeProtoFirstChildGetter$LWS, fragment$LWS, []);
  return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
}

function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const sanitizer$LWS = svgSanitizer$LWS();
  return sanitizer$LWS.sanitize(dirty$LWS);
}
/*! version: 0.16.27 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const CustomElementRegistryBlockedProperties$LWS = ObjectFreeze$LWS(['define']);
const documentToSandboxAttributeDistortionRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS());
const recordToAttributeDistortionFactories$LWS = toSafeMap$LWS(new MapCtor$LWS());

function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS); // istanbul ignore if: currently unreachable via tests

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS]; // istanbul ignore if: currently unreachable via tests

  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$LWS(StringProtoToLowerCase$LWS, attrName$LWS, [])];

  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }

  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }

  const mapIterator$LWS = elementCtorMap$LWS.entries();

  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }

  return undefined;
}

function createAttributeDistortions$LWS(record$LWS, entries$LWS = []) {
  const factories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS); // istanbul ignore else: currently unreachable via tests

  if (factories$LWS === undefined) {
    return entries$LWS;
  }

  recordToAttributeDistortionFactories$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = documentToSandboxAttributeDistortionRegistry$LWS.get(document$LWS);

  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    documentToSandboxAttributeDistortionRegistry$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }

  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  let {
    length: entriesOffset$LWS
  } = entries$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(attributeDistortionRegistry$LWS); // istanbul ignore if: currently unreachable via tests

    if (entry$LWS) {
      entries$LWS[entriesOffset$LWS++] = entry$LWS;
    }
  }

  return entries$LWS;
} // Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').


function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}

function registerElementSetDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let factories$LWS = recordToAttributeDistortionFactories$LWS.get(record$LWS);

  if (factories$LWS === undefined) {
    factories$LWS = [];
    recordToAttributeDistortionFactories$LWS.set(record$LWS, factories$LWS);
  }

  const loweredAttributeName$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, attributeName$LWS, []);

  factories$LWS[factories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];

    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }

    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];

    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = toSafeMap$LWS(new MapCtor$LWS());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }

    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
    return null;
  };
}

function distortionAttrValueSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS
    }
  } = record$LWS;
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');

  function value$LWS(val$LWS) {
    const ownerElement$LWS = ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore else: needs default platform behavior test

    if (ownerElement$LWS) {
      const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, this, []);
      const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
      /* istanbul ignore if: coverage missing, needs investigation */

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, ownerElement$LWS, [val$LWS]);
        return;
      }
    }

    ReflectApply$LWS(originalAttrValueSetter$LWS, this, [val$LWS]);
  }

  return [originalAttrValueSetter$LWS, value$LWS];
}

function distortionAuraUtilGlobalEval$LWS(record$LWS) {
  var _globalObject$aura$LWS, _globalObject$aura$ut$LWS;

  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: globalObject$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS; // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null ? void 0 : (_globalObject$aura$ut$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$ut$LWS.globalEval; // istanbul ignore else: external is the default sandbox type for coverage runs

  if (typeof originalGlobalEval$LWS !== 'function') {
    return null;
  } // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  const globalEval$LWS = function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
    let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;

    if (typeof descriptor$LWS === 'string') {
      const split$LWS = ReflectApply$LWS(StringProtoSplit$LWS, descriptor$LWS, ['://']);
      const {
        length: length$LWS
      } = split$LWS;
      const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
      wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${ReflectApply$LWS(StringProtoReplace$LWS, name$LWS, ['.', '/'])}` : `/components/${ReflectApply$LWS(StringProtoReplace$LWS, name$LWS, [':', '/'])}.js`);
    }

    return sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
  }; // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only


  return [originalGlobalEval$LWS, globalEval$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageDelete$LWS(record$LWS) {
  var _CacheStorage$prototy$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalDelete$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const patchedDelete$LWS = function patchedDelete$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, patchedDelete$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageHas$LWS(record$LWS) {
  var _CacheStorage$prototy2$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalHas$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;

  if (typeof originalHas$LWS !== 'function') {
    return null;
  }

  const has$LWS = function has$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalHas$LWS, this, args$LWS);
  };

  return [originalHas$LWS, has$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageKeys$LWS(record$LWS) {
  var _CacheStorage$prototy3$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalKeys$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;

  if (typeof originalKeys$LWS !== 'function') {
    return null;
  }

  const keys$LWS = function keys$LWS() {
    const keysResultPromise$LWS = ReflectApply$LWS(originalKeys$LWS, this, []);
    return ReflectApply$LWS(PromiseProtoThen$LWS, keysResultPromise$LWS, [result$LWS => {
      const sandboxedCacheNames$LWS = [];

      for (let i$LWS = 0, j$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cacheName$LWS = result$LWS[i$LWS];

        if (isNamespacePrefixed$LWS(cacheName$LWS, key$LWS)) {
          sandboxedCacheNames$LWS[j$LWS++] = unprefixNamespace$LWS(cacheName$LWS, key$LWS);
        }
      }

      return sandboxedCacheNames$LWS;
    }]);
  };

  return [originalKeys$LWS, keys$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageMatch$LWS(record$LWS) {
  var _CacheStorage$prototy4$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalMatch$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;

  if (typeof originalMatch$LWS !== 'function') {
    return null;
  }

  const match$LWS = function match$LWS( // @ts-ignore: Prevent 'TS1003: Identifier expected' error.
  ...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Let the native method handle missing parameters.

    if (!length$LWS) {
      return ReflectApply$LWS(originalMatch$LWS, this, args$LWS);
    } // Next we check `length` is at least 2, which means options are present.


    const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined; // In order to enforce the sandbox partition, we must REQUIRE the
    // `options.cacheName` value. The value of `options.cacheName` must
    // also be safely convertible to a string.

    if (isObjectLike$LWS(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
      const {
        cacheName: cacheName$LWS
      } = matchOptions$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
        clonedOptions$LWS.cacheName = prefixNamespace$LWS(cacheName$LWS, key$LWS);
        args$LWS[1] = clonedOptions$LWS;
        return ReflectApply$LWS(originalMatch$LWS, this, args$LWS);
      }
    }

    return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
  };

  return [originalMatch$LWS, match$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCacheStorageOpen$LWS(record$LWS) {
  var _CacheStorage$prototy5$LWS;

  const {
    globalObject: {
      CacheStorage: CacheStorage$LWS
    },
    key: key$LWS
  } = record$LWS; // Chrome and Safari will only expose CacheStorage over HTTPS.

  const originalOpen$LWS = CacheStorage$LWS == null ? void 0 : (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;

  if (typeof originalOpen$LWS !== 'function') {
    return null;
  }

  const open$LWS = function open$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: cacheName$LWS
      } = args$LWS;

      if (isConvertibleToString$LWS(cacheName$LWS)) {
        args$LWS[0] = prefixNamespace$LWS(cacheName$LWS, key$LWS);
      }
    }

    return ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  };

  return [originalOpen$LWS, open$LWS];
}

const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */

function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
    detailsOrName$LWS = clonedDetails$LWS;
  } else {
    detailsOrName$LWS = prefixNamespace$LWS(detailsOrName$LWS, key$LWS);
  }

  return detailsOrName$LWS;
}

function unprefixCookie$LWS(cookieEntry$LWS, key$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!isNamespacePrefixed$LWS(cookieEntry$LWS, key$LWS)) {
    return null;
  } // If this cookie belongs to this sandbox, remove the prefix key.


  const prefix$LWS = getNamespacePrefix$LWS(key$LWS);
  const {
    length: prefixLength$LWS
  } = prefix$LWS;
  const pos$LWS = cookieEntry$LWS.length > prefixLength$LWS && cookieEntry$LWS[prefixLength$LWS] === '=' ? prefixLength$LWS + 1 : prefixLength$LWS;
  return ReflectApply$LWS(StringProtoSlice$LWS, cookieEntry$LWS, [pos$LWS]);
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreDelete$LWS(record$LWS) {
  var _CookieStore$prototyp$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalDelete$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;

  if (typeof originalDelete$LWS !== 'function') {
    return null;
  }

  const deleteValue$LWS = function deleteValue$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
    }

    return ReflectApply$LWS(originalDelete$LWS, this, args$LWS);
  };

  return [originalDelete$LWS, deleteValue$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGet$LWS(record$LWS) {
  var _CookieStore$prototyp2$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalGet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
    }

    const getResultPromise$LWS = ReflectApply$LWS(originalGet$LWS, this, args$LWS);
    return ReflectApply$LWS(PromiseProtoThen$LWS, getResultPromise$LWS, [cookieListItem$LWS => {
      if (cookieListItem$LWS) {
        const {
          name: name$LWS
        } = cookieListItem$LWS;

        if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
          cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
          return cookieListItem$LWS;
        }
      }

      return null;
    }]);
  };

  return [originalGet$LWS, get$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreGetAll$LWS(record$LWS) {
  var _CookieStore$prototyp3$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;

  if (typeof originalGetAll$LWS !== 'function') {
    return null;
  }

  const getAll$LWS = function getAll$LWS(...args$LWS) {
    const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
      args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
    }

    const getAllResultPromise$LWS = ReflectApply$LWS(originalGetAll$LWS, this, args$LWS);
    return ReflectApply$LWS(PromiseProtoThen$LWS, getAllResultPromise$LWS, [result$LWS => {
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;

      for (let i$LWS = 0, {
        length: length$LWS
      } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookieListItem$LWS = result$LWS[i$LWS];

        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;

          if (isNamespacePrefixed$LWS(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = unprefixNamespace$LWS(name$LWS, key$LWS);
            sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
          }
        }
      }

      return sandboxedCookies$LWS;
    }]);
  };

  return [originalGetAll$LWS, getAll$LWS];
}

const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};

function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;

  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }

  return restrictedEventTargetRegistry$LWS[eventName$LWS].has(eventTarget$LWS.constructor);
}

function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  if (isEventTargetRestricted$LWS(record$LWS, EventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }

  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(EventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreOnChange$LWS(record$LWS) {
  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    }
  } = record$LWS;
  const originalOnChangeSetter$LWS = ObjectLookupOwnSetter$LWS(CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, 'onchange');

  if (typeof originalOnChangeSetter$LWS !== 'function') {
    return null;
  }

  const onchange$LWS = function onchange$LWS() {
    throw new LockerSecurityError$LWS('Cannot set cookieStore.onchange.');
  };

  registerEventTargetRestriction$LWS(record$LWS, CookieStore$LWS, 'change');
  return [originalOnChangeSetter$LWS, onchange$LWS];
}
/* istanbul ignore next: only available in secure context */


function distortionCookieStoreSet$LWS(record$LWS) {
  var _CookieStore$prototyp4$LWS;

  const {
    globalObject: {
      CookieStore: CookieStore$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalSet$LWS = CookieStore$LWS == null ? void 0 : (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;

  if (typeof originalSet$LWS !== 'function') {
    return null;
  }

  const set$LWS = function set$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS > 1) {
      args$LWS[0] = prefixNamespace$LWS(args$LWS[0], key$LWS);
    } else if (length$LWS) {
      const {
        0: details$LWS
      } = args$LWS;

      if (isObjectLike$LWS(details$LWS)) {
        const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
        clonedDetails$LWS.name = prefixNamespace$LWS(clonedDetails$LWS.name, key$LWS);
        args$LWS[0] = clonedDetails$LWS;
      }
    }

    return ReflectApply$LWS(originalSet$LWS, this, args$LWS);
  };

  return [originalSet$LWS, set$LWS];
}

function distortionCSSStyleRuleStyleGetter$LWS(record$LWS) {
  const {
    globalObject: {
      CSSStyleRule: CSSStyleRule$LWS
    }
  } = record$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(CSSStyleRule$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionCustomElementRegistryGet$LWS(record$LWS) {
  var _CustomElementRegistr$LWS;

  const {
    globalObject: {
      CustomElementRegistry: CustomElementRegistry$LWS
    },
    key: key$LWS
  } = record$LWS;
  const LOWERED_NS$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, key$LWS, []); // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurence of the operator

  const originalGet$LWS = CustomElementRegistry$LWS == null ? void 0 : (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.get; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalGet$LWS !== 'function') {
    return null;
  }

  const get$LWS = function get$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const sanitizedName$LWS = toString$LWS(args$LWS[0]);
      const loweredName$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, sanitizedName$LWS, []);

      if (!ReflectApply$LWS(StringProtoStartsWith$LWS, loweredName$LWS, [`${LOWERED_NS$LWS}-`])) {
        return undefined;
      }

      args$LWS[0] = sanitizedName$LWS;
    }

    return ReflectApply$LWS(originalGet$LWS, this, args$LWS);
  };

  return [originalGet$LWS, get$LWS];
}
/**
 * Factory patched cookie getter. Must be invoked with namespace argument.
 * Will return a patched cookie getter bound to the namespace.
 * @param key
 * @returns Distortion: string
 */


function distortionDocumentCookieGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS(Document$LWS.prototype, 'cookie');

  function get$LWS() {
    const documentCookieValue$LWS = ReflectApply$LWS(DocumentProtoCookieGetter$LWS, this, []);
    const cookies$LWS = ReflectApply$LWS(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
    const sandboxedCookies$LWS = [];
    let sandboxedCookiesOffset$LWS = 0;

    for (let i$LWS = 0, {
      length: length$LWS
    } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);

      if (cookie$LWS) {
        sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
      }
    }

    return ReflectApply$LWS(ArrayProtoJoin$LWS, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
  }

  return [originalCookieGetter$LWS, get$LWS];
}
/**
 * Factory patched cookie setter. Must be invoked with namespace argument.
 * Returns a distortion function bound to the namespace.
 */


function distortionDocumentCookieSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    },
    key: key$LWS
  } = record$LWS;
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');

  function set$LWS(value$LWS) {
    const cookieEntries$LWS = ReflectApply$LWS(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
    let {
      0: newCookieEntry$LWS
    } = cookieEntries$LWS;

    if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
      newCookieEntry$LWS = ReflectApply$LWS(StringProtoSlice$LWS, newCookieEntry$LWS, [1]);
    }

    cookieEntries$LWS[0] = prefixNamespace$LWS(newCookieEntry$LWS, key$LWS);
    const cookie$LWS = ReflectApply$LWS(ArrayProtoJoin$LWS, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
    ReflectApply$LWS(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
  }

  return [originalCookieSetter$LWS, set$LWS];
}

function distortionDocumentDomainSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');

  function domain$LWS() {
    throw new LockerSecurityError$LWS('Cannot set document.domain.');
  }

  return [originalDomainSetter$LWS, domain$LWS];
}

function distortionDocumentExecCommand$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS,
      HTMLElement: HTMLElement$LWS
    },
    type: type$LWS
  } = record$LWS;
  const {
    prototype: DocumentProto$LWS
  } = Document$LWS;
  const {
    execCommand: originalExecCommand$LWS
  } = DocumentProto$LWS;
  const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'isContentEditable'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function execCommand$LWS(...args$LWS) {
    if (args$LWS.length > 2) {
      const {
        2: unsanitizedValue$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
        const command$LWS = toString$LWS(args$LWS[0]); // istanbul ignore else: LWS does not test for all possible commands

        if (ReflectApply$LWS(StringProtoToLowerCase$LWS, command$LWS, []) === 'inserthtml') {
          // istanbul ignore else: external is the default sandbox type for coverage runs
          if (type$LWS === 0
          /* External */
          ) {
            const activeElement$LWS = ReflectApply$LWS(originalActiveElement$LWS, this, []);

            if (isSharedElement$LWS(activeElement$LWS) && ReflectApply$LWS(originalIsContentEditable$LWS, activeElement$LWS, [])) {
              throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, activeElement$LWS, []))}.`);
            }
          }

          args$LWS[0] = command$LWS;
          args$LWS[2] = sanitize$LWS(unsanitizedValue$LWS);
        }
      }
    }

    return ReflectApply$LWS(originalExecCommand$LWS, this, args$LWS);
  }

  return [originalExecCommand$LWS, execCommand$LWS];
} // Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes


const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;

function sanitizeWindowOpenArguments$LWS(args$LWS) {
  const sanitizedArgs$LWS = shallowCloneArray$LWS(args$LWS);

  if (sanitizedArgs$LWS.length > 2) {
    // Lowercase the features string because it is case insensitive.
    // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
    const windowFeatures$LWS = toString$LWS(sanitizedArgs$LWS[2]);
    let loweredWindowFeatures$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, windowFeatures$LWS, []); // RegExp.prototype[Symbol.replace] resets the lastIndex of global
    // regexp to 0.
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace

    if (ReflectApply$LWS(RegExpProtoTest$LWS, noopenerRegExp$LWS, [windowFeatures$LWS])) {
      // Replacing noopener with an enabled state that is supported
      // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
      loweredWindowFeatures$LWS = ReflectApply$LWS(StringProtoReplace$LWS, loweredWindowFeatures$LWS, [// RegExp.prototype[Symbol.replace] resets the lastIndex of
      // global regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
    }

    sanitizedArgs$LWS[2] = loweredWindowFeatures$LWS;
  }

  return sanitizedArgs$LWS;
}

function distortionDocumentOpen$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const {
    open: originalDocumentOpen$LWS
  } = Document$LWS.prototype;

  function open$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 3) {
      // Distort three-argument document.open calls which is an alias for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
      return ReflectApply$LWS(originalDocumentOpen$LWS, this, sanitizedArgs$LWS);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalDocumentOpen$LWS, this, args$LWS);
  }

  return [originalDocumentOpen$LWS, open$LWS];
}

function distortionDocumentReplaceChildren$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS
    }
  } = record$LWS;
  const {
    replaceChildren: originalReplaceChild$LWS
  } = Document$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function replaceChildren$LWS(...args$LWS) {
    // To figure out if "this" is the top level document, we can check if
    // its `head` property is a shared element. This will allow magenta window
    // documents to call replaceChildren successfully.
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(ReflectApply$LWS(DocumentProtoHeadGetter$LWS, this, []))) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChildren$LWS];
}

function distortionDOMParserParseFromString$LWS(record$LWS) {
  const {
    globalObject: {
      DOMParser: DOMParser$LWS
    }
  } = record$LWS;
  const {
    parseFromString: originalParseFromString$LWS
  } = DOMParser$LWS.prototype;

  function parseFromString$LWS(...args$LWS) {
    // DOMParser.prototype.parseFromString can only be called with exactly
    // two arguments. If it receives one argument, it will fail. Some implementations
    // will also fail if it receives more than two arguments. Since any call that does
    // not have at least two arguments will fail no matter what, we only need to
    // expend effort to sanitize when we know that the operation is definitely
    // NOT going to fail.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length >= 2) {
      // Override the value of the first argument with a sanitized version
      // of that argument.
      const string$LWS = toString$LWS(args$LWS[0]);
      const mimeType$LWS = toString$LWS(args$LWS[1]);
      args$LWS[0] = // If the provided mimeType indicates that the first argument is
      // an svg, use the svg sanitizer instead of the default sanitizer.
      mimeType$LWS === 'image/svg+xml' ? sanitizeSvgInnerHtml$LWS(string$LWS) : // If the provided mimeType indicates that the first argument
      // is xml, there's nothing to do.
      mimeType$LWS === 'application/xhtml+xml' || mimeType$LWS === 'application/xml' || mimeType$LWS === 'text/xml' ? string$LWS : sanitize$LWS(string$LWS);
    }

    return ReflectApply$LWS(originalParseFromString$LWS, this, args$LWS);
  }

  return [originalParseFromString$LWS, parseFromString$LWS];
}

function distortionElementAfter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    after: originalAfter$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAfter$LWS, this, args$LWS);
  }

  return [originalAfter$LWS, after$LWS];
}

function distortionElementAppend$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    append: originalAppend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
        }
      }
    }

    return ReflectApply$LWS(originalAppend$LWS, this, args$LWS);
  }

  return [originalAppend$LWS, append$LWS];
}

function distortionElementAttachShadow$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    attachShadow: originalAttachShadow$LWS
  } = Element$LWS.prototype;

  function attachShadow$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: originalShadowRootInit$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (originalShadowRootInit$LWS !== null && originalShadowRootInit$LWS !== undefined) {
        // Snapshot shadowRootInit to avoid getter poisoning.
        const {
          mode: mode$LWS
        } = originalShadowRootInit$LWS;

        if (mode$LWS !== 'closed') {
          throw new LockerSecurityError$LWS("Shadow root mode cannot be 'open.'");
        } // Assign own properties and set prototype of shadowRootInit because
        // attachShadow() accepts inherited shadowRootInit properties.


        const shadowRootInit$LWS = ObjectAssign$LWS({}, originalShadowRootInit$LWS, {
          mode: mode$LWS
        }); // Set the prototype of shadowRootInit after assignment of mode
        // to avoid complications with inherited non-configurable/non-writable
        // mode properties.

        const originalShadowRootInitProto$LWS = ReflectGetPrototypeOf$LWS(originalShadowRootInit$LWS);
        ReflectSetPrototypeOf$LWS(shadowRootInit$LWS, originalShadowRootInitProto$LWS); // Replace shadowRootInit parameter.

        args$LWS[0] = shadowRootInit$LWS;
      }
    }

    return ReflectApply$LWS(originalAttachShadow$LWS, this, args$LWS);
  }

  return [originalAttachShadow$LWS, attachShadow$LWS];
}

const namedNodeMapToElementRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS());

function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementRegistry$LWS.set(attrInstance$LWS, element$LWS);
}

function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementRegistry$LWS.get(nodeNameMap$LWS); // istanbul ignore else: nothing to do if there's no element

  if (element$LWS) {
    const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: nothing to do if there's no distortion

    if (distortion$LWS) {
      const attrValue$LWS = ReflectApply$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
      return ReflectApply$LWS(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  } // istanbul ignore next: needs default platform behavior test


  return ReflectApply$LWS(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}

function distortionElementAttributesGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'attributes');

  function attributes$LWS() {
    const attrs$LWS = ReflectApply$LWS(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }

  return [originalAttributesGetter$LWS, attributes$LWS];
}

function distortionElementBefore$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    before: originalBefore$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // istanbul ignore else: needs default platform behavior test

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
        }
      }
    }

    return ReflectApply$LWS(originalBefore$LWS, this, args$LWS);
  }

  return [originalBefore$LWS, before$LWS];
}

function distortionElementInnerHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      SVGElement: SVGElement$LWS,
      XMLDocument: XMLDocument$LWS
    }
  } = record$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'innerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function innerHTML$LWS(value$LWS) {
    const isOwnerXMLDocument$LWS = ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;

    if (!isOwnerXMLDocument$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }

      value$LWS = this instanceof SVGElement$LWS ? sanitizeSvgInnerHtml$LWS(this, value$LWS) : sanitize$LWS(value$LWS);
    }

    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [value$LWS]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionElementInsertAdjacentElement$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    insertAdjacentElement: originalInsertAdjacentElement$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
    }

    return ReflectApply$LWS(originalInsertAdjacentElement$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentElement$LWS, insertAdjacentElement$LWS];
}

function distortionElementInsertAdjacentHTML$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    insertAdjacentHTML: originalInsertAdjacentHTML$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function insertAdjacentHTML$LWS(...args$LWS) {
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}`);
    } // istanbul ignore else: needs default platform behavior test


    if (args$LWS.length > 1) {
      args$LWS[1] = sanitize$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(originalInsertAdjacentHTML$LWS, this, args$LWS);
  }

  return [originalInsertAdjacentHTML$LWS, insertAdjacentHTML$LWS];
}

function distortionElementOuterHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function outerHTML$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    ReflectApply$LWS(originalOuterHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalOuterHTMLSetter$LWS, outerHTML$LWS];
}

function distortionElementPrepend$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    prepend: originalPrepend$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary number of arguments
      // which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
        length: length$LWS
      } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS]; // ...If any of the provided arguments is NOT a valid shared element child,
        // which is limited to script and link, an exception is thrown.

        if (!isAllowedSharedElementChild$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = toString$LWS(argValue$LWS instanceof Node$LWS ? ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) :
          /* istanbul ignore next: currently unreachable via tests */
          argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
        }
      }
    }

    return ReflectApply$LWS(originalPrepend$LWS, this, args$LWS);
  }

  return [originalPrepend$LWS, prepend$LWS];
}

function distortionElementRemove$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    remove: originalRemove$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    ReflectApply$LWS(originalRemove$LWS, this, []);
  }

  return [originalRemove$LWS, remove$LWS];
}

function distortionElementReplaceChildren$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    replaceChildren: originalReplaceChildren$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    return ReflectApply$LWS(originalReplaceChildren$LWS, this, args$LWS);
  }

  return [originalReplaceChildren$LWS, replaceChildren$LWS];
}

function distortionElementReplaceWith$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    replaceWith: originalReplaceWith$LWS
  } = Element$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    return ReflectApply$LWS(originalReplaceWith$LWS, this, args$LWS);
  }

  return [originalReplaceWith$LWS, replaceWith$LWS];
}

function distortionElementSetAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element$LWS.prototype;

  function setAttribute$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      const attrName$LWS = toString$LWS(args$LWS[0]);
      const attrValue$LWS = toString$LWS(args$LWS[1]);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);

      if (distortion$LWS) {
        ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
        return;
      } // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"


      args$LWS[0] = attrName$LWS;
      args$LWS[1] = attrValue$LWS;
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, args$LWS);
  }

  return [originalSetAttribute$LWS, setAttribute$LWS];
}

function distortionElementSetAttributeNode$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNode: originalSetAttributeNode$LWS
  } = Element$LWS.prototype;

  function setAttributeNode$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.
    // istanbul ignore if: needs default platform behavior test


    if (ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
      return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
    }

    const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ReflectApply$LWS(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

      if (oldAttr$LWS) {
        // Disconnect old attribute.
        ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      const attrValue$LWS = ReflectApply$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ReflectApply$LWS(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);

      if (newAttr$LWS) {
        // Remove distorted attribute.
        ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = ReflectApply$LWS(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

        ReflectApply$LWS(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNode$LWS, this, [attr$LWS]);
      }

      return undefined;
    }

    return ReflectApply$LWS(originalSetAttributeNode$LWS, this, args$LWS);
  }

  return [originalSetAttributeNode$LWS, setAttributeNode$LWS];
}

function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNodeNS: originalSetAttributeNodeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNodeNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (!(attr$LWS instanceof Attr$LWS)) {
      // Handle non-Attr values using the native API.
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    } // We can't set an attribute connected to another element.
    // Calling the original getter for property ownerElement validates
    // that we are dealing with an instance of Attr.
    // istanbul ignore if: needs default platform behavior test


    if (ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
      return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, args$LWS);
    }

    const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);

    if (distortion$LWS) {
      const oldAttr$LWS = ReflectApply$LWS(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

      if (oldAttr$LWS) {
        // Disconnect the old attribute.
        ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
      }

      const attrValue$LWS = ReflectApply$LWS(AttrProtoValueGetter$LWS, attr$LWS, []);
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      const newAttr$LWS = ReflectApply$LWS(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);

      if (newAttr$LWS) {
        // Remove the distorted attribute.
        ReflectApply$LWS(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
      }

      if (oldAttr$LWS) {
        // Re-attach old attribute to maintain identify checks.
        ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
      }

      if (newAttr$LWS) {
        const newValue$LWS = ReflectApply$LWS(AttrProtoValueGetter$LWS, newAttr$LWS, []); // Set the distorted attr value.

        ReflectApply$LWS(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]); // Replace old attr.

        return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
      }

      return null;
    }

    return ReflectApply$LWS(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
  }

  return [originalSetAttributeNodeNS$LWS, setAttributeNodeNS$LWS];
}

function distortionElementSetAttributeNS$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    setAttributeNS: originalSetAttributeNS$LWS
  } = Element$LWS.prototype;

  function setAttributeNS$LWS(...args$LWS) {
    // istanbul ignore next: needs default platform behavior test
    if (args$LWS.length < 3) {
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
      return;
    }

    let {
      0: attrNamespace$LWS
    } = args$LWS;

    if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
      attrNamespace$LWS = toString$LWS(attrNamespace$LWS);
    }

    const attrName$LWS = toString$LWS(args$LWS[1]);
    const attrValue$LWS = toString$LWS(args$LWS[2]);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

    if (distortion$LWS) {
      ReflectApply$LWS(distortion$LWS, this, [attrValue$LWS]);
      return;
    } // istanbul ignore next: needs default platform behavior test
    // eslint-disable-next-line no-lone-blocks


    {
      // This is in a block to avoid requiring an "instanbul ignore next" for all for lines.
      // We could avoid this entirely by testing the default platform behavior.
      args$LWS[0] = attrNamespace$LWS; // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"

      args$LWS[1] = attrName$LWS;
      args$LWS[2] = attrValue$LWS;
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, args$LWS);
    }
  }

  return [originalSetAttributeNS$LWS, setAttributeNS$LWS];
}

function distortionElementShadowRootGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS(Element$LWS.prototype, 'shadowRoot');

  function shadowRoot$LWS() {
    return null;
  }

  return [originalShadowRootGetter$LWS, shadowRoot$LWS];
}

function distortionElementToggleAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      Element: Element$LWS
    }
  } = record$LWS;
  const {
    hasAttribute: ElementProtoHasAttribute$LWS,
    toggleAttribute: originalToggleAttribute$LWS
  } = Element$LWS.prototype;

  const toggleAttribute$LWS = function toggleAttribute$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 0) {
      const attrName$LWS = toString$LWS(args$LWS[0]);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : []; // Calling the distortion may end this execution entirely, if the distortion throws.

        ReflectApply$LWS(distortion$LWS, this, distortionArgs$LWS); // If the distortion does not throw, then we need to return true | false, based on
        // the presence or absence of this attribute.

        return ReflectApply$LWS(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
      } // Cannot use the normalized attrNameDistortionKey because that value has been
      // lowercased, which may cause issues with case-sensitive attribute names
      // such as svg element's "viewBox"
      // istanbul ignore next: needs default platform behavior test


      args$LWS[0] = attrName$LWS;
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalToggleAttribute$LWS, this, args$LWS);
  };

  return [originalToggleAttribute$LWS, toggleAttribute$LWS];
}

function distortionEval$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      eval: originalEval$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function Eval$LWS(sourceText$LWS) {
    return sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(toString$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS);
  }

  return [originalEval$LWS, Eval$LWS];
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function createDistortedComposedPath$LWS(event$LWS) {
  const currentTarget$LWS = ReflectApply$LWS(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$LWS(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;

  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const eventTarget$LWS = rawComposedPath$LWS[i$LWS];

    if (eventTarget$LWS instanceof ShadowRoot) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }

  return distortedComposedPath$LWS;
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function distortionEventComposedPath$LWS(record$LWS) {
  const {
    globalObject: {
      Event: Event$LWS
    }
  } = record$LWS;
  const {
    composedPath: originalComposedPath$LWS
  } = Event$LWS.prototype;

  function composedPath$LWS() {
    return createDistortedComposedPath$LWS(this);
  }

  return [originalComposedPath$LWS, composedPath$LWS];
} // istanbul ignore next: LWS/Locker currently blocks CustomElementRegistry#define() and disables the composedPath tests


function distortionEventPathGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Event: Event$LWS
    }
  } = record$LWS;
  const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS(Event$LWS.prototype, 'path');

  if (typeof originalPathGetter$LWS !== 'function') {
    return null;
  }

  const path$LWS = function path$LWS() {
    return createDistortedComposedPath$LWS(this);
  };

  return [originalPathGetter$LWS, path$LWS];
}

function distortionEventTargetAddEventListener$LWS(record$LWS) {
  const {
    globalObject: {
      EventTarget: EventTarget$LWS
    }
  } = record$LWS;
  const {
    addEventListener: originalAddEventListener$LWS
  } = EventTarget$LWS.prototype;

  function addEventListener$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS; // Ensure that we fallback to the default platform behavior which
    // should fail if less than 2 arguments are provided.
    // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const eventName$LWS = toString$LWS(args$LWS[0]);

      if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
        var _safeDesc$LWS;

        const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(this.constructor, 'name');
        let safeDesc$LWS; // istanbul ignore else: needs default platform behavior test

        if (unsafeDesc$LWS) {
          safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
        }

        const name$LWS = (_safeDesc$LWS = safeDesc$LWS) == null ? void 0 : _safeDesc$LWS.value;
        let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`; // istanbul ignore else: needs default platform behavior test

        if (typeof name$LWS === 'string') {
          exceptionMessage$LWS += ` to ${name$LWS} object`;
        }

        throw new LockerSecurityError$LWS(`${exceptionMessage$LWS}.`);
      }

      args$LWS[0] = eventName$LWS;
    }

    return ReflectApply$LWS(originalAddEventListener$LWS, this, args$LWS);
  }

  return [originalAddEventListener$LWS, addEventListener$LWS];
}

function distortionFunction$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      Function: originalFunction$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function Function$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;

    if (length$LWS) {
      const lastIndex$LWS = length$LWS - 1;
      args$LWS[lastIndex$LWS] = transformUncompiledSourceText$LWS(toString$LWS(args$LWS[lastIndex$LWS]));
    } // NOTE: Function constructor and eval are controlled by the same CSP rules,
    // which means we can rely on eval to fulfill the behavior of the Function
    // constructor.


    const fn$LWS = sandboxEvaluator$LWS(`(...args) => Function(...args)`, UNCOMPILED_CONTEXT$LWS);
    return ReflectApply$LWS(fn$LWS, this, args$LWS);
  }

  return [originalFunction$LWS, Function$LWS];
}

function distortionHistoryPushState$LWS(record$LWS) {
  const {
    globalObject: {
      History: History$LWS
    }
  } = record$LWS;
  const {
    pushState: originalPushState$LWS
  } = History$LWS.prototype;

  function pushState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPushState$LWS, this, args$LWS);
  }

  return [originalPushState$LWS, pushState$LWS];
}

function distortionHistoryReplaceState$LWS(record$LWS) {
  const {
    globalObject: {
      History: History$LWS
    }
  } = record$LWS;
  const {
    replaceState: originalReplaceState$LWS
  } = History$LWS.prototype;

  function replaceState$LWS(...args$LWS) {
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalReplaceState$LWS, this, args$LWS);
  }

  return [originalReplaceState$LWS, replaceState$LWS];
}

function distortionHTMLElementDatasetGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionHTMLElementInnerTextSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  const innerText$LWS = function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    ReflectApply$LWS(originalInnerTextSetter$LWS, this, [value$LWS]);
  };

  return [originalInnerTextSetter$LWS, innerText$LWS];
} // outerText is not a standard property, so the descriptor could be undefined, like in the case
// of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility


function distortionHTMLElementOuterTextSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return null;
  } // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.


  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  const outerText$LWS = function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))}.`);
    }

    ReflectApply$LWS(originalOuterTextSetter$LWS, this, [value$LWS]);
  };

  return [originalOuterTextSetter$LWS, outerText$LWS];
}

function distortionHTMLElementStyleGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLElement: HTMLElement$LWS
    }
  } = record$LWS;
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement$LWS.prototype, 'style');

  function style$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalStyleGetter$LWS, this, []));
  }

  return [originalStyleGetter$LWS, style$LWS];
}

function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLIFrameElement: HTMLIFrameElement$LWS
    }
  } = record$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');

  function src$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes and relative urls.');
    }

    ReflectApply$LWS(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
  return [originalSrcSetter$LWS, src$LWS];
}

const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'HTMLLinkElement does not allow setting "rel" property to "import" value.';

function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !ReflectApply$LWS(RegExpProtoTest$LWS, importRegExp$LWS, [value$LWS]);
}

function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  } = record$LWS;
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');

  function rel$LWS(value$LWS) {
    const string$LWS = toString$LWS(value$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', NAMESPACE_DEFAULT$LWS, rel$LWS);
  return [originalRelSetter$LWS, rel$LWS];
}

function distortionHTMLLinkElementRelListSetter$LWS(record$LWS) {
  const {
    globalObject: {
      DOMTokenList: DOMTokenList$LWS,
      HTMLLinkElement: HTMLLinkElement$LWS
    }
  } = record$LWS;
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');

  function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ?
    /* istanbul ignore next: needs default platform behavior test */
    ReflectApply$LWS(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toString$LWS(relListValue$LWS);

    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }

    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }

  return [originalRelListSetter$LWS, relList$LWS];
}

function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLObjectElement: HTMLObjectElement$LWS
    }
  } = record$LWS;
  const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, 'data');

  function data$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);

    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLObjectElement.data supports http://, https:// schemes and relative urls.');
    }

    const parsedURL$LWS = parseURL$LWS(urlString$LWS);

    if (!isValidURL$LWS(parsedURL$LWS)) {
      throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }

    ReflectApply$LWS(originalDataSetter$LWS, this, [urlString$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', NAMESPACE_DEFAULT$LWS, data$LWS);
  return [originalDataSetter$LWS, data$LWS];
}

function getDatasetSrcValue$LWS(el$LWS) {
  const dataset$LWS = ReflectApply$LWS(HTMLElementProtoDatasetGetter$LWS, el$LWS, []);
  const distortedSrc$LWS = ObjectLookupOwnValue$LWS(dataset$LWS, 'distortedSrc');
  return distortedSrc$LWS === undefined ? '' : distortedSrc$LWS;
}

function distortionHTMLScriptElementSrcGetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  } = record$LWS;
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLScriptElement$LWS.prototype, 'src');

  function src$LWS() {
    return getDatasetSrcValue$LWS(this) || ReflectApply$LWS(originalSrcGetter$LWS, this, []);
  }

  return [originalSrcGetter$LWS, src$LWS];
}

const SCRIPT_PAYLOAD_NAME$LWS = '$payload$';
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_BLOB_OPTIONS$LWS = {
  __proto__: null,
  type: 'text/javascript'
};
const SCRIPT_BLOB_TEMPLATE$LWS = `document.currentScript[${enquote$LWS(SCRIPT_EVALUATOR_PROPERTY_NAME$LWS)}](decodeURIComponent(${// Enquote with double quotes because `WindowEncodeURIComponent()` encodes
// double quotes (") as (%22).
enquote$LWS(SCRIPT_PAYLOAD_NAME$LWS, CHAR_QUOTE_DOUBLE$LWS)}))`;

function abstractFactoryValueThrower$LWS(proto$LWS, propName$LWS) {
  return function valueThrowerDistortionFactory$LWS(_record$LWS) {
    const {
      [propName$LWS]: originalValue$LWS
    } = proto$LWS;

    function value$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalValue$LWS, value$LWS];
  };
}

function abstractFactoryGetThrower$LWS(proto$LWS, propName$LWS) {
  return function getThrowerDistortionFactory$LWS(_record$LWS) {
    const originalGet$LWS = ObjectLookupOwnGetter$LWS(proto$LWS, propName$LWS);

    function get$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalGet$LWS, get$LWS];
  };
}

function abstractFactorySetThrower$LWS(proto$LWS, propName$LWS) {
  return function setThrowerDistortionFactory$LWS(_record$LWS) {
    const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, propName$LWS);

    function set$LWS() {
      throw new LockerSecurityError$LWS(`Cannot access ${propName$LWS}.`);
    }

    return [originalSet$LWS, set$LWS];
  };
}
/**
 * Wraps the source content of a script tag in the evaluator
 * Creates a blob: url with the wrapped content
 */


function createScriptUrl$LWS(sourceText$LWS) {
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([ReflectApply$LWS(StringProtoReplace$LWS, SCRIPT_BLOB_TEMPLATE$LWS, [SCRIPT_PAYLOAD_NAME$LWS, WindowEncodeURIComponent$LWS(sourceText$LWS)])], SCRIPT_BLOB_OPTIONS$LWS));
}

function createBlockedPropertyDistortionFactories$LWS(proto$LWS, propertyList$LWS, factories$LWS = []) {
  let {
    length: factoriesOffset$LWS
  } = factories$LWS;

  for (let i$LWS = 0, {
    length: length$LWS
  } = propertyList$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = propertyList$LWS[i$LWS];
    const unsafeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS);

    if (unsafeDesc$LWS) {
      const safeDesc$LWS = toSafeDescriptor$LWS(unsafeDesc$LWS);
      const {
        value: value$LWS
      } = safeDesc$LWS;

      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS; // istanbul ignore else

        if (getter$LWS) {
          factories$LWS[factoriesOffset$LWS++] = abstractFactoryGetThrower$LWS(proto$LWS, prop$LWS);
        }

        if (setter$LWS) {
          factories$LWS[factoriesOffset$LWS++] = abstractFactorySetThrower$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {} because prettier
        // won't allow a multi-line comment between "else" and "if", which is where the
        // istanbul ignore directive must go to be effective.
        // istanbul ignore else: currently unreachable via tests
        if (typeof value$LWS === 'function') {
          factories$LWS[factoriesOffset$LWS++] = abstractFactoryValueThrower$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }

  return factories$LWS;
}

function createScriptDistortion$LWS(record$LWS, attributeName$LWS, datasetGetter$LWS) {
  const {
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;
  const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`;
  const normalizerAnchor$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['a']); // Use a computed property to dynamically set the distortion function name
  // without using Reflect.defineProperty().

  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](value$LWS) {
      const originalValue$LWS = value$LWS;
      const elementNamespaceURI$LWS = ReflectApply$LWS(ElementProtoNamespaceURIGetter$LWS, this, []);
      const attributeNamespaceURI$LWS = elementNamespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;

      if (value$LWS === '') {
        ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, value$LWS]);
        return;
      } // Normalize Value


      ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [value$LWS]);
      value$LWS = ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []); // Create Synthetic Attribute

      const dataset$LWS = ReflectApply$LWS(datasetGetter$LWS, this, []);
      dataset$LWS[`distorted${capitalizeFirstChar$LWS(attributeName$LWS)}`] = originalValue$LWS; // Create XHR

      const hostname$LWS = ReflectApply$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
      const xhr$LWS = new XhrCtor$LWS(); // istanbul ignore if: currently unreachable via tests

      if (ReflectApply$LWS(RegExpProtoTest$LWS, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS])) {
        ReflectApply$LWS(XhrProtoWithCredentialsSetter$LWS, xhr$LWS, [true]);
      }

      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
        const status$LWS = ReflectApply$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []);

        if (status$LWS === 200) {
          const responseText$LWS = ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
          ReflectDefineProperty$LWS(this, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
            __proto__: null,
            configurable: true,
            // Create a bound function to obscure the getter
            // source as "[native code]".
            get: ReflectApply$LWS(FunctionProtoBind$LWS, () => {
              ReflectDeleteProperty$LWS(this, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
              const ownerDoc$LWS = ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, this, []);
              const defaultView$LWS = ReflectApply$LWS(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []); // We don't need to use something like
              // `WindowLocationGetter()` because the
              // 'location' property is non-configurable.

              const context$LWS = {
                [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location
              };
              return sourceText$LWS => sandboxEvaluator$LWS(transformUncompiledSourceText$LWS(toString$LWS(sourceText$LWS)), context$LWS, defaultView$LWS, ownerDoc$LWS);
            }, [this])
          });
          ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, createScriptUrl$LWS(responseText$LWS)]);
        } else {
          // The following if statement is enclosed in a dedicated
          // else {} because prettier won't allow a multi-line comment
          // between "else" and "if", which is where the istanbul
          // ignore directive must go to be effective.
          // istanbul ignore else: cannot produce codes beyond 200, 404 in tests
          if (status$LWS === 404) {
            ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, this, [attributeNamespaceURI$LWS, attributeName$LWS, 'blob:http://localhost/not-found']);
          }
        }
      }]);
      ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', value$LWS]);
      ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
    }

  };
  return distortion$LWS;
}

function distortBlockedAttributes$LWS(record$LWS, Ctor$LWS, attributes$LWS, elNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  for (let i$LWS = 0, {
    length: length$LWS
  } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attributeName$LWS = attributes$LWS[i$LWS];
    const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
    const safeCtorName$LWS = toSafeTemplateStringValue$LWS(Ctor$LWS.name);
    const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`; // Use a computed property to dynamically set the distortion function
    // name without using Reflect.defineProperty().

    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${safeCtorName$LWS}.`);
      }
    };
    registerElementSetDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, elNamespace$LWS, distortion$LWS);
  }
}

function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
  const {
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS
    }
  } = record$LWS;
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLScriptElement$LWS.prototype, 'src');
  const src$LWS = createScriptDistortion$LWS(record$LWS, 'src', HTMLElementProtoDatasetGetter$LWS);
  registerElementSetDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
  return [originalSrcSetter$LWS, src$LWS];
}

function distortionIDBObjectStoreAdd$LWS(record$LWS) {
  const {
    globalObject: {
      IDBObjectStore: IDBObjectStore$LWS
    }
  } = record$LWS;
  const {
    add: originalAdd$LWS
  } = IDBObjectStore$LWS.prototype;

  function add$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalAdd$LWS, this, args$LWS);
  }

  return [originalAdd$LWS, add$LWS];
}

function distortionIDBObjectStorePut$LWS(record$LWS) {
  const {
    globalObject: {
      IDBObjectStore: IDBObjectStore$LWS
    }
  } = record$LWS;
  const {
    put: originalPut$LWS
  } = IDBObjectStore$LWS.prototype;

  function put$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      args$LWS[0] = partialStructuredClone$LWS(args$LWS[0]);
    }

    return ReflectApply$LWS(originalPut$LWS, this, args$LWS);
  }

  return [originalPut$LWS, put$LWS];
}

function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: NamedNodeMap$LWS
    }
  } = record$LWS;
  const {
    setNamedItem: originalSetNamedItem$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItem$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (attr$LWS && attr$LWS instanceof Attr$LWS) {
      return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
    }

    return ReflectApply$LWS(originalSetNamedItem$LWS, this, args$LWS);
  }

  return [originalSetNamedItem$LWS, setNamedItem$LWS];
}

function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      NamedNodeMap: NamedNodeMap$LWS
    }
  } = record$LWS;
  const {
    setNamedItemNS: originalSetNamedItemNS$LWS
  } = NamedNodeMap$LWS.prototype;

  function setNamedItemNS$LWS(...args$LWS) {
    const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;

    if (attr$LWS && attr$LWS instanceof Attr$LWS) {
      return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
    }

    return ReflectApply$LWS(originalSetNamedItemNS$LWS, this, args$LWS);
  }

  return [originalSetNamedItemNS$LWS, setNamedItemNS$LWS];
}

function distortionNavigatorSendBeacon$LWS(record$LWS) {
  const {
    globalObject: {
      Navigator: Navigator$LWS
    }
  } = record$LWS;
  const {
    sendBeacon: originalSendBeacon$LWS
  } = Navigator$LWS.prototype;

  function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(args$LWS[0]));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }

    return ReflectApply$LWS(originalSendBeacon$LWS, this, args$LWS);
  }

  return [originalSendBeacon$LWS, sendBeacon$LWS];
}

function distortionNavigatorServiceWorkerGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Navigator: Navigator$LWS
    }
  } = record$LWS;
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS(Navigator$LWS.prototype, 'serviceWorker'); // istanbul ignore if: needs default platform behavior test

  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return null;
  }

  const get$LWS = () => undefined;

  return [originalServiceWorkerGetter$LWS, get$LWS];
}

function distortionNodeInsertBefore$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    insertBefore: originalInsertBefore$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);

  function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(this) && !isAllowedSharedElementChild$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []))} into ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))},`);
      }
    }

    return ReflectApply$LWS(originalInsertBefore$LWS, this, args$LWS);
  }

  return [originalInsertBefore$LWS, insertBefore$LWS];
}

function distortionNodeValueSetter$LWS(record$LWS) {
  const {
    globalObject: {
      Attr: Attr$LWS,
      Node: Node$LWS
    }
  } = record$LWS;
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');

  function nodeValue$LWS(value$LWS) {
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the nodeValue property.
    // istanbul ignore else: needs default platform behavior test
    if (this instanceof Attr$LWS) {
      const ownerEl$LWS = ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

      if (ownerEl$LWS === null) {
        return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
      }

      const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, this, []);
      const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerEl$LWS, [value$LWS]);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalNodeValueSetter$LWS, this, [value$LWS]);
  }

  return [originalNodeValueSetter$LWS, nodeValue$LWS];
}

function distortionNodeRemoveChild$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    removeChild: originalRemoveChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, child$LWS, []))}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalRemoveChild$LWS, this, args$LWS);
  }

  return [originalRemoveChild$LWS, removeChild$LWS];
}

function distortionNodeReplaceChild$LWS(record$LWS) {
  const {
    globalObject: {
      Node: Node$LWS
    }
  } = record$LWS;
  const {
    replaceChild: originalReplaceChild$LWS
  } = Node$LWS.prototype; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments. If the "old element"
    // argument is a valid shared element, an exception is thrown.
    const {
      length: length$LWS
    } = args$LWS; // istanbul ignore else: needs default platform behavior test

    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS; // istanbul ignore else: needs default platform behavior test

      if (isSharedElement$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, child$LWS, []))}.`);
      }
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalReplaceChild$LWS, this, args$LWS);
  }

  return [originalReplaceChild$LWS, replaceChild$LWS];
}

const EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const RAW_VALUE_PROPERTY_NAME$LWS = '$$raw$$';
const SANDBOXED_PROPERTY_NAME$LWS = '$$sandboxed$$';

const inlineEvaluatorCall$LWS = () => `document.currentScript['${EVALUATOR_PROPERTY_NAME$LWS}']();`;
/**
 *
 * @param host: Host element for the evaluator
 * @param src: Raw code to be evaluated
 * @param evaluator: No argument function to be returned to the caller.
 * @returns boolean: False if the getter has been accessed previously. True if only redefined
 */


function setEvaluatorFn$LWS(host$LWS, src$LWS, evaluator$LWS) {
  if (ReflectHas$LWS(host$LWS, SANDBOXED_PROPERTY_NAME$LWS)) {
    return false;
  }

  ReflectDefineProperty$LWS(host$LWS, RAW_VALUE_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    value: src$LWS
  });
  ReflectDefineProperty$LWS(host$LWS, EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter
    // source as "[native code]".
    get: ReflectApply$LWS(FunctionProtoBind$LWS, () => {
      ReflectDeleteProperty$LWS(host$LWS, EVALUATOR_PROPERTY_NAME$LWS);
      ReflectDefineProperty$LWS(host$LWS, SANDBOXED_PROPERTY_NAME$LWS, {
        __proto__: null
      });
      const ownerDoc$LWS = ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, host$LWS, []);
      const globalObject$LWS = ReflectApply$LWS(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
      return () => evaluator$LWS(globalObject$LWS);
    }, [host$LWS])
  });
  return true;
}

function rawValue$LWS(host$LWS) {
  // @ts-ignore
  return host$LWS[RAW_VALUE_PROPERTY_NAME$LWS];
}

function distortionNodeTextContentGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const {
    Node: Node$LWS
  } = globalObject$LWS;
  const originalTextContentGetter$LWS = ObjectLookupOwnGetter$LWS(Node$LWS.prototype, 'textContent');
  const {
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;

  function textContent$LWS() {
    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      const rawSource$LWS = rawValue$LWS(this);

      if (rawSource$LWS !== undefined) {
        return rawSource$LWS;
      }
    }

    return ReflectApply$LWS(originalTextContentGetter$LWS, this, []);
  }

  return [originalTextContentGetter$LWS, textContent$LWS];
}

function distortionNodeTextContentSetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;
  const {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  } = globalObject$LWS;
  const originalTextContentSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'textContent'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function textContent$LWS(value$LWS) {
    const valueAsString$LWS = toString$LWS(value$LWS); // There are two existence of the attribute textContent, one on Attr and one on Node.
    // This first if statement is checking to figure out which distortion should be applied.
    // The instanceof operator tests to see if the current global object, this, is of the type Attr,
    // while also taking inheritance into consideration.
    // W-10476944 Window access via nodeValue/textContent:
    // This distortion sanitizes the given text to prevent window access from being achieved
    // via the textContent property.
    // istanbul ignore else: needs default platform behavior test

    if (this instanceof Attr$LWS) {
      const ownerEl$LWS = ReflectApply$LWS(AttrProtoOwnerElementGetter$LWS, this, []); // istanbul ignore if: needs default platform behavior test

      if (ownerEl$LWS === null) {
        return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      }

      const attrName$LWS = ReflectApply$LWS(AttrProtoNameGetter$LWS, this, []);
      const attrNamespace$LWS = ReflectApply$LWS(AttrProtoNamespaceURIGetter$LWS, this, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS); // istanbul ignore else: needs default platform behavior test

      if (distortion$LWS) {
        return ReflectApply$LWS(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
      }
    }

    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      const didAttach$LWS = setEvaluatorFn$LWS(this, valueAsString$LWS, globalObject$LWS => {
        sandboxEvaluator$LWS(valueAsString$LWS, globalObject$LWS);
        ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
      });

      if (didAttach$LWS) {
        const overrideContent$LWS = inlineEvaluatorCall$LWS();
        return ReflectApply$LWS(originalTextContentSetter$LWS, this, [overrideContent$LWS]);
      }
    } // istanbul ignore else: needs default platform behavior test


    if (isSharedElement$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set textContent of ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, this, []))} elements.`);
    }

    return ReflectApply$LWS(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
  }

  return [originalTextContentSetter$LWS, textContent$LWS];
}

function distortionNotificationCtor$LWS(record$LWS) {
  const {
    globalObject: {
      Notification: originalNotificationCtor$LWS
    }
  } = record$LWS; // istanbul ignore if: needs default platform behavior test

  if (typeof originalNotificationCtor$LWS !== 'function') {
    return null;
  }

  const Notification$LWS = function Notification$LWS(...args$LWS) {
    if (args$LWS.length > 1) {
      args$LWS[1] = partialStructuredClone$LWS(args$LWS[1]);
    }

    return ReflectApply$LWS(originalNotificationCtor$LWS, this, args$LWS);
  };

  return [originalNotificationCtor$LWS, Notification$LWS];
}

function distortionRangeCreateContextualFragment$LWS(record$LWS) {
  const {
    globalObject: {
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    createContextualFragment: originalCreateContextualFragment$LWS
  } = Range$LWS.prototype;

  function createContextualFragment$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: tagString$LWS
      } = args$LWS;

      if (tagString$LWS !== null && tagString$LWS !== undefined) {
        args$LWS[0] = sanitize$LWS(tagString$LWS);
      }
    }

    return ReflectApply$LWS(originalCreateContextualFragment$LWS, this, args$LWS);
  }

  return [originalCreateContextualFragment$LWS, createContextualFragment$LWS];
}

function distortionRangeDeleteContents$LWS(record$LWS) {
  const {
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    deleteContents: originalDeleteContents$LWS
  } = Range$LWS.prototype; // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  //
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.

  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range$LWS;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS(AbstractRangeProto$LWS, 'startContainer'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS(originalDeleteContents$LWS, this, args$LWS);
  }

  return [originalDeleteContents$LWS, deleteContents$LWS];
}

function distortionRangeExtractContents$LWS(record$LWS) {
  const {
    globalObject: {
      AbstractRange: AbstractRange$LWS,
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    extractContents: originalExtractContents$LWS
  } = Range$LWS.prototype; // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  //
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.

  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range$LWS;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS(AbstractRangeProto$LWS, 'startContainer'); // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.

  const {
    isSharedElement: isSharedElement$LWS
  } = getValidator$LWS(record$LWS.top);

  function extractContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS(originalStartContainerGetter$LWS, this, [])];

    for (let i$LWS = 0, {
      length: length$LWS
    } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];

      if (isSharedElement$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS(originalExtractContents$LWS, this, args$LWS);
  }

  return [originalExtractContents$LWS, extractContents$LWS];
}

function distortionRangeInsertNode$LWS(record$LWS) {
  // IMPORTANT! This validator MUST use the "window" global object, and not the provided
  // "globalObject" because future magenta objects (arbitrary user-code created global objects)
  // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
  // content window). Using the provided "globalObject" here would result in receiving a validator
  // bound to the magenta global object, which would erroneously prevent code from interacting
  // with that document's <html>, <head> and <body>.
  const {
    isSharedElement: isSharedElement$LWS,
    isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
  } = getValidator$LWS(record$LWS.top);
  const {
    globalObject: {
      Range: Range$LWS
    }
  } = record$LWS;
  const {
    insertNode: originalInsertNode$LWS
  } = Range$LWS.prototype;
  const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$LWS(Range$LWS.prototype, 'commonAncestorContainer');

  function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      const commonAncestorContainer$LWS = ReflectApply$LWS(originalCommonAncestorContainerGetter$LWS, this, []);

      if (commonAncestorContainer$LWS && isSharedElement$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
      }
    }

    return ReflectApply$LWS(originalInsertNode$LWS, this, args$LWS);
  }

  return [originalInsertNode$LWS, insertNode$LWS];
}

function createRangeProtoMethodDistortionFactory$LWS(methodName$LWS) {
  return function distortionContentWindowGetter$LWS(record$LWS) {
    const {
      globalObject: {
        Range: Range$LWS
      }
    } = record$LWS;
    const {
      prototype: RangeProto$LWS
    } = Range$LWS;
    const {
      [methodName$LWS]: originalMethod$LWS
    } = RangeProto$LWS; // IMPORTANT! This validator MUST use the "window" global object, and not the provided
    // "globalObject" because magenta objects (arbitrary user-code created global objects)
    // must be allowed to interact with their OWN <html>, <head> and <body> (within the iframe
    // content window). Using the provided "globalObject" here would result in receiving a validator
    // bound to the magenta global object, which would erroneously prevent code from interacting
    // with that document's <html>, <head> and <body>.

    const {
      isSharedElement: isSharedElement$LWS
    } = getValidator$LWS(record$LWS.top);

    function method$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: node$LWS
        } = args$LWS; // istanbul ignore else: needs default platform behavior test

        if (isSharedElement$LWS(node$LWS)) {
          throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${toSafeTemplateStringValue$LWS(ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []))}.`);
        }
      }

      return ReflectApply$LWS(originalMethod$LWS, this, args$LWS);
    }

    return [originalMethod$LWS, method$LWS];
  };
}

const distortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactory$LWS('setEnd');
const distortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactory$LWS('selectNode');
const distortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactory$LWS('selectNodeContents');
const distortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactory$LWS('setEndAfter');
const distortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactory$LWS('setEndBefore');
const distortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactory$LWS('setStart');
const distortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactory$LWS('setStartAfter');
const distortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactory$LWS('setStartBefore');
const distortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactory$LWS('surroundContents');

function distortionServiceWorkerContainer$LWS(record$LWS) {
  const {
    globalObject: {
      ServiceWorkerContainer: ServiceWorkerContainer$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionShadowRootInnerHTMLSetter$LWS(record$LWS) {
  const {
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  } = record$LWS;
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');

  function innerHTML$LWS(value$LWS) {
    ReflectApply$LWS(originalInnerHTMLSetter$LWS, this, [sanitize$LWS(value$LWS)]);
  }

  return [originalInnerHTMLSetter$LWS, innerHTML$LWS];
}

function distortionShadowRootModeGetter$LWS(record$LWS) {
  const {
    globalObject: {
      ShadowRoot: ShadowRoot$LWS
    }
  } = record$LWS;
  const originalModeGetter$LWS = ObjectLookupOwnGetter$LWS(ShadowRoot$LWS.prototype, 'mode');

  function mode$LWS() {
    return 'closed';
  }

  return [originalModeGetter$LWS, mode$LWS];
}

function distortionSharedWorkerCtor$LWS(record$LWS) {
  const {
    globalObject: {
      SharedWorker: originalSharedWorkerCtor$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return null;
  }

  const SharedWorker$LWS = function SharedWorker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  };

  return [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
}

function distortionSharedWorkerProto$LWS(record$LWS) {
  const {
    globalObject: {
      SharedWorker: SharedWorker$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof SharedWorker$LWS !== 'function') {
    return null;
  }

  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function getStorageRootKey$LWS(namespace$LWS) {
  return `LSKey[${namespace$LWS}]`;
}

function getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS) {
  return `${storageRootKey$LWS}${key$LWS}`;
}

function getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;

  for (let i$LWS = 0, {
    length: length$LWS
  } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];

    if (ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [storageRootKey$LWS])) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }

  return keys$LWS;
}

function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = ArrayCtor$LWS(length$LWS);

  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = ReflectApply$LWS(StringProtoReplace$LWS, key$LWS, [storageRootKey$LWS, '']);
  }

  return keys$LWS;
}

const storageToMetaMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS());

function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS); // istanbul ignore if: currently unreachable via tests

  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS('Illegal invocation');
  }

  return storageMeta$LWS;
}

function createStorageProxy$LWS(s$LWS) {
  return new Proxy(s$LWS, {
    get(target$LWS, key$LWS, receiver$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$LWS(storage$LWS, keyForNamespace$LWS)) {
        return ReflectGet$LWS(storage$LWS, keyForNamespace$LWS);
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },

    set(target$LWS, key$LWS, value$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, [keyForNamespace$LWS, value$LWS]);
      return true;
    },

    defineProperty(target$LWS, key$LWS, descriptor$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const safeDesc$LWS = toSafeDescriptor$LWS(descriptor$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDefineProperty$LWS(storage$LWS, keyForNamespace$LWS, safeDesc$LWS);
    },

    deleteProperty(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectDeleteProperty$LWS(storage$LWS, keyForNamespace$LWS);
    },

    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);
      return ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, keyForNamespace$LWS);
    },

    ownKeys(target$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, storageRootKey$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },

    has(target$LWS, key$LWS) {
      const {
        storage: storage$LWS,
        storageRootKey: storageRootKey$LWS
      } = getStorageMetaOrThrowInvalidInvocation$LWS(target$LWS);

      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }

      const keyForNamespace$LWS = getStorageKeyForNamespace$LWS(storageRootKey$LWS, key$LWS);

      if (ObjectHasOwn$LWS(storage$LWS, keyForNamespace$LWS)) {
        return true;
      }

      const proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);

      if (proto$LWS === null) {
        return false;
      }

      return ReflectHas$LWS(proto$LWS, key$LWS);
    },

    preventExtensions(_target$LWS) {
      return false;
    }

  });
}

class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new LockerSecurityError$LWS('Illegal constructor');
  }

  get length() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
    return storageKeysForNamespace$LWS.length;
  }

  key(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;

      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }

      return ReflectApply$LWS(StringProtoReplace$LWS, resolvedKey$LWS, [storageRootKey$LWS, '']);
    }

    return ReflectApply$LWS(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }

  getItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    return ReflectApply$LWS(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }

  setItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length > 1) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
      args$LWS[1] = toString$LWS(args$LWS[1]);
    }

    ReflectApply$LWS(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }

  removeItem(...args$LWS) {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);

    if (args$LWS.length) {
      args$LWS[0] = getStorageKeyForNamespace$LWS(storageRootKey$LWS, toString$LWS(args$LWS[0]));
    }

    ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }

  clear() {
    const {
      storage: storage$LWS,
      storageRootKey: storageRootKey$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, storageRootKey$LWS);

    for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$LWS(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }

}

function createStorage$LWS(storage$LWS, storageRootKey$LWS) {
  const target$LWS = {
    __proto__: PatchedStorage$LWS.prototype
  };
  markLiveObject$LWS(target$LWS);
  const proxy$LWS = createStorageProxy$LWS(target$LWS);
  const storageMeta$LWS = {
    proxy: proxy$LWS,
    storage: storage$LWS,
    storageRootKey: storageRootKey$LWS
  };
  storageToMetaMap$LWS.set(proxy$LWS, storageMeta$LWS);
  storageToMetaMap$LWS.set(target$LWS, storageMeta$LWS);
  return proxy$LWS;
}

const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS(PatchedStorageProto$LWS, 'length');

function createDistortionStorageFactory$LWS(storageName$LWS) {
  return function distortionStorageFactory$LWS(record$LWS) {
    const {
      globalObject: globalObject$LWS,
      key: key$LWS
    } = record$LWS; // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.

    let originalStorageObject$LWS;

    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS]; // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {} // istanbul ignore if: currently unreachable via tests


    if (!isObject$LWS(originalStorageObject$LWS)) {
      return null;
    }

    const patchedStorageObject$LWS = createStorage$LWS(originalStorageObject$LWS, getStorageRootKey$LWS(key$LWS));
    return [originalStorageObject$LWS, patchedStorageObject$LWS];
  };
}

function distortionStorageLength$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(Storage$LWS.prototype, 'length');
  return [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
}

function distortionStorageGetItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    getItem: originalStorageGetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
}

function distortionStorageSetItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    setItem: originalStorageSetItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
}

function distortionStorageKey$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    key: originalStorageKey$LWS
  } = Storage$LWS.prototype;
  return [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
}

function distortionStorageRemoveItem$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    removeItem: originalStorageRemoveItem$LWS
  } = Storage$LWS.prototype;
  return [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
}

function distortionStorageClear$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  const {
    clear: originalStorageClear$LWS
  } = Storage$LWS.prototype;
  return [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
}

function distortionStorage$LWS(record$LWS) {
  const {
    globalObject: {
      Storage: Storage$LWS
    }
  } = record$LWS;
  return [Storage$LWS, PatchedStorage$LWS];
}

const distortionLocalStorage$LWS = createDistortionStorageFactory$LWS('localStorage');
const distortionSessionStorage$LWS = createDistortionStorageFactory$LWS('sessionStorage');

function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ReflectApply$LWS(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
      const originalAttributeValue$LWS = ReflectApply$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'from');
      distortAttribute$LWS(this, 'to');
      distortAttribute$LWS(this, 'values');
    }
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
  return null;
}

function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function from$LWS(value$LWS) {
    if (ReflectApply$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', NAMESPACE_DEFAULT$LWS, from$LWS);
  return null;
}

function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ReflectApply$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
  return null;
}

function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGAnimateElement: SVGAnimateElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;

    if (ReflectApply$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = ReflectApply$LWS(StringProtoSplit$LWS, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;

      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }

      returnValues$LWS = ReflectApply$LWS(ArrayProtoJoin$LWS, valuesSplit$LWS, [';']);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', NAMESPACE_DEFAULT$LWS, values$LWS);
  return null;
}

function distortionSVGElementDatasetGetter$LWS(record$LWS) {
  const {
    globalObject: {
      SVGElement: SVGElement$LWS
    }
  } = record$LWS;
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS(SVGElement$LWS.prototype, 'dataset');

  function dataset$LWS() {
    return toLiveValue$LWS(ReflectApply$LWS(originalDatasetGetter$LWS, this, []));
  }

  return [originalDatasetGetter$LWS, dataset$LWS];
}

function distortionSVGScriptElementHrefAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGScriptElement: SVGScriptElement$LWS
    }
  } = record$LWS;
  registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'href', SVGElementProtoDatasetGetter$LWS));
  registerElementSetDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href', SVGElementProtoDatasetGetter$LWS));
  return null;
}

function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGSetElement: SVGSetElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function distortAttribute$LWS(el$LWS, attrName$LWS) {
    if (ReflectApply$LWS(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
      const originalAttributeValue$LWS = ReflectApply$LWS(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]); // istanbul ignore else: needs default platform behavior test

      if (originalAttributeValue$LWS) {
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS); // istanbul ignore else: needs default platform behavior test

        if (distortion$LWS) {
          ReflectApply$LWS(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
        }
      }
    }
  }

  function attributeName$LWS(value$LWS) {
    ReflectApply$LWS(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);

    if (value$LWS === 'href') {
      distortAttribute$LWS(this, 'to');
    }
  }

  registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
  return null;
}

function distortionSVGSetElementToAttribute$LWS(record$LWS) {
  const {
    globalObject: {
      SVGSetElement: SVGSetElement$LWS
    }
  } = record$LWS;
  const {
    setAttribute: originalSetAttribute$LWS
  } = Element.prototype;

  function to$LWS(value$LWS) {
    if (ReflectApply$LWS(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }

    ReflectApply$LWS(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }

  registerElementSetDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
  return null;
}

function createDistortionHrefAttributeFactory$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactory$LWS(record$LWS) {
    const {
      globalObject: {
        SVGUseElement: SVGUseElement$LWS
      }
    } = record$LWS;
    const {
      setAttribute: originalSetAttribute$LWS,
      setAttributeNS: originalSetAttributeNS$LWS
    } = Element.prototype;

    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
      /* istanbul ignore next: needs default platform behavior test */
      value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$LWS(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }

    registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);

    if (attributeName$LWS === 'href') {
      const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
        const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ?
        /* istanbul ignore next: needs default platform behavior test */
        value$LWS : sanitizeSvgHref$LWS(value$LWS);
        ReflectApply$LWS(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
      };

      registerElementSetDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
    }

    return null;
  };
}

const distortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('href');
const distortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactory$LWS('xlink:href');

function distortionTrustedTypePolicyFactoryCreatePolicy$LWS(record$LWS) {
  const {
    globalObject: {
      TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
    }
  } = record$LWS; // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof TrustedTypePolicyFactory$LWS !== 'function') {
    return null;
  }

  const {
    createPolicy: originalCreatePolicy$LWS
  } = TrustedTypePolicyFactory$LWS.prototype;

  const createPolicy$LWS = function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] :
    /* istanbul ignore next: needs default platform behavior test */
    undefined; // istanbul ignore else: needs default platform behavior test

    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(`Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`);
    } // istanbul ignore next: needs default platform behavior test


    return ReflectApply$LWS(originalCreatePolicy$LWS, this, args$LWS);
  };

  return [originalCreatePolicy$LWS, createPolicy$LWS];
}

const HTML_MIME_TYPES_LIST$LWS = toSafeArray$LWS(['text/html', 'image/svg+xml', 'text/xml']);

function distortionURLCreateObjectURL$LWS(record$LWS) {
  const {
    globalObject: {
      URL: URL$LWS
    }
  } = record$LWS;
  const {
    createObjectURL: originalCreateObjectURL$LWS
  } = URL$LWS;
  const {
    isEqualDomString: isEqualDomString$LWS,
    isMediaSourceObject: isMediaSourceObject$LWS
  } = getValidator$LWS(record$LWS);

  function createObjectURL$LWS(blobObject$LWS) {
    // Create a URL object first using the native APIs.
    // This will ensure native validation against undefined and other
    // non-accepted types.
    let outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [blobObject$LWS]); // MediaSource does not share the same proto object as Blob or File.
    // It can still be used with createObjectURL however we need to treat it separately.
    // MediaSource does not accept plain text input as Blob and File and does not have a MIME type.

    if (isMediaSourceObject$LWS(blobObject$LWS)) {
      return outURL$LWS;
    }

    const blobType$LWS = ReflectApply$LWS(BlobProtoTypeGetter$LWS, blobObject$LWS, []);

    if (blobType$LWS === '') {
      // Browsers interpret the empty MIME type differently.
      // Chrome makes it text/plain.
      // Firefox attempts to guess the content.
      // Safari makes it application/octet-stream effectively forcing a download of the content.
      // We need to normalize the behavior here.
      const plainTextBlob$LWS = ReflectApply$LWS(BlobProtoSlice$LWS, blobObject$LWS, [0, undefined, 'text/plain']);
      return ReflectApply$LWS(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
    }

    const loweredBlobType$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, blobType$LWS, []);

    if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
      const blobSize$LWS = ReflectApply$LWS(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
      const normalizedBlob$LWS = ReflectApply$LWS(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
      URLRevokeObjectURL$LWS(outURL$LWS);
      outURL$LWS = ReflectApply$LWS(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
      const xhr$LWS = new XhrCtor$LWS();
      ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', outURL$LWS, false]);
      ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
      const sanitizer$LWS = blobSanitizer$LWS();
      const responseText$LWS = ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);

      if (!isEqualDomString$LWS(responseText$LWS, sanitized$LWS)) {
        URLRevokeObjectURL$LWS(outURL$LWS);
        throw new LockerSecurityError$LWS(`Cannot 'createObjectURL' using a unsecure ${toSafeTemplateStringValue$LWS(blobObject$LWS)}.`);
      }

      return outURL$LWS;
    }

    if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
      return outURL$LWS;
    }

    URLRevokeObjectURL$LWS(outURL$LWS);
    throw new LockerSecurityError$LWS('Unsupported MIME type.');
  }

  return [originalCreateObjectURL$LWS, createObjectURL$LWS];
}

function distortionWindowFetch$LWS(record$LWS) {
  const {
    globalObject: {
      fetch: originalFetch$LWS
    }
  } = record$LWS;

  function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;

    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;

      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(ReflectApply$LWS(RequestProtoURLGetter$LWS, url$LWS, []));
      } else {
        parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }

      if (!isValidURL$LWS(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
      }
    }

    return ReflectApply$LWS(originalFetch$LWS, this, args$LWS);
  }

  return [originalFetch$LWS, fetch$LWS];
}
/* eslint-disable class-methods-use-this, max-classes-per-file */
// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target


class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }

  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }

  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }

  isExtensible(_target$LWS) {
    return true;
  }

  ownKeys(_target$LWS) {
    return [];
  }

  preventExtensions(_target$LWS) {
    return true;
  }

  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }

  setPrototypeOf(_target$LWS) {
    return false;
  }

}

ReflectSetPrototypeOf$LWS(BaseFrameHandler$LWS.prototype, null);
ObjectFreeze$LWS(BaseFrameHandler$LWS.prototype);

class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}

ObjectFreeze$LWS(ShadowFramesPrototypeHandler$LWS.prototype);

function distortionWindowFramesGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'frames'); // istanbul ignore if: this is a safety precaution, but currently unreachable via tests

  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return null;
  }

  let framesProxy$LWS;

  const frames$LWS = function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS(globalObject$LWS);
      const WindowProperties$LWS = ReflectGetPrototypeOf$LWS(WindowPrototype$LWS); // Wrap `WindowLengthGetter` in bound function to obscure the getter
      // source as "[native code]".

      const framesLengthGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]); // Wrap `noop` in bound function to obscure the setter source as
      // "[native code]".

      const framesLengthSetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS, noop$LWS, []);

      const getFrameByIndexKey$LWS = key$LWS => {
        const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;

        if (possibleIndex$LWS > -1 && NumberIsInteger$LWS(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$LWS(WindowLengthGetter$LWS, globalObject$LWS, [])) {
          const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);

          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }

        return undefined;
      };

      const getFrameByNameKey$LWS = key$LWS => {
        if (typeof key$LWS === 'string' && // Don't shadow properties on the global object...
        !ObjectHasOwn$LWS(globalObject$LWS, key$LWS) && // ...Or its prototype.
        !ObjectHasOwn$LWS(WindowPrototype$LWS, key$LWS)) {
          const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);

          if (isWindow$LWS(value$LWS)) {
            return value$LWS;
          }
        }

        return undefined;
      };

      const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? ReflectApply$LWS(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);

      class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getValueByKey$LWS(key$LWS);
          return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
          ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : // window.frames.length
          // window.frames[n]
          // window.frames['n']
          value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          if (key$LWS === 'length') {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              get: framesLengthGetter$LWS,
              set: framesLengthSetter$LWS
            };
          }

          const value$LWS = getFrameByIndexKey$LWS(key$LWS);

          if (value$LWS) {
            return {
              __proto__: null,
              configurable: true,
              enumerable: true,
              value: value$LWS,
              writable: false
            };
          }

          return undefined;
        }

        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
        }

        ownKeys() {
          const {
            length: length$LWS
          } = globalObject$LWS;
          const keys$LWS = ArrayCtor$LWS(length$LWS + 1);

          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            keys$LWS[i$LWS] = `${i$LWS}`;
          }

          keys$LWS[length$LWS] = 'length';
          return keys$LWS;
        }

      }

      ObjectFreeze$LWS(ShadowFrameHandler$LWS.prototype);

      class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
        get(target$LWS, key$LWS, receiver$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);
          return value$LWS === undefined ? // window.frames.foo when iframe.name is 'foo'
          ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) :
          /* istanbul ignore next: needs default platform behavior test */
          value$LWS;
        }

        getOwnPropertyDescriptor(_target$LWS, key$LWS) {
          const value$LWS = getFrameByNameKey$LWS(key$LWS);

          if (value$LWS === undefined) {
            return value$LWS;
          }

          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }

        has(target$LWS, key$LWS) {
          return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
        }

        ownKeys() {
          const keys$LWS = [];
          let keysOffset$LWS = 0;
          const descMap$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
          ReflectSetPrototypeOf$LWS(descMap$LWS, null);

          for (const key$LWS in descMap$LWS) {
            if (typeof key$LWS === 'string') {
              const unsafeDesc$LWS = descMap$LWS[key$LWS];

              if (ObjectHasOwn$LWS(unsafeDesc$LWS, 'value') && isWindow$LWS(unsafeDesc$LWS.value)) {
                keys$LWS[keysOffset$LWS++] = key$LWS;
              }
            }
          }

          return keys$LWS;
        }

      }

      ObjectFreeze$LWS(ShadowWindowPropertiesHandler$LWS.prototype); // In order to preserve window.frames === window.frames, create a
      // shadow target object, to be used with the proxy object that is
      // returned by accesses to window.frames.

      const shadowFrames$LWS = {};
      const shadowFramesPrototype$LWS = {};
      const shadowWindowProperties$LWS = {};
      const shadowFramesHandler$LWS = ObjectFreeze$LWS(new ShadowFrameHandler$LWS());
      const shadowFramesPrototypeHandler$LWS = ObjectFreeze$LWS(new ShadowFramesPrototypeHandler$LWS());
      const shadowWindowPropertiesHandler$LWS = ObjectFreeze$LWS(new ShadowWindowPropertiesHandler$LWS());
      const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
      const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
      ReflectSetPrototypeOf$LWS(shadowFrames$LWS, framesPrototypeProxy$LWS);
      ReflectSetPrototypeOf$LWS(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
      framesProxy$LWS = new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
    }

    return framesProxy$LWS;
  };

  return [originalWindowFramesGetter$LWS, frames$LWS];
}

function distortionWindowGetComputedStyle$LWS(record$LWS) {
  const {
    globalObject: {
      getComputedStyle: originalGetComputedStyle$LWS
    }
  } = record$LWS;

  function getComputedStyle$LWS(...args$LWS) {
    return toLiveValue$LWS(ReflectApply$LWS(originalGetComputedStyle$LWS, this, args$LWS));
  }

  return [originalGetComputedStyle$LWS, getComputedStyle$LWS];
}

function distortionWindowLengthGetter$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS(globalObject$LWS, 'length'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalLengthGetter$LWS !== 'function') {
    return null;
  }

  const length$LWS = function length$LWS() {
    return 0;
  };

  return [originalLengthGetter$LWS, length$LWS];
}

function distortionWindowOnstorage$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  const {
    Window: Window$LWS
  } = globalObject$LWS;
  const originalOnstorageSetter$LWS = ObjectLookupOwnSetter$LWS(globalObject$LWS, 'onstorage'); // istanbul ignore if: currently unreachable via tests

  if (typeof originalOnstorageSetter$LWS !== 'function') {
    return null;
  }

  const onstorage$LWS = function onstorage$LWS() {
    throw new LockerSecurityError$LWS('Cannot set window.onstorage.');
  };

  registerEventTargetRestriction$LWS(record$LWS, Window$LWS, 'storage');
  return [originalOnstorageSetter$LWS, onstorage$LWS];
}

function distortionWindowOpen$LWS(record$LWS) {
  const {
    globalObject: {
      open: originalWindowOpen$LWS
    }
  } = record$LWS;

  function open$LWS(...args$LWS) {
    const sanitizedArgs$LWS = sanitizeWindowOpenArguments$LWS(args$LWS);
    return ReflectApply$LWS(originalWindowOpen$LWS, this, sanitizedArgs$LWS);
  }

  return [originalWindowOpen$LWS, open$LWS];
}

function distortionWindowPostMessage$LWS(record$LWS) {
  const {
    globalObject: {
      postMessage: originalPostMessage$LWS
    }
  } = record$LWS;

  function postMessage$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `transfer` is referenced
      // correctly within `message`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalPostMessage$LWS, this, args$LWS);
  }

  return [originalPostMessage$LWS, postMessage$LWS];
}

function distortionWindowSetInterval$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setInterval: originalSetInterval$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function setInterval$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const sourceText$LWS = transformUncompiledSourceText$LWS(toString$LWS(callback$LWS)); // Replace callback parameter.

        args$LWS[0] = () => {
          sandboxEvaluator$LWS(sourceText$LWS, UNCOMPILED_CONTEXT$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetInterval$LWS, this, args$LWS);
  }

  return [originalSetInterval$LWS, setInterval$LWS];
}

function distortionWindowSetTimeout$LWS(record$LWS) {
  const {
    UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
    globalObject: {
      setTimeout: originalSetTimeout$LWS
    },
    sandboxEvaluator: sandboxEvaluator$LWS
  } = record$LWS;

  function setTimeout$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: callback$LWS
      } = args$LWS;

      if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
        // Snapshot callback source to prevent shapeshifting.
        const sourceText$LWS = transformUncompiledSourceText$LWS(toString$LWS(callback$LWS)); // Replace callback parameter.

        args$LWS[0] = () => {
          sandboxEvaluator$LWS(sourceText$LWS, UNCOMPILED_CONTEXT$LWS);
        };
      }
    }

    return ReflectApply$LWS(originalSetTimeout$LWS, this, args$LWS);
  }

  return [originalSetTimeout$LWS, setTimeout$LWS];
}

function distortionWindowStructuredClone$LWS(record$LWS) {
  const {
    globalObject: {
      structuredClone: originalStructuredClone$LWS
    }
  } = record$LWS; // istanbul ignore if: currently unreachable via tests

  if (typeof originalStructuredClone$LWS !== 'function') {
    return null;
  }

  const structuredClone$LWS = function structuredClone$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      // Structured clone all arguments so that `options.transfer` is
      // referenced correctly within `value`.
      args$LWS = partialStructuredClone$LWS(args$LWS);
    }

    return ReflectApply$LWS(originalStructuredClone$LWS, this, args$LWS);
  };

  return [originalStructuredClone$LWS, structuredClone$LWS];
}

function distortionWorkerCtor$LWS(record$LWS) {
  const {
    globalObject: {
      Worker: originalWorkerCtor$LWS
    }
  } = record$LWS;

  function Worker$LWS(scriptURL$LWS) {
    throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
  }

  return [originalWorkerCtor$LWS, Worker$LWS];
}

function distortionWorkerProto$LWS(record$LWS) {
  const {
    globalObject: {
      Worker: {
        prototype: originalPrototype$LWS
      }
    }
  } = record$LWS;
  return [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
}

function distortionXMLHttpRequestOpen$LWS(record$LWS) {
  const {
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const {
    open: originalOpen$LWS
  } = XMLHttpRequest$LWS.prototype;

  function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;

    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toString$LWS(url$LWS));

      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }

      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }

    ReflectApply$LWS(originalOpen$LWS, this, args$LWS);
  }

  return [originalOpen$LWS, open$LWS];
}

function distortionXMLHttpRequestResponseGetter$LWS(record$LWS) {
  const {
    globalObject: {
      Document: Document$LWS,
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'response');

  function response$LWS() {
    const rawResponse$LWS = ReflectApply$LWS(originalResponseGetter$LWS, this, []);
    return rawResponse$LWS instanceof Document$LWS ? sanitizeDocument$LWS(rawResponse$LWS) :
    /* istanbul ignore next: needs default platform behavior test */
    rawResponse$LWS;
  }

  return [originalResponseGetter$LWS, response$LWS];
}

function distortionXMLHttpRequestResponseXMLGetter$LWS(record$LWS) {
  const {
    globalObject: {
      XMLHttpRequest: XMLHttpRequest$LWS
    }
  } = record$LWS;
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS(XMLHttpRequest$LWS.prototype, 'responseXML');

  function responseXML$LWS() {
    const rawResponseXML$LWS = ReflectApply$LWS(originalResponseXMLGetter$LWS, this, []);
    return sanitizeDocument$LWS(rawResponseXML$LWS);
  }

  return [originalResponseXMLGetter$LWS, responseXML$LWS];
}
/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/


const internalDistortionFactories$LWS = ObjectFreeze$LWS([// CSSStyleRule
distortionCSSStyleRuleStyleGetter$LWS, // Document
distortionDocumentDomainSetter$LWS, distortionDocumentExecCommand$LWS, distortionDocumentOpen$LWS, // DOMParser
distortionDOMParserParseFromString$LWS, // Element
distortionElementAttachShadow$LWS, distortionElementAttributesGetter$LWS, distortionElementInnerHTMLSetter$LWS, distortionElementOuterHTMLSetter$LWS, distortionElementInsertAdjacentHTML$LWS, distortionElementRemove$LWS, distortionElementReplaceChildren$LWS, distortionElementReplaceWith$LWS, // Event
distortionEventComposedPath$LWS, distortionEventPathGetter$LWS, // Function
distortionFunction$LWS, // History
distortionHistoryPushState$LWS, distortionHistoryReplaceState$LWS, // HTMLElement
distortionHTMLElementDatasetGetter$LWS, distortionHTMLElementInnerTextSetter$LWS, distortionHTMLElementOuterTextSetter$LWS, distortionHTMLElementStyleGetter$LWS, // HTMLIFrameElement
distortionHTMLIFrameElementSrcSetter$LWS, // HTMLLinkElement
distortionHTMLLinkElementRelSetter$LWS, distortionHTMLLinkElementRelListSetter$LWS, // HTMLObjectElement
distortionHTMLObjectElementDataSetter$LWS, // HTMLScriptElement
distortionHTMLScriptElementSrcGetter$LWS, // IDBObjectStore
distortionIDBObjectStoreAdd$LWS, distortionIDBObjectStorePut$LWS, // Navigator
distortionNavigatorSendBeacon$LWS, distortionNavigatorServiceWorkerGetter$LWS, // Node
distortionNodeRemoveChild$LWS, distortionNodeReplaceChild$LWS, // Notification
distortionNotificationCtor$LWS, // Range
distortionRangeCreateContextualFragment$LWS, distortionRangeDeleteContents$LWS, distortionRangeExtractContents$LWS, distortionRangeInsertNode$LWS, distortionRangeSelectNode$LWS, distortionRangeSelectNodeContents$LWS, distortionRangeSetEnd$LWS, distortionRangeSetEndAfter$LWS, distortionRangeSetEndBefore$LWS, distortionRangeSetStart$LWS, distortionRangeSetStartAfter$LWS, distortionRangeSetStartBefore$LWS, distortionRangeSurroundContents$LWS, // ServiceWorkerContainer
distortionServiceWorkerContainer$LWS, // ShadowRoot
distortionShadowRootInnerHTMLSetter$LWS, distortionShadowRootModeGetter$LWS, // SharedWorker
distortionSharedWorkerCtor$LWS, distortionSharedWorkerProto$LWS, // Storage
distortionStorageLength$LWS, distortionStorageGetItem$LWS, distortionStorageSetItem$LWS, distortionStorageKey$LWS, distortionStorageRemoveItem$LWS, distortionStorageClear$LWS, distortionStorage$LWS, // SVGAnimateElement
distortionSVGAnimateElementFromAttribute$LWS, distortionSVGAnimateElementToAttribute$LWS, distortionSVGAnimateElementValuesAttribute$LWS, // SVGElement
distortionSVGElementDatasetGetter$LWS, // SVGSetElement
distortionSVGSetElementToAttribute$LWS, // SVGUseElement
distortionSVGUseElementHrefAttribute$LWS, distortionSVGUseElementXlinkHrefAttribute$LWS, // TrustedTypePolicyFactory
distortionTrustedTypePolicyFactoryCreatePolicy$LWS, // URL
distortionURLCreateObjectURL$LWS, // Window
distortionWindowFetch$LWS, distortionWindowFramesGetter$LWS, distortionWindowGetComputedStyle$LWS, distortionWindowLengthGetter$LWS, distortionWindowOpen$LWS, distortionWindowPostMessage$LWS, distortionWindowStructuredClone$LWS, // Worker
distortionWorkerCtor$LWS, distortionWorkerProto$LWS, // XHR
distortionXMLHttpRequestOpen$LWS, distortionXMLHttpRequestResponseGetter$LWS, distortionXMLHttpRequestResponseXMLGetter$LWS]);
const internalKeyedDistortionFactories$LWS = ObjectFreeze$LWS([// Attr
distortionAttrValueSetter$LWS, // Aura
distortionAuraUtilGlobalEval$LWS, // CacheStorage
distortionCacheStorageDelete$LWS, distortionCacheStorageHas$LWS, distortionCacheStorageKeys$LWS, distortionCacheStorageMatch$LWS, distortionCacheStorageOpen$LWS, // CookieStore
distortionCookieStoreDelete$LWS, distortionCookieStoreGet$LWS, distortionCookieStoreGetAll$LWS, distortionCookieStoreOnChange$LWS, distortionCookieStoreSet$LWS, // Document
distortionDocumentCookieGetter$LWS, distortionDocumentCookieSetter$LWS, distortionDocumentReplaceChildren$LWS, // CustomElementRegistry
distortionCustomElementRegistryGet$LWS, // Element
distortionElementSetAttribute$LWS, distortionElementSetAttributeNode$LWS, distortionElementSetAttributeNodeNS$LWS, distortionElementSetAttributeNS$LWS, distortionElementToggleAttribute$LWS, // EventTarget
distortionEventTargetAddEventListener$LWS, // HTMLScriptElement,
distortionHTMLScriptElementSrcSetter$LWS, // NamedNodeMap
distortionNamedNodeMapSetNamedItem$LWS, distortionNamedNodeMapSetNamedItemNS$LWS, // Node
distortionNodeValueSetter$LWS, distortionNodeTextContentGetter$LWS, distortionNodeTextContentSetter$LWS, // Storage
distortionLocalStorage$LWS, distortionSessionStorage$LWS, // SVGAnimationElement
distortionSVGAnimateElementAttributeNameAttribute$LWS, // SVGScriptElement
distortionSVGScriptElementHrefAttribute$LWS, // SVGSetElement
distortionSVGSetElementAttributeNameAttribute$LWS, // Window
distortionWindowOnstorage$LWS, distortionWindowSetInterval$LWS, distortionWindowSetTimeout$LWS]);
const externalDistortionFactories$LWS = ObjectFreeze$LWS(ArrayConcat$LWS(internalDistortionFactories$LWS, [// Element
distortionElementAfter$LWS, distortionElementAppend$LWS, distortionElementBefore$LWS, distortionElementInsertAdjacentElement$LWS, distortionElementPrepend$LWS, distortionElementShadowRootGetter$LWS, // Node
// The distortionNodeAppendChild distortion is temporarily disabled until W-10409618 is resolved
// distortionNodeAppendChild,
distortionNodeInsertBefore$LWS]));
const externalKeyedDistortionFactories$LWS = internalKeyedDistortionFactories$LWS;
const evaluationDistortionFactories$LWS = ObjectFreeze$LWS([// eval
distortionEval$LWS]);
const opaqueDistortionFactories$LWS = ObjectFreeze$LWS([// Window
distortionWindowPostMessage$LWS]);
const DocumentBlockedProperties$LWS = ObjectFreeze$LWS(['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onsecuritypolicyviolation', 'onunhandledrejection', 'releaseCapture', 'releaseEvents', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln']);
const ElementBlockedProperties$LWS = ObjectFreeze$LWS(['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen']);
const HTMLElementBlockedAttributes$LWS = ObjectFreeze$LWS(['nonce']);
const HTMLElementBlockedProperties$LWS = ObjectFreeze$LWS(['nonce', 'onrejectionhandled', 'onunhandledrejection']);
const HTMLEmbedElementBlockedProperties$LWS = ObjectFreeze$LWS(['getSVGDocument']); // https://www.w3schools.com/tags/tag_iframe.asp

const HTMLIFrameElementBlockedAttributes$LWS = ObjectFreeze$LWS(['allowpaymentrequest', 'referrerpolicy', 'sandbox', 'srcdoc']);
const HTMLIFrameElementBlockedProperties$LWS = ObjectFreeze$LWS(['allowPaymentRequest', 'csp', 'featurePolicy', 'getSVGDocument', 'referrerPolicy', 'sandbox', 'srcdoc']);
const HTMLObjectElementBlockedProperties$LWS = ObjectFreeze$LWS(['getSVGDocument']);
const HTMLScriptElementBlockedAttributes$LWS = ObjectFreeze$LWS(['nonce']);
const HTMLScriptElementBlockedProperties$LWS = ObjectFreeze$LWS(['nonce']);
const SVGElementBlockedAttributes$LWS = ObjectFreeze$LWS(['nonce']);
const SVGElementBlockedProperties$LWS = ObjectFreeze$LWS(['nonce']);
const XSLTProcessorBlockedProperties$LWS = ObjectFreeze$LWS(['transformToDocument', 'transformToFragment']);
/*! version: 0.16.27 */

/*!
 * Copyright (C) 2021 salesforce.com, inc.
 */
/* eslint-disable class-methods-use-this, max-classes-per-file */

let ticketSequence$LWS = 0;

function getActivityId$LWS() {
  ticketSequence$LWS += 1;
  return DateNow$LWS() + ticketSequence$LWS;
} // Locker Instrumentation Activity class

/* eslint no-underscore-dangle: ['error',{allowAfterThis:true}] */


class LockerActivity$LWS {
  constructor(activityName$LWS, startCallback$LWS, stopCallback$LWS, captureTimestamps$LWS = false) {
    this._activityStart = 0;
    this._activityStop = 0;
    this._captureTimestamps = captureTimestamps$LWS;
    this._startCallback = startCallback$LWS;
    this._started = false;
    this._stopCallback = stopCallback$LWS;
    this._stopped = false;
    this.activityId = `${activityName$LWS}-${getActivityId$LWS()}`;
    this.activityName = activityName$LWS;
  }
  /*
   * starts an activity
   */


  start(data$LWS) {
    if (!this._started) {
      this._started = true;

      if (this._captureTimestamps) {
        this._activityStart = getTimestamp$LWS();
      }

      if (typeof this._startCallback === 'function') {
        this._startCallback(this, data$LWS);
      }
    }
  }
  /*
   * stops the current activity
   */


  stop(data$LWS) {
    if (!this._stopped) {
      this._stopped = true;

      if (this._captureTimestamps) {
        this._activityStop = getTimestamp$LWS();
      }

      if (typeof this._stopCallback === 'function') {
        this._stopCallback(this, data$LWS);
      }
    }
  }
  /*
   * stop the current activity with error state.
   */


  error(data$LWS) {
    // @TODO:
    // Aura's metrics service ($A.metricsService) is the current
    // instrumentation service used by Locker. The metrics service does not
    // have an `error` API for perf activities. But O11y provides this
    // feature. When Locker is able to integrate O11y, the following line
    // should be calling O11y's error API instead of `stop()`.
    this.stop(data$LWS);
  }

  get duration() {
    return this._activityStop > this._activityStart ? this._activityStop - this._activityStart : 0;
  }

} // Creates a new no-op Instrumentation instance.


class DefaultInstrumentation$LWS {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startActivity(activityName$LWS, _data$LWS) {
    return new LockerActivity$LWS(activityName$LWS, undefined, undefined);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  log(_data$LWS) {} // eslint-disable-next-line @typescript-eslint/no-unused-vars


  error(_data$LWS) {}

} // Export the default instrumentation instance with no-op operations.


const defaultInstrumentation$LWS = new DefaultInstrumentation$LWS();
/*! version: 0.16.27 */

const Ot=SymbolFor$LWS("@@lockerDebugMode");if(LOCKER_UNMINIFIED_FLAG$LWS){let t=!0;const O=100,_=5,E=100,x=E/2,A="display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;",B={style:"margin-left:11px; margin-bottom: 3px;"},F={style:"display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;"},M={style:"color: #9d288c; font-weight: bold"},j={style:"color: #b17ab0"},H={style:"color: #16239f"},k={style:"color: #236d25"},R={style:"color: #606367"},I={style:"color: #b82619"},formatValue$LWS=function(t){if(null==t)return ["span",R,`${t}`];if("boolean"==typeof t)return ["span",H,t];if("number"==typeof t)return NumberIsFinite$LWS(t)?["span",H,t]:["span",H,(t>=0?"":"-")+"Infinity"];if("string"==typeof t){let e=t;const{length:o}=e;if(o>E){const t=ReflectApply$LWS(StringProtoSlice$LWS,e,[0,x]),r=ReflectApply$LWS(StringProtoSlice$LWS,e,[o-x-1,o]);e=t+CHAR_ELLIPSIS$LWS+r;}return ["span",I,JSONStringify$LWS(e)]}return ArrayIsArray$LWS(t)?["span",{},`Array(${t.length})`]:isObject$LWS(t)?["span",{},`{${CHAR_ELLIPSIS$LWS}}`]:["span",I,StringCtor$LWS(t)]},formatHeader$LWS=function(t,o={}){const{t:r}=o,i=[];let b=0;r&&(i[b++]=["span",M,o.o],i[b++]=["span",{},": "]);const T=ReflectApply$LWS(ObjectProtoToString$LWS,t,[]);let P=ObjectKeys$LWS(t);if(T===TO_STRING_BRAND_SYMBOL$LWS)ReflectApply$LWS(ArrayProtoIncludes$LWS,P,["description"])||ReflectApply$LWS(ArrayProtoUnshift$LWS,P,["description"]);else if(T===TO_STRING_BRAND_STRING$LWS){const{length:e}=t;P=ReflectApply$LWS(ArrayProtoFilter$LWS,P,[t=>{const o="string"==typeof t?+t:-1;return o<0||o>=e||!NumberIsInteger$LWS(o)}]);}const{length:w}=P;if(ArrayIsArray$LWS(t)){i[b++]=["span",r?R:{},`(${t.length}) [`];for(let e=0,o=MathMin$LWS(w,O);e<o;e+=1){const o=t[P[e]];i[b++]=["span",{},e?", ":""],i[b++]=formatValue$LWS(o);}return w>O&&(i[b++]=["span",null,["span",{},`, ${CHAR_ELLIPSIS$LWS}`]]),i[b++]=["span",{},"]"],i}let m,E="{";switch(T){case TO_STRING_BRAND_BIG_INT$LWS:case TO_STRING_BRAND_BOOLEAN$LWS:case TO_STRING_BRAND_NUMBER$LWS:case TO_STRING_BRAND_STRING$LWS:case TO_STRING_BRAND_SYMBOL$LWS:{let e=H;T===TO_STRING_BRAND_BIG_INT$LWS?e=k:T===TO_STRING_BRAND_SYMBOL$LWS&&(e=I),E=`${ReflectApply$LWS(StringProtoSlice$LWS,T,[8,-1])} {`,m=["span",e,`${StringCtor$LWS(getNearMembraneSerializedValue$LWS(t))}`];break}}i[b++]=["span",{},E],m&&(i[b++]=m,w&&(i[b++]=["span",{},", "]));for(let e=0,o=MathMin$LWS(w,_);e<o;e+=1){const o=P[e],r=t[o];i[b++]=["span",{},e?", ":""],i[b++]=["span",R,o],i[b++]=["span",{},": "],i[b++]=formatValue$LWS(r);}return w>_&&(i[b++]=["span",null,["span",{},`, ${CHAR_ELLIPSIS$LWS}`]]),i[b++]=["span",{},"}"],i},formatBody$LWS=function(t){const o=ObjectKeys$LWS(t),r=ReflectOwnKeys$LWS(t);ArrayIsArray$LWS(t)||ReflectApply$LWS(ArrayProtoSort$LWS,r,[]);const i=[];let a=0;for(let e=0,{length:s}=r;e<s;e+=1){const s=r[e],l=t[s];if(isObject$LWS(l))i[a++]=["div",{},["object",{object:l,config:{o:StringCtor$LWS(s),t:!0}}]];else {let t=M;"symbol"!=typeof s&&ReflectApply$LWS(ArrayProtoIncludes$LWS,o,[s])||(t=j),i[a++]=["div",B,["span",t,StringCtor$LWS(s)],["span",{},": "],formatValue$LWS(l)];}}return i};let{devtoolsFormatters:C}=window;ArrayIsArray$LWS(C)||(C=[],ReflectDefineProperty$LWS(window,"devtoolsFormatters",{__proto__:null,configurable:!0,value:C,writable:!0})),C[C.length]={header(e,a={}){if(t&&(t=!1,ReflectDefineProperty$LWS(window,Ot,{__proto__:null,configurable:!0,value:!0,writable:!0})),!isNearMembrane$LWS(e))return null;const s=["div",{style:`${A}${a.t?"":"font-style: italic;"}`}];return ReflectApply$LWS(ArrayProtoPush$LWS,s,formatHeader$LWS(e,a)),["div",{},s]},hasBody:()=>!0,body(t){const e=["div",F];return ReflectApply$LWS(ArrayProtoPush$LWS,e,formatBody$LWS(t)),e}};}const _t=Array,Et=WeakMap,{setPrototypeOf:xt}=Reflect,{iterator:At,toStringTag:Bt,unscopables:Ft}=Symbol,{prototype:Mt}=_t,{at:jt,concat:Ht,copyWithin:kt,entries:Rt,every:It,fill:Ct,filter:Dt,find:Nt,findIndex:Gt,flat:Kt,flatMap:Ut,forEach:Vt,includes:zt,indexOf:Xt,join:qt,keys:Qt,lastIndexOf:Zt,map:Jt,pop:Yt,push:te,reduce:ee,reduceRight:oe,reverse:re,shift:ne,slice:ie,some:ae,sort:se,splice:le,toLocaleString:ce,toString:ue,unshift:fe,values:de,[At]:ye}=Mt,pe=Object.freeze(Object.assign({__proto__:null},Mt[Ft])),{prototype:Se}=Et,{delete:he,get:Le,has:ge,set:$e,[Bt]:ve}=Se;function toSafeWeakMap$LWS(t){return xt(t,null),t.delete=he,t.get=Le,t.has=ge,t.set=$e,t[Bt]=ve,xt(t,Se),t}const We=toSafeWeakMap$LWS(new WeakMap);function createMembraneMarshall$LWS(t){var e,o,r;const n=Array,i=ArrayBuffer,a=Error,s=Number,l=Object,c=Proxy,u=Reflect,f=RegExp,d=String,y=Symbol,p=TypeError,S=WeakMap,{for:h,toStringTag:L}=y,{apply:g,construct:$,defineProperty:v,deleteProperty:W,get:b,getOwnPropertyDescriptor:T,getPrototypeOf:P,has:w,isExtensible:m,ownKeys:O,preventExtensions:_,set:E,setPrototypeOf:x}=u,{assign:A,defineProperties:B,freeze:F,getOwnPropertyDescriptor:M,getOwnPropertyDescriptors:j,isFrozen:H,isSealed:k,keys:R,prototype:I,seal:C}=l,{hasOwnProperty:D,propertyIsEnumerable:N,toString:G}=I,{hasOwn:K}=l,{__defineGetter__:U,__defineSetter__:V,__lookupGetter__:z,__lookupSetter__:X}=I,q="function"==typeof K?K:(t,e)=>g(D,t,[e]),Q="object"!=typeof t||null===t,Z=Q?void 0:h("@@lockerDebugMode"),J=Q?void 0:h("@@lockerLiveValue"),Y=Q?void 0:h("@@lockerNearMembraneSerializedValue"),tt=Q?void 0:h("@@lockerNearMembrane"),et=h("@@lockerNearMembraneUndefinedValue"),LOCKER_UNMINIFIED_FLAG$LWS=`${()=>
/* $LWS */
1}`.includes("*"),ot=LOCKER_UNMINIFIED_FLAG$LWS&&!Q,rt=Q?/\w*$/:void 0;let nt,it;const at="function"==typeof BigInt,{isArray:st}=n,{includes:lt,indexOf:ct,slice:ut}=n.prototype,{isView:ft}=i,dt=Q?void 0:g(z,i.prototype,["byteLength"]),yt=at?BigInt.prototype.valueOf:void 0,{valueOf:pt}=Boolean.prototype,{toString:St}=a.prototype,{bind:ht,toString:Lt}=Function.prototype,{stringify:gt}=JSON,{isInteger:$t}=s,{valueOf:vt}=s.prototype,{revocable:Wt}=c,{prototype:bt}=f,{exec:Tt,test:Pt,toString:wt}=bt,mt=Q?null!=(e=g(z,bt,["flags"]))?e:function(){const t=g(wt,this,[]);return g(Tt,rt,[t])[0]}:void 0,Ot=g(z,bt,["source"]),{replace:_t,slice:Et,valueOf:xt}=d.prototype,{toString:At,valueOf:Bt}=y.prototype,Ft=g(z,Uint8Array.prototype.__proto__,["length"]),{prototype:Mt}=S,{delete:jt,has:Ht,set:kt,[L]:Rt}=Mt,It=Q||"object"!=typeof console||null===console?void 0:console,Ct=null==It?void 0:It.info,Dt=Q?eval:void 0,Nt=null!=(o=null!=(r=null!=t?t:"undefined"!=typeof globalThis?globalThis:void 0)?r:"undefined"!=typeof self?self:void 0)?o:(v(I,"globalThis",{__proto__:null,configurable:!0,get(){return W(I,"globalThis"),null!=this?this:self}}),globalThis);let Gt=!1,Kt=!1;function alwaysFalse$LWS(){return !1}const Ut=LOCKER_UNMINIFIED_FLAG$LWS?()=>{if(Gt)return;Gt=!0;const t=(()=>{try{var t;a.prepareStackTrace=(t,e)=>e;const e=(new a).stack;return W(a,"prepareStackTrace"),st(e)&&e.length>0?null==(t=e[0])?void 0:t.constructor:void 0}catch(t){}})();if("function"!=typeof t)return;const{getEvalOrigin:e,getFunctionName:o,toString:r}=t.prototype,n=new f(`${g(_t,"$LWS",[/[\\^$.*+?()[\]{}|]/g,"\\$&"])}(?=\\.|$)`);try{a.prepareStackTrace=function(t,i){return function(t,i){let a="";try{a=g(St,t,[]);}catch(t){a="<error>";}let s=!1;for(let t=0,{length:l}=i;t<l;t+=1){const l=i[t],c=g(o,l,[]);let u=!1;if("string"==typeof c&&"eval"!==c&&g(Pt,n,[c])&&(u=!0),!u){const t=g(e,l,[]);"string"==typeof t&&g(Pt,n,[t])&&(u=!0);}if(u)s||(s=!0,a+="\n    at LWS");else {s=!1;try{a+=`\n    at ${g(r,l,[])}`;}catch(t){}}}return a}(t,i)};}catch(t){}try{const{stackTraceLimit:t}=a;("number"!=typeof t||t<20)&&(a.stackTraceLimit=20);}catch(t){}}:noop$LWS;function noop$LWS(){}const Vt=Q?t=>g(yt,t,[]):noop$LWS,zt=Q?t=>g(pt,t,[]):noop$LWS,Xt=Q?t=>g(vt,t,[]):noop$LWS,qt=Q?t=>{if(t!==bt){const e=g(Ot,t,[]);return gt({__proto__:null,flags:g(mt,t,[]),source:e})}}:noop$LWS,Qt=Q?t=>g(xt,t,[]):noop$LWS,Zt=Q?t=>g(Bt,t,[]):noop$LWS,Jt=Q?t=>{switch(g(G,t,[])){case"[object Boolean]":return zt(t);case"[object Number]":return Xt(t);case"[object RegExp]":return qt(t);case"[object String]":return Qt(t);case"[object Object]":try{return Zt(t)}catch(t){}if(at)try{return Vt(t)}catch(t){}default:return}}:noop$LWS,Yt=Q?t=>{try{return Zt(t)}catch(t){}if(at)try{return Vt(t)}catch(t){}try{return zt(t)}catch(t){}try{return Xt(t)}catch(t){}try{return qt(t)}catch(t){}try{return Qt(t)}catch(t){}}:noop$LWS;function toSafeWeakMap$LWS(t){return x(t,null),t.delete=jt,t.has=Ht,t.set=kt,t[L]=Rt,x(t,Mt),t}return function(t,e,o){Q&&(o=void 0);const{distortionCallback:r,instrumentation:i}=A({__proto__:null},o),a=!Q&&"object"==typeof i&&null!==i,s={__proto__:null,0:void 0,1:void 0,2:void 0,3:void 0,4:void 0,n:void 0},f={__proto__:null,0:void 0,1:void 0,2:void 0,3:void 0,4:void 0,n:void 0},y=toSafeWeakMap$LWS(new S),h=toSafeWeakMap$LWS(new S),D=a?i.startActivity:void 0;let K,rt,at,yt,pt,St,gt,vt,Tt,Pt,wt,mt,_t,xt,Bt,Mt,jt,Ht,kt,Rt,Gt,Vt,zt,Xt,qt,Qt,Zt,te,ee,oe=!1,re=0;const ne=Q?(t,e,o)=>{o[e]=!1;const r=getTransferablePointer$LWS(t);let n;try{vt(r,e,(t,e,o,r,i,a,s)=>{n=createDescriptorFromMeta$LWS(e,o,r,i,a,s);});}catch(t){var i;const e=null!=(i=ee)?i:t;throw ee=void 0,e}n?v(t,e,n):W(t,e);}:noop$LWS;let ie=ot?()=>{try{q(Nt,Z)&&(ie=()=>!0,Ut(),Gt());}catch(t){ie=alwaysFalse$LWS;}return !1}:alwaysFalse$LWS;function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(t,e){let o,r,n;a&&(o=D("copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget"));try{r=Qt(t,(...t)=>{const o={};for(let e=0,{length:r}=t;e<r;e+=7){o[t[e]]=createDescriptorFromMeta$LWS(t[e+1],t[e+2],t[e+3],t[e+4],t[e+5],t[e+6]);}B(e,o);});}catch(t){var i;const e=null!=(i=ee)?i:t;throw ee=void 0,a&&o.error(e),e}"function"==typeof r?(r(),n=ee,ee=void 0):n=null,x(e,n),a&&o.stop();}function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}()`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(0!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForOneOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}(1)`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(1!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{const{0:t}=c;S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}(2)`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(2!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{const{0:t,1:e}=c;S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}(3)`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(3!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{const{0:t,1:e,2:o}=c;S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):"undefined"==typeof o?void 0:o);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForFourOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}(4)`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(4!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{const{0:t,1:e,2:o,3:r}=c;S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):"undefined"==typeof o?void 0:o,"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):"undefined"==typeof r?void 0:r);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(t){const e=1&t,o=`Reflect.${e?"apply":"construct"}(5)`,r=e?s:f,n=e?at:yt;return function(i,s,l){re=t;const c=e?l:s,{length:u}=c;var f;if(5!==u)return this[null!=(f=r[u])?f:r.n](i,s,l);let d;a&&(d=D(o));const{i:y}=this,p=e?s:l;let S,h;try{const{0:t,1:e,2:o,3:r,4:i}=c;S=n(y,"object"==typeof p&&null!==p||"function"==typeof p?getTransferablePointer$LWS(p):"undefined"==typeof p?void 0:p,"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,"object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e,"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):"undefined"==typeof o?void 0:o,"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):"undefined"==typeof r?void 0:r,"object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):"undefined"==typeof i?void 0:i);}catch(t){var L;const e=null!=(L=ee)?L:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof S?(S(),h=ee,ee=void 0):h=S,a&&d.stop(),h}}function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(t){const e=1&t,o=e?"apply":"construct",r=e?at:yt;return function(i,s,l){re=t;const{i:c}=this,u=e?l:s,{length:f}=u;let d;a&&(d=D(`Reflect.${o}(${f})`));const y=e?s:l;let p=2;const S=new n(f+p);let h,L;S[0]=c;try{S[1]="object"==typeof y&&null!==y||"function"==typeof y?getTransferablePointer$LWS(y):"undefined"==typeof y?void 0:y;for(let t=0;t<f;t+=1){const e=u[t];S[p++]="object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):"undefined"==typeof e?void 0:e;}h=g(r,void 0,S);}catch(t){var $;const e=null!=($=ee)?$:t;throw ee=void 0,a&&d.error(e),e}return "function"==typeof h?(h(),L=ee,ee=void 0):L=h,a&&d.stop(),L}}function createDescriptorFromMeta$LWS(t,e,o,r,n,i){const a={__proto__:null};return t!==et&&(a.configurable=t),e!==et&&(a.enumerable=e),o!==et&&(a.writable=o),n!==et&&("function"==typeof n?(n(),a.get=ee,ee=void 0):a.get=void 0),i!==et&&("function"==typeof i?(i(),a.set=ee,ee=void 0):a.set=void 0),r!==et&&("function"==typeof r?(r(),a.value=ee,ee=void 0):a.value=r),a}function createPointer$LWS(t){return ()=>{ee=t;}}const ae=Q?t=>{let e=y.get(t);if(void 0===e){const o=jt(getTransferablePointer$LWS(t));"function"==typeof o&&(o(),e=ee,ee=void 0,e&&y.set(t,e));}return e}:noop$LWS;function getTransferablePointer$LWS(t,e=rt){let o,n=h.get(t);if(n)return n;if(r){if(o=r(t),o!==t&&typeof o!=typeof t)throw new p(`Invalid distortion ${function(t){if("string"==typeof t)return t;try{if("object"==typeof t&&null!==t){const e=g(G,t,[]);return "[object Symbol]"===e?g(At,t,[]):e}return "function"==typeof t?g(Lt,t,[]):d(t)}catch(t){}return "[Object Unknown]"}(t)}.`)}else o=t;let i=!0,a=0,s=0,l=16;if("function"==typeof o){i=!1,a=0,l=4;try{"prototype"in o||(l|=8);const e=T(t,"length");if(e){x(e,null);const{value:t}=e;"number"==typeof t&&(a=t);}void 0;}catch(t){i=!0;}}else if(ft(o)){i=!1,l=2;try{s=g(Ft,o,[]),l|=32;}catch(t){i=!0;}}if(i)try{st(o)&&(l=1);}catch(t){l=64;}return n=e(createPointer$LWS(o),l,a,"",s),h.set(t,n),n}const se=Q?t=>{if(Kt)return;Kt=!0;const e=st(t)&&t.length>0,o=e?{__proto__:null}:void 0,r=e?(e,o)=>g(lt,t,[o])?{configurable:!1,enumerable:g(N,e,[o]),get:n(o),set:void 0}:T(e,o):void 0,n=e?t=>{let e=o[t];return void 0===e&&(e=g(ht,s,[]),o[t]=e),e}:void 0,i=e?(e,o)=>g(lt,t,[o])?n(o):g(z,e,[o]):void 0,a=e?(e,o)=>g(lt,t,[o])?void 0:g(X,e,[o]):void 0,s=e?()=>Nt:void 0,wrapDefineAccessOrProperty$LWS=t=>{const{length:e}=t,o=2===e;return new c(t,{apply(r,n,i){if(i.length>=e){const t=o?n:i[0];if("object"==typeof t&&null!==t||"function"==typeof t){const e=o?i[0]:i[1],r=ae(t);null!=r&&r[e]&&t[e];}}return g(t,n,i)}})},wrapLookupAccessor$LWS=(t,o)=>new c(t,{apply(r,n,i){if(i.length&&("object"==typeof n&&null!==n||"function"==typeof n)){const{0:t}=i,r=ae(n);if(null!=r&&r[t]&&n[t],e&&n===Nt)return o(n,t)}return g(t,n,i)}}),wrapGetOwnPropertyDescriptor$LWS=t=>new c(t,{apply(o,n,i){if(i.length>1){const{0:t,1:o}=i;if("object"==typeof t&&null!==t||"function"==typeof t){const n=ae(t);if(null!=n&&n[o]&&t[o],e&&t===Nt)return r(t,o)}}return g(t,n,i)}});try{u.defineProperty=wrapDefineAccessOrProperty$LWS(v);}catch(t){}try{u.getOwnPropertyDescriptor=wrapGetOwnPropertyDescriptor$LWS(T);}catch(t){}try{l.getOwnPropertyDescriptor=wrapGetOwnPropertyDescriptor$LWS(M);}catch(t){}try{l.getOwnPropertyDescriptors=new c(f=j,{apply(t,o,n){const i=n.length?n[0]:void 0;if(("object"!=typeof i||null===i)&&"function"!=typeof i)return g(f,o,n);const a=ae(i),s=i===Nt&&e,l=s?{}:g(f,o,n);if(!s&&void 0===a)return l;const c=O(s?i:l);for(let t=0,{length:e}=c;t<e;t+=1){const e=c[t],o=!(null==a||!a[e]);if(o&&i[e],o||s){const t=s?r(i,e):T(i,e);t?l[e]=t:s||W(l,e);}}return l}});}catch(t){}var f;try{I.__defineGetter__=wrapDefineAccessOrProperty$LWS(U);}catch(t){}try{I.__defineSetter__=wrapDefineAccessOrProperty$LWS(V);}catch(t){}try{I.__lookupGetter__=wrapLookupAccessor$LWS(z,i);}catch(t){}try{I.__lookupSetter__=wrapLookupAccessor$LWS(X,a);}catch(t){}}:noop$LWS;function lookupForeignDescriptor$LWS(t,e,o){let r,n,i;a&&(r=D("lookupForeignDescriptor"));try{n=te(t,o,(t,r,n,a,s,l,c)=>{i={__proto__:null,l:!0},r!==et&&(i.configurable=r),n!==et&&(i.enumerable=n),a!==et&&(i.writable=a),l!==et&&("function"==typeof l?(l(),i.get=ee,ee=void 0):i.get=void 0),c!==et&&("function"==typeof c?(c(),i.set=ee,ee=void 0):i.set=void 0),s!==et&&("function"==typeof s?(s(),i.value=ee,ee=void 0):i.value=s),!1===r&&v(e,o,i);});}catch(t){var s;const e=null!=(s=ee)?s:t;throw ee=void 0,a&&r.error(e),e}if(void 0===i){let t;for("function"==typeof n?(n(),t=ee,ee=void 0):t=null;t;){if(i=T(t,o),i){x(i,null);break}t=P(t);}if(i){var l;const{get:t,set:e,value:o}=i,r=null!=(l=null!=t?t:e)?l:o;i.l=("object"==typeof r&&null!==r||"function"==typeof r)&&void 0!==h.get(r);}}return a&&r.stop(),i}function pushErrorAcrossBoundary$LWS(t){if(ot&&ie(),"object"==typeof t&&null!==t||"function"==typeof t){getTransferablePointer$LWS(t,K)();}return t}function pushTarget$LWS(t,e,o,r,n){const{proxy:i}=new BoundaryProxyHandler$LWS(t,e,o,r,n);return h.set(i,t),createPointer$LWS(i)}const le=Q?(t,e)=>{y.set(t,e),qt(getTransferablePointer$LWS(t),getTransferablePointer$LWS(e));}:noop$LWS;class BoundaryProxyHandler$LWS{constructor(t,e,o,r,n){let i;const a=1&e,l=4&e;i=l?8&e?()=>{}:function(){}:a?[]:{};const{proxy:c,revoke:u}=Wt(i,this);var d,y;(this.i=t,this.u=e,this.p=n,this.S=(t,e,o,r,n,i,a)=>{v(this.h,t,createDescriptorFromMeta$LWS(e,o,r,n,i,a));},this.proxy=c,this.revoke=u,this.serializedValue=void 0,this.h=i,this.L="Object",l)&&(this.apply=this[null!=(d=s[o])?d:s.n],this.construct=this[null!=(y=f[o])?y:f.n]);if(this.defineProperty=BoundaryProxyHandler$LWS.g,this.deleteProperty=BoundaryProxyHandler$LWS.$,this.isExtensible=BoundaryProxyHandler$LWS.v,this.getOwnPropertyDescriptor=BoundaryProxyHandler$LWS.W,this.getPrototypeOf=BoundaryProxyHandler$LWS.T,this.get=32&e?BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray:BoundaryProxyHandler$LWS.P,this.has=BoundaryProxyHandler$LWS.m,this.ownKeys=BoundaryProxyHandler$LWS.O,this.preventExtensions=BoundaryProxyHandler$LWS._,this.setPrototypeOf=BoundaryProxyHandler$LWS.A,this.set=BoundaryProxyHandler$LWS.B,64&e)F(this),this.revoke();else if(Q)(a||2&e)&&this.F();else {if(16&e){let t=et;const{serializedValue:e}=this;void 0===nt&&({0:nt}=R({serializedValue:e})),g(U,this,[nt,()=>(t===et&&(t=Xt(this.i)),t)]);}F(this);}}F(){this.deleteProperty=BoundaryProxyHandler$LWS.M,this.defineProperty=BoundaryProxyHandler$LWS.j,this.preventExtensions=BoundaryProxyHandler$LWS.H,this.set=BoundaryProxyHandler$LWS.k,this.setPrototypeOf=BoundaryProxyHandler$LWS.R,F(this);}I(){this.defineProperty=BoundaryProxyHandler$LWS.C,this.deleteProperty=BoundaryProxyHandler$LWS.D,this.get=BoundaryProxyHandler$LWS.N,this.getOwnPropertyDescriptor=BoundaryProxyHandler$LWS.G,this.getPrototypeOf=BoundaryProxyHandler$LWS.K,this.has=BoundaryProxyHandler$LWS.U,this.isExtensible=BoundaryProxyHandler$LWS.V,this.ownKeys=BoundaryProxyHandler$LWS.X,this.preventExtensions=BoundaryProxyHandler$LWS.q,this.set=BoundaryProxyHandler$LWS.Z,this.setPrototypeOf=BoundaryProxyHandler$LWS.J;const{i:t,u:e,h:o}=this,r=Ht(t);if(8&r)return F(this),this.revoke(),void 0;try{copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(t,o);}catch(e){if(zt(t))return F(this),this.revoke(),void 0}if(16&e&&!(L in o)){let e="Object";try{e=kt(t);}catch(t){}this.L=e;}4&r?F(o):(2&r?C(o):1&r&&_(o),LOCKER_UNMINIFIED_FLAG$LWS&&Mt("Mutations on the membrane of an object originating outside of the sandbox will not be reflected on the object itself:",t)),F(this);}static j(t,e,o){let r;re=4,a&&(r=D("Reflect.defineProperty"));const{i:n,S:i}=this,s=o;x(s,null);const{get:l,set:c,value:u}=s,f="value"in s?"object"==typeof u&&null!==u||"function"==typeof u?getTransferablePointer$LWS(u):"undefined"==typeof u?void 0:u:et,d="get"in s?"function"==typeof l?getTransferablePointer$LWS(l):l:et,y="set"in s?"function"==typeof c?getTransferablePointer$LWS(c):c:et;let p=!1;try{p=pt(n,e,"configurable"in s?!!s.configurable:et,"enumerable"in s?!!s.enumerable:et,"writable"in s?!!s.writable:et,f,d,y,i);}catch(t){var S;const e=null!=(S=ee)?S:t;throw ee=void 0,a&&r.error(e),e}return a&&r.stop(),p}static M(t,e){let o;re=8,a&&(o=D("Reflect.deleteProperty"));let r=!1;try{r=St(this.i,e);}catch(t){var n;const e=null!=(n=ee)?n:t;throw ee=void 0,a&&o.error(e),e}return a&&o.stop(),r}static Y(t){let e,o,r;re=64,a&&(e=D("Reflect.getPrototypeOf"));try{o=Tt(this.i);}catch(t){var n;const o=null!=(n=ee)?n:t;throw ee=void 0,a&&e.error(o),o}return "function"==typeof o?(o(),r=ee,ee=void 0):r=null,a&&e.stop(),r}static tt(t){let e;re=256,a&&(e=D("Reflect.isExtensible"));const{h:o}=this;let r=!1;if(m(o)){const{i:t}=this;try{r=wt(t);}catch(t){var n;const o=null!=(n=ee)?n:t;throw ee=void 0,a&&e.error(o),o}r||(copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(t,o),_(o));}return a&&e.stop(),r}static et(t){let e,o;re=512,a&&(e=D("Reflect.ownKeys"));try{mt(this.i,(...t)=>{o=t;});}catch(t){var r;const o=null!=(r=ee)?r:t;throw ee=void 0,a&&e.error(o),o}return a&&e.stop(),o||[]}static ot(t,e){let o;re=32,a&&(o=D("Reflect.getOwnPropertyDescriptor"));const{i:r,h:n}=this;let i;try{vt(r,e,(t,o,r,a,s,l,c)=>{i=createDescriptorFromMeta$LWS(o,r,a,s,l,c),!1===i.configurable&&v(n,e,i);});}catch(t){var s;const e=null!=(s=ee)?s:t;throw ee=void 0,a&&o.error(e),e}return a&&o.stop(),i}static H(t){let e;re=1024,a&&(e=D("Reflect.preventExtensions"));const{i:o,h:r}=this;let n=!0;if(m(r)){let t=0;try{t=_t(o);}catch(t){var i;const o=null!=(i=ee)?i:t;throw ee=void 0,a&&e.error(o),o}1&t||(copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(o,r),_(r)),n=!(2&t);}return a&&e.stop(),n}static R(t,e){let o;re=4096,a&&(o=D("Reflect.setPrototypeOf"));const r=e?getTransferablePointer$LWS(e):e;let n=!1;try{n=Bt(this.i,r);}catch(t){var i;const e=null!=(i=ee)?i:t;throw ee=void 0,a&&o.error(e),e}return a&&o.stop(),n}static k(t,e,o,r){re=2048;const{i:n,proxy:i,h:s}=this;"undefined"==typeof o&&(o=void 0),"undefined"==typeof r&&(r=i);const l=i===r;let c;a&&(c=D(l?"Reflect.set":"passthruForeignTraversedSet"));let u=!1;try{u=l?xt(n,e,"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o,et):function(t,e,o,r,n){const i=lookupForeignDescriptor$LWS(t,e,o);if(i){if("get"in i||"set"in i){const{set:t}=i;return !!t&&(i.l?at(getTransferablePointer$LWS(t),"object"==typeof n&&null!==n||"function"==typeof n?getTransferablePointer$LWS(n):"undefined"==typeof n?void 0:n,"object"==typeof r&&null!==r||"function"==typeof r?getTransferablePointer$LWS(r):"undefined"==typeof r?void 0:r):g(t,n,[r]),!0)}if(!1===i.writable)return !1}if(("object"!=typeof n||null===n)&&"function"!=typeof n)return !1;const a=T(n,o);return a?(x(a,null),!("get"in a)&&!("set"in a)&&!1!==a.writable&&(v(n,o,{__proto__:null,value:r}),!0)):v(n,o,{__proto__:null,configurable:!0,enumerable:!0,value:r,writable:!0})}(n,s,e,o,r);}catch(t){var f;const e=null!=(f=ee)?f:t;throw ee=void 0,a&&c.error(e),e}return a&&c.stop(),u}}BoundaryProxyHandler$LWS.rt=Q?function(t,e,o){let r;a&&(r=D("hybridGetTrap"));const{i:n,u:i,proxy:s,h:l}=this,c=lookupForeignDescriptor$LWS(n,l,e);let u;if(c){const{get:t,value:e}=c;if(t)if(c.l){const e=getTransferablePointer$LWS(t),i=s===o?n:"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o;let l;try{l=at(e,i);}catch(t){var f;const e=null!=(f=ee)?f:t;throw ee=void 0,a&&r.error(e),e}"function"==typeof l?(l(),u=ee,ee=void 0):u=l;}else u=g(t,o,[]);else u=e;}else if(e===L&&16&i){let t;try{t=kt(n);}catch(t){var d;const e=null!=(d=ee)?d:t;throw ee=void 0,a&&r.error(e),e}"Object"!==t&&(u=t);}return a&&r.stop(),u}:noop$LWS,BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray=Q?function(t,e,o){let r;a&&(r=D("hybridGetTrapForTypedArray"));const{i:n,p:i,proxy:s,h:l}=this,c="string"==typeof e?+e:-1;let u;if(c>-1&&c<i&&$t(c))try{u=Rt(n,e);}catch(t){var f;const e=null!=(f=ee)?f:t;throw ee=void 0,a&&r.error(e),e}else {const t=lookupForeignDescriptor$LWS(n,l,e);if(t){const{get:e,value:i}=t;if(e)if(t.l){const t=getTransferablePointer$LWS(e),i=s===o?n:"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o;let l;try{l=at(t,i);}catch(t){var d;const e=null!=(d=ee)?d:t;throw ee=void 0,a&&r.error(e),e}"function"==typeof l?(l(),u=ee,ee=void 0):u=l;}else u=g(e,o,[]);else u=i;}}return a&&r.stop(),u}:noop$LWS,BoundaryProxyHandler$LWS.nt=Q?function(t,e){let o,r;a&&(o=D("hybridHasTrap"));try{r=Zt(this.i,e);}catch(t){var n;const e=null!=(n=ee)?n:t;throw ee=void 0,a&&o.error(e),e}let i=!1;if(!0===r)i=!0;else {let t;for("function"==typeof r?(r(),t=ee,ee=void 0):t=null;t;){if(q(t,e)){i=!0;break}t=P(t);}}return a&&o.stop(),i}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.it=Q?noop$LWS:function(t,e,o){if(oe&&(oe=128===re),re=16,oe){if(e===tt)return !0;if(e===Y)return this.serializedValue}let r;a&&(r=D("Reflect.get"));const{i:n,u:i,proxy:s}=this;"undefined"==typeof o&&(o=s);const l=s===o?et:"object"==typeof o&&null!==o||"function"==typeof o?getTransferablePointer$LWS(o):o;let c,u;try{c=gt(n,i,e,l);}catch(t){var f;const e=null!=(f=ee)?f:t;throw ee=void 0,a&&r.error(e),e}return "function"==typeof c?(c(),u=ee,ee=void 0):u=c,a&&r.stop(),u},BoundaryProxyHandler$LWS.st=Q?alwaysFalse$LWS:function(t,e){let o,r;re=128,a&&(o=D("Reflect.has"));try{r=Pt(this.i,e);}catch(t){var n;const e=null!=(n=ee)?n:t;throw ee=void 0,a&&o.error(e),e}return oe=!r&&(e===tt||e===Y),a&&o.stop(),r},BoundaryProxyHandler$LWS.lt=Q?function(t,e,o){return Vt(this.i)?this.F():this.I(),this.defineProperty(t,e,o)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.ct=Q?function(t,e){return Vt(this.i)?this.F():this.I(),this.deleteProperty(t,e)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.ut=Q?function(t){return Vt(this.i)?this.F():this.I(),this.preventExtensions(t)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.ft=Q?function(t,e){return Vt(this.i)?this.F():this.I(),this.setPrototypeOf(t,e)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.dt=Q?function(t,e,o,r){return Vt(this.i)?this.F():this.I(),this.set(t,e,o,r)}:alwaysFalse$LWS,BoundaryProxyHandler$LWS.C=Q?v:alwaysFalse$LWS,BoundaryProxyHandler$LWS.D=Q?W:alwaysFalse$LWS,BoundaryProxyHandler$LWS.G=Q?T:noop$LWS,BoundaryProxyHandler$LWS.K=Q?P:()=>null,BoundaryProxyHandler$LWS.N=Q?function(t,e,o){const{u:r,L:n}=this,i=b(t,e,o);return void 0===i&&e===L&&16&r&&"Object"!==n&&!(e in t)?n:i}:noop$LWS,BoundaryProxyHandler$LWS.U=Q?w:alwaysFalse$LWS,BoundaryProxyHandler$LWS.V=Q?m:alwaysFalse$LWS,BoundaryProxyHandler$LWS.X=Q?O:()=>[],BoundaryProxyHandler$LWS.q=Q?_:alwaysFalse$LWS,BoundaryProxyHandler$LWS.J=Q?x:alwaysFalse$LWS,BoundaryProxyHandler$LWS.Z=Q?E:alwaysFalse$LWS,BoundaryProxyHandler$LWS.g=Q?BoundaryProxyHandler$LWS.lt:BoundaryProxyHandler$LWS.j,BoundaryProxyHandler$LWS.$=Q?BoundaryProxyHandler$LWS.ct:BoundaryProxyHandler$LWS.M,BoundaryProxyHandler$LWS.W=BoundaryProxyHandler$LWS.ot,BoundaryProxyHandler$LWS.T=BoundaryProxyHandler$LWS.Y,BoundaryProxyHandler$LWS.P=Q?BoundaryProxyHandler$LWS.rt:BoundaryProxyHandler$LWS.it,BoundaryProxyHandler$LWS.m=Q?BoundaryProxyHandler$LWS.nt:BoundaryProxyHandler$LWS.st,BoundaryProxyHandler$LWS.v=BoundaryProxyHandler$LWS.tt,BoundaryProxyHandler$LWS.O=BoundaryProxyHandler$LWS.et,BoundaryProxyHandler$LWS._=Q?BoundaryProxyHandler$LWS.ut:BoundaryProxyHandler$LWS.H,BoundaryProxyHandler$LWS.B=Q?BoundaryProxyHandler$LWS.dt:BoundaryProxyHandler$LWS.k,BoundaryProxyHandler$LWS.A=Q?BoundaryProxyHandler$LWS.ft:BoundaryProxyHandler$LWS.R,e(createPointer$LWS(Nt),Q?noop$LWS:()=>{const t=ee;return ee=void 0,t},t=>"object"==typeof t&&null!==t||"function"==typeof t?getTransferablePointer$LWS(t):"undefined"==typeof t?void 0:t,(t,e)=>{t();const o=ee;ee=void 0;const r=null==o?void 0:o[e];return createPointer$LWS("undefined"==typeof r?void 0:r)},Q?t=>{let e;try{e=Dt(t);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "object"==typeof e&&null!==e||"function"==typeof e?getTransferablePointer$LWS(e):e}:noop$LWS,(t,e)=>{t();const o=ee;ee=void 0,("object"==typeof o&&null!==o||"function"==typeof o)&&h.set(o,e);},ot?(t,e,o,r,n)=>{const i=pushTarget$LWS(t,e,o,r,n);return ()=>(ie(),i())}:pushTarget$LWS,pushTarget$LWS,(t,e,...o)=>{t();const r=ee;let n,i;ee=void 0,"function"==typeof e&&(e(),n=ee,ee=void 0);for(let t=0,{length:e}=o;t<e;t+=1){const e=o[t];"function"==typeof e&&(e(),o[t]=ee,ee=void 0);}try{i=g(r,n,o);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):"undefined"==typeof i?void 0:i},(t,e,...o)=>{t();const r=ee;let n,i;ee=void 0,"function"==typeof e&&(e(),n=ee,ee=void 0);for(let t=0,{length:e}=o;t<e;t+=1){const e=o[t];"function"==typeof e&&(e(),o[t]=ee,ee=void 0);}try{i=$(r,o,n);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):"undefined"==typeof i?void 0:i},(t,e,o,r,n,i,a,s,l)=>{t();const c=ee;ee=void 0;const u=createDescriptorFromMeta$LWS(o,r,n,i,a,s);let f=!1;try{f=v(c,e,u);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}if(f&&!1===o){let t;try{t=T(c,e);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}if(t&&(x(t,null),!1===t.configurable)){const{get:o,set:r,value:n}=t;l(e,!1,"enumerable"in t?t.enumerable:et,"writable"in t?t.writable:et,"value"in t?"object"==typeof n&&null!==n||"function"==typeof n?getTransferablePointer$LWS(n):n:et,"get"in t?"function"==typeof o?getTransferablePointer$LWS(o):o:et,"set"in t?"function"==typeof r?getTransferablePointer$LWS(r):r:et);}}return f},(t,e)=>{t();const o=ee;ee=void 0;try{return W(o,e)}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},(t,e,o,r)=>{t();const n=ee;let i,a;ee=void 0,"function"==typeof r?(r(),i=ee,ee=void 0):i=r===et?n:r;try{a=b(n,o,i);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}if("object"==typeof a&&null!==a||"function"==typeof a)return getTransferablePointer$LWS(a);if(void 0===a&&o===L&&16&e)try{if(!(o in n)){const t=g(G,n,[]);"[object Object]"!==t&&(a=g(Et,t,[8,-1]));}}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "undefined"==typeof a?void 0:a},(t,e,o)=>{t();const r=ee;let n;ee=void 0;try{n=T(r,e);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}if(n){x(n,null);const{get:t,set:r,value:i}=n;o(e,"configurable"in n?n.configurable:et,"enumerable"in n?n.enumerable:et,"writable"in n?n.writable:et,"value"in n?"object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):"undefined"==typeof i?void 0:i:et,"get"in n?"function"==typeof t?getTransferablePointer$LWS(t):t:et,"set"in n?"function"==typeof r?getTransferablePointer$LWS(r):r:et);}},t=>{t();const e=ee;let o;ee=void 0;try{o=P(e);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "undefined"==typeof o?null:o?getTransferablePointer$LWS(o):o},(t,e)=>{t();const o=ee;ee=void 0;try{return e in o}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},t=>{t();const e=ee;ee=void 0;try{return m(e)}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},(t,e)=>{t();const o=ee;let r;ee=void 0;try{r=O(o);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}g(e,void 0,r);},t=>{t();const e=ee;ee=void 0;let o=2;try{_(e)?o=4:m(e)&&(o|=1);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return o},(t,e,o,r)=>{t();const n=ee;let i,a;ee=void 0,"function"==typeof o?(o(),i=ee,ee=void 0):i=o,"function"==typeof r?(r(),a=ee,ee=void 0):a=r===et?n:r;try{return E(n,e,i,a)}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},(t,e=null)=>{t();const o=ee;let r;ee=void 0,"function"==typeof e?(e(),r=ee,ee=void 0):r=null;try{return x(o,r)}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},ot?(...t)=>{if(ie()){for(let e=0,{length:o}=t;e<o;e+=1){const o=t[e];"function"==typeof o&&(o(),t[e]=ee,ee=void 0);}try{g(Ct,It,t);}catch(t){}}}:noop$LWS,Q?(t,...e)=>{t();const o=ee;ee=void 0;for(let t=0,{length:r}=e;t<r;t+=7)v(o,e[t],createDescriptorFromMeta$LWS(e[t+1],e[t+2],e[t+3],e[t+4],e[t+5],e[t+6]));}:noop$LWS,Q?noop$LWS:t=>{t();const e=ee;ee=void 0;const o=We.get(e);return o?getTransferablePointer$LWS(o):o},Q?()=>0:t=>{t();const e=ee;ee=void 0;try{if(!m(e))return H(e)||k(e)?0:1}catch(t){try{st(e);}catch(t){return 8}}return 0},t=>{t();const e=ee;ee=void 0;try{const t=g(G,e,[]);return "[object Object]"===t?"Object":g(Et,t,[8,-1])}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},Q?noop$LWS:(t,e)=>{t();const o=ee;ee=void 0;try{return o[e]}catch(t){throw pushErrorAcrossBoundary$LWS(t)}},Ut,Q?(t,...e)=>{const o=g(ct,e,[et]);let r,n;-1===o?r=e:(r=g(ut,e,[0,o]),n=g(ut,e,[o+1])),t();const i=ee;ee=void 0;let a=ae(i);void 0===a&&(a={__proto__:null},le(i,a));for(let t=0,{length:e}=r;t<e;t+=1){const e=r[t];a[e]=!0,v(i,e,{__proto__:null,configurable:!0,get:()=>(ne(i,e,a),i[e]),set(t){ne(i,e,a),E(i,e,t);}});}se(n);}:noop$LWS,Q?alwaysFalse$LWS:t=>{t();const e=ee;if(ee=void 0,null==e||e===I||e===bt)return !1;if("function"==typeof e){try{return q(e,J)}catch(t){}return !1}if("object"==typeof e){let t;try{if(({constructor:t}=e),t===l)return !0}catch(t){}try{if(q(e,J))return !0}catch(t){}try{if(null===P(e)&&("function"!=typeof t||t.prototype!==e))return !0}catch(t){}try{if(q(e,"lastIndex"))return g(Ot,e,[]),!0}catch(t){}try{if("byteLength"in e)return g(dt,e,[]),!0}catch(t){}}return !1},Q?alwaysFalse$LWS:t=>{t();const e=ee;ee=void 0;try{return st(e),!1}catch(t){}return !0},Q?t=>{t();const e=ee;ee=void 0;try{return L in e?Yt(e):Jt(e)}catch(t){}}:noop$LWS,Q?noop$LWS:(t,e)=>{t();const o=ee;ee=void 0,e();const r=ee;ee=void 0,We.set(o,r);},(t,e)=>{t();const o=ee;let r;ee=void 0;try{r=j(o);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}const i=O(r),{length:a}=i,s=new n(7*a);for(let t=0,e=0;t<a;t+=1,e+=7){const o=i[t],n=r[o];x(n,null);const{get:a,set:l,value:c}=n;s[e]=o,s[e+1]="configurable"in n?n.configurable:et,s[e+2]="enumerable"in n?n.enumerable:et,s[e+3]="writable"in n?n.writable:et,s[e+4]="value"in n?"object"==typeof c&&null!==c||"function"==typeof c?getTransferablePointer$LWS(c):c:et,s[e+5]="get"in n?"function"==typeof a?getTransferablePointer$LWS(a):a:et,s[e+6]="set"in n?"function"==typeof l?getTransferablePointer$LWS(l):l:et;}let l;g(e,void 0,s);try{l=P(o);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "undefined"==typeof l?null:l?getTransferablePointer$LWS(l):l},(t,e)=>{t();const o=ee;let r;ee=void 0;try{if(q(o,e))return !0;r=P(o);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "undefined"==typeof r?null:r?getTransferablePointer$LWS(r):r},(t,e,o)=>{t();const r=ee;let n,i;ee=void 0;try{n=T(r,e);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}if(n){x(n,null);const{get:t,set:r,value:i}=n;return o(e,"configurable"in n?n.configurable:et,"enumerable"in n?n.enumerable:et,"writable"in n?n.writable:et,"value"in n?"object"==typeof i&&null!==i||"function"==typeof i?getTransferablePointer$LWS(i):"undefined"==typeof i?void 0:i:et,"get"in n?"function"==typeof t?getTransferablePointer$LWS(t):t:et,"set"in n?"function"==typeof r?getTransferablePointer$LWS(r):r:et),void 0}try{i=P(r);}catch(t){throw pushErrorAcrossBoundary$LWS(t)}return "undefined"==typeof i?null:i?getTransferablePointer$LWS(i):i});let ce=!1;return (...t)=>{if(ce)return;ce=!0,({6:K,7:rt,8:at,9:yt,10:pt,11:St,12:gt,13:vt,14:Tt,15:Pt,16:wt,17:mt,18:_t,19:xt,20:Bt,21:Mt,23:jt,24:Ht,25:kt,26:Rt,27:Gt,29:Vt,30:zt,31:Xt,32:qt,33:Qt,34:Zt,35:te}=t);const e=createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1),o=createApplyOrConstructTrapForOneOrMoreArgs$LWS(1),r=createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1),n=createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1),i=createApplyOrConstructTrapForFourOrMoreArgs$LWS(1),a=createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1),l=createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1),c=createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2),u=createApplyOrConstructTrapForOneOrMoreArgs$LWS(2),d=createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2),y=createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2),p=createApplyOrConstructTrapForFourOrMoreArgs$LWS(2),S=createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2),h=createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2);void 0===it&&(it=R({yt:e,St:o,ht:r,Lt:n,gt:i,$t:a,vt:l,Wt:c,bt:u,Tt:d,Pt:y,wt:p,Ot:S,_t:h})),s[0]=it[0],s[1]=it[1],s[2]=it[2],s[3]=it[3],s[4]=it[4],s[5]=it[5],s.n=it[6],f[0]=it[7],f[1]=it[8],f[2]=it[9],f[3]=it[10],f[4]=it[11],f[5]=it[12],f.n=it[13];const{prototype:L}=BoundaryProxyHandler$LWS;L[s[0]]=e,L[s[1]]=o,L[s[2]]=r,L[s[3]]=n,L[s[4]]=i,L[s[5]]=a,L[s.n]=l,L[f[0]]=c,L[f[1]]=u,L[f[2]]=d,L[f[3]]=y,L[f[4]]=p,L[f[5]]=S,L[f.n]=h,x(L,null),F(L);}}}const be=TypeError,Te=`\n'use strict';\n(${createMembraneMarshall$LWS})`;function createRedConnector$LWS(t){if("function"!=typeof t)throw new be("Missing evaluator function.");return t(Te)()}const Pe=Symbol.for("@@lockerNearMembraneUndefinedValue"),we=Array,me=Error,Oe=Object,{push:_e}=we.prototype,{assign:Ee}=Oe,{apply:xe,ownKeys:Ae}=Reflect;class VirtualEnvironment$LWS{constructor(t){if(void 0===t)throw new me("Missing VirtualEnvironmentOptions options bag.");const{Et:e,distortionCallback:o,instrumentation:r,redConnector:n}=Ee({__proto__:null},t);let i;const a=e("blue",(...t)=>{i=t;},{distortionCallback:o,instrumentation:r}),{0:s,1:l,2:c,3:u,5:f,6:d,7:y,8:p,9:S,10:h,11:L,12:g,13:$,14:v,15:W,16:b,17:T,18:P,19:w,20:m,21:O,23:_,24:E,25:x,26:A,27:B,29:F,30:M,31:j,32:H,33:k,34:R,35:I}=i;let C;const D=n("red",(...t)=>{C=t;}),{0:N,3:G,4:K,5:U,6:V,7:z,8:X,9:q,10:Q,11:Z,12:J,13:Y,14:tt,15:et,16:ot,17:rt,18:nt,19:it,20:at,21:st,22:lt,23:ct,24:ut,25:ft,26:dt,27:yt,28:pt,29:St,30:ht,31:Lt,32:gt,33:$t,34:vt,35:Wt}=C;a(void 0,void 0,void 0,void 0,void 0,void 0,V,z,X,q,Q,Z,J,Y,tt,et,ot,rt,nt,it,at,st,void 0,ct,ut,ft,dt,yt,void 0,St,ht,Lt,gt,$t,vt,Wt),D(void 0,void 0,void 0,void 0,void 0,void 0,d,y,p,S,h,L,g,$,v,W,b,T,P,w,m,O,void 0,_,E,x,A,B,void 0,F,M,j,H,k,R,I),this.xt=s,this.At=l,this.Bt=c,this.Ft=u,this.Mt=f,this.redGlobalThisPointer=N,this.jt=G,this.Ht=K,this.kt=U,this.Rt=at,this.It=lt,this.Ct=pt;}evaluate(t){try{const e=this.Ht(t);return "function"==typeof e?(e(),this.At()):e}catch(t){var e;throw null!=(e=this.At())?e:t}}Dt(t,e,o){if("object"==typeof t&&null!==t||"function"==typeof t){const r=[this.Bt(t)];xe(_e,r,e),null!=o&&o.length&&(r[r.length]=Pe,xe(_e,r,o)),xe(this.Ct,void 0,r);}}link(...t){let e=this.xt,o=this.redGlobalThisPointer;for(let r=0,{length:n}=t;r<n;r+=1){const n=t[r];e=this.Ft(e,n),o=this.jt(o,n),this.kt(o,e),this.Mt(e,o);}}Nt(t,e){if("object"==typeof t&&null!==t||"function"==typeof t){const o=this.Bt(t),r=Ae(e),{length:n}=r,i=new we(1+7*n);i[0]=o;for(let t=0,o=1;t<n;t+=1,o+=7){const n=r[t],a=e[n],s=Ee({__proto__:null},a);i[o]=n,i[o+1]="configurable"in s?!!s.configurable:Pe,i[o+2]="enumerable"in s?!!s.enumerable:Pe,i[o+3]="writable"in s?!!s.writable:Pe,i[o+4]="value"in s?this.Bt(s.value):Pe,i[o+5]="get"in s?this.Bt(s.get):Pe,i[o+6]="set"in s?this.Bt(s.set):Pe;}xe(this.It,this,i);}}Gt(t,e){if("object"==typeof t&&null!==t||"function"==typeof t){const o=this.Bt(t),r=e?this.Bt(e):e;this.Rt(o,r);}}}const{assign:Be}=Object,{ownKeys:Fe}=Reflect,Me=["AggregateError","Array","Error","EvalError","Function","Object","Proxy","RangeError","ReferenceError","SyntaxError","TypeError","URIError","eval","globalThis"],je=(He=["globalThis","Infinity","NaN","undefined","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","BigInt","Boolean","FinalizationRegistry","Number","RegExp","String","Symbol","WeakRef","JSON","Math","Reflect","escape","unescape",...Me],xt(He,null),He.at=jt,He.concat=Ht,He.copyWithin=kt,He.entries=Rt,He.every=It,He.fill=Ct,He.filter=Dt,He.find=Nt,He.findIndex=Gt,He.flat=Kt,He.flatMap=Ut,He.forEach=Vt,He.includes=zt,He.indexOf=Xt,He.join=qt,He.keys=Qt,He.lastIndexOf=Zt,He.map=Jt,He.pop=Yt,He.push=te,He.reduce=ee,He.reduceRight=oe,He.reverse=re,He.shift=ne,He.slice=ie,He.some=ae,He.sort=se,He.splice=le,He.toLocaleString=ce,He.toString=ue,He.unshift=fe,He.values=de,He[At]=ye,He[Ft]=pe,xt(He,Mt),He);var He;function getFilteredGlobalOwnKeys$LWS(t){const e=[];let o=0;const r=Fe(t);for(let t=0,{length:n}=r;t<n;t+=1){const n=r[t];je.includes(n)||(e[o++]=n);}return e}const{deleteProperty:ke,getPrototypeOf:Re,ownKeys:Ie}=Reflect,Ce=toSafeWeakMap$LWS(new WeakMap),De=(()=>{const{navigator:t,navigator:{userAgentData:e}}=window,o=null==e?void 0:e.brands;if(Array.isArray(o)&&o.length?o.find(t=>"Chromium"===(null==t?void 0:t.brand)):/ (?:Headless)?Chrome\/\d+/.test(t.userAgent))return ["window"]})();function getCachedGlobalObjectReferences$LWS(t){const{window:e}=t;let o,r;try{({document:r}=t),o=Ce.get(r);}catch(t){return}if(o)return o;const n=Re(e),i=Re(n),a=Re(i);return o={document:r,Kt:Re(r),window:e,Ut:Re(e),Vt:Re(n),zt:a,Xt:Ie(a)},Ce.set(r,o),o}function filterWindowKeys$LWS(t){const e=[];let o=0;for(let r=0,{length:n}=t;r<n;r+=1){const n=t[r];"document"!==n&&"location "!==n&&"top"!==n&&"window"!==n&&"chrome"!==n&&(e[o++]=n);}return e}getCachedGlobalObjectReferences$LWS(window);const Ne=Object,Ge=TypeError,Ke=WeakMap,{prototype:Ue}=Document,{prototype:Ve}=Node,{remove:ze,setAttribute:Xe}=Element.prototype,{appendChild:qe}=Ve,{assign:Qe}=Ne,{__lookupGetter__:Ze}=Ne.prototype,{apply:Je}=Reflect,{close:Ye,createElement:to,open:eo}=Ue,oo=Je(Ze,Ue,["body"]),ro=Je(Ze,HTMLElement.prototype,["style"]),no=Je(Ze,HTMLIFrameElement.prototype,["contentWindow"]),io=Je(Ze,Ve,["lastChild"]),ao=toSafeWeakMap$LWS(new Ke);let so=null;function createIframeVirtualEnvironment$LWS(t,e){if("object"!=typeof t||null===t)throw new Ge("Missing global object virtualization target.");const o=getCachedGlobalObjectReferences$LWS(t);if("object"!=typeof o||null===o)throw new Ge("Invalid virtualization target.");const{distortionCallback:r,endowments:n,globalObjectShape:i,instrumentation:a,qt:s=!1}=Qe({__proto__:null},e),l=function(t){var e;const o=Je(to,t,["iframe"]),r=null!=(e=Je(oo,t,[]))?e:Je(io,t,[]);return Je(ro,o,[]).display="none",Je(Xe,o,["sandbox","allow-same-origin allow-scripts"]),Je(qe,r,[o]),o}(o.document),c=Je(no,l,[]),u="object"!=typeof i||null===i;u&&null===so&&(so=filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(c)));let f=ao.get(o.document);void 0===f&&(f=function(t){if("object"!=typeof t||null===t)throw new be("Missing globalObject.");return createMembraneMarshall$LWS(t)}(t),ao.set(o.document,f));const d=new VirtualEnvironment$LWS({Et:f,distortionCallback:r,instrumentation:a,redConnector:createRedConnector$LWS(c.eval)});if(!function(t,e){for(let o=0,{length:r}=Me;o<r;o+=1){const r=Me[o],n=e[r];n&&(n.prototype?t.link(r,"prototype"):t.link(r));}}(d,t),"undefined"==typeof globalThis?d.link("window","document"):d.link("document"),d.link("__proto__","__proto__","__proto__"),d.Gt(o.document,o.Kt),d.Dt(o.window,u?so:filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(i)),s?void 0:De),n){const t={};!function(t,e){const o=Fe(e);for(let r=0,{length:n}=o;r<n;r+=1){const n=o[r];if(!je.includes(n)){const o=e[n];o&&(t[n]=Be({__proto__:null},o));}}return t}(t,n),ke(y=t,"document"),ke(y,"location"),ke(y,"top"),ke(y,"window"),ke(y,"chrome"),d.Nt(o.window,t);}var y;if(d.Dt(o.zt,o.Xt),s){const{document:t}=c;Je(eo,t,[]),Je(Ye,t,[]);}else Je(ze,l,[]);return d}const lo=`'use strict';\n        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function(t){const{Qt:e}=t,o=Array,r=Promise,n=TypeError,{asyncIterator:i,iterator:a}=Symbol,{[a]:s}=o.prototype,l=function*(){}.constructor.prototype.prototype,{next:c,throw:u}=l,{delete:f,get:d,set:y}=Map.prototype,{appendChild:p}=Node.prototype,{defineProperties:S,freeze:h}=Object,{then:L}=r.prototype,g=r.resolve.bind(r),{apply:$,getPrototypeOf:v,setPrototypeOf:W}=Reflect,{replace:b}=String.prototype,{get:T,set:P}=WeakMap.prototype,{createElement:w}=Document.prototype,{querySelector:m,setAttribute:O}=Element.prototype,{stopPropagation:_}=Event.prototype,{addEventListener:E,removeEventListener:x}=EventTarget.prototype,{head:A}=document,B=new Map,F=/\\?'/g,M="data-locker-id",j=`${crypto.getRandomValues(new Uint32Array(1))[0]}`;class LockerSecurityError$LWS extends Error{constructor(t){super(`Lightning Web Security: ${t}`);}}function escapeSingleQuotes$LWS(t){return $(b,t,[F,"\\'"])}function genStep$LWS(t,e,o,r,n,i,a){let s,l;try{s=$(i,t,[a]),l=s.value;}catch(t){return o(t),void 0}s.done?e(l):g(l).then(r,n);}function loadPromise$LWS(t,o){const n=new r((e,r)=>{function onerror$LWS(e){$(x,t,["error",onerror$LWS]),$(x,t,["load",onload$LWS]),$(_,e,[]),r(new LockerSecurityError$LWS(`Resource loader error loading '${escapeSingleQuotes$LWS(o)}'.`));}function onload$LWS(){$(x,t,["error",onerror$LWS]),$(x,t,["load",onload$LWS]),e(void 0);}$(E,t,["error",onerror$LWS]),$(E,t,["load",onload$LWS]);});return $(P,e,[t,n]),$(p,A,[t]),n}function spreadable$LWS(t){return W(t,null),t[a]=s,t}function toString$LWS(t){return "string"==typeof t?t:`${t}`}return {asyncToGen:function(t,e,o){return new r((r,n)=>{const i=$(t,e,o);function next$LWS(t){genStep$LWS(i,r,n,next$LWS,thrower$LWS,c,t);}function thrower$LWS(t){genStep$LWS(i,r,n,next$LWS,thrower$LWS,u,t);}next$LWS(void 0);})},forAwaitOf:function(t,e,o){if(0===e){let e=!1,{[i]:r}=o;if(null==r&&(e=!0,({[a]:r}=o)),"function"!=typeof r)throw new n("Object is not iterable.");return $(y,B,[t,{iterable:$(r,o,[]),step:void 0,sync:e}]),void 0}const s=$(d,B,[t]);if(1===e){const t=s.iterable.next();return s.sync?new r(e=>{s.step=t,e();}):$(L,t,[t=>{s.step=t;}])}if(2===e)return s.step.value;if(3===e){const e=!!s.step.done;return e&&$(f,B,[t]),e}},loadScript:function(t,o){const r=toString$LWS(o);let n=$(m,A,[`script[data-distorted-src='${escapeSingleQuotes$LWS(r)}'][data-locker-id='${j}']`]);var i;return n?null!=(i=$(T,e,[n]))?i:g():(n=$(w,document,["script"]),$(O,n,[M,j]),n.type="text/javascript",n.src=r,loadPromise$LWS(n,r))},loadStyle:function(t,o){const r=toString$LWS(o);let n=$(m,A,[`link[href='${escapeSingleQuotes$LWS(r)}']`]);var i;return n?null!=(i=$(T,e,[n]))?i:g():(n=$(w,document,["link"]),n.type="text/css",n.rel="stylesheet",n.href=r,loadPromise$LWS(n,r))},makeRedGet:function(...t){const{length:e}=t,r=o(e),n={};for(let o=0;o<e;o+=1)n[o]={__proto__:null,get:t[o]};return S(r,n),r},makeRedResyncImports:function(t){return function(...e){for(let e=0,{length:o}=t;e<o;e+=1)try{t[e];}catch(t){}return spreadable$LWS(e)}},namespace:function(t){return h(t)},spreadable:spreadable$LWS,super:function(t,e,o,r){const n=v(t.prototype)[e];return $(n,o,r)}}}})`,uo={[SANDBOX_EVAL_CONTEXT_NAME$LWS]:{__proto__:null,get:()=>clearEvalContext$LWS()},[SANDBOX_EVAL_HELPERS_NAME$LWS]:{__proto__:null,get:()=>clearEvalHelpers$LWS()}},fo=(()=>{const{navigator:t,navigator:{userAgentData:o}}=window,r=/WebKit/i,n=null==o?void 0:o.brands;return !(ArrayIsArray$LWS(n)&&n.length?n.find(t=>{const e=null==t?void 0:t.brand;return "string"==typeof e&&r.test(e)}):r.test(t.userAgent))})(),yo=toSafeWeakMap$LWS$1(new WeakMapCtor$LWS),po=toSafeWeakMap$LWS$1(new WeakMapCtor$LWS),So=toSafeWeakSet$LWS(new WeakSetCtor$LWS);let ho,Lo;function clearEvalContext$LWS(){const t=ho;return ho=void 0,t}function clearEvalHelpers$LWS(){const t=Lo;return Lo=void 0,t}function createDistortionFactoryEntries$LWS(t,o=function(t){const{globalObject:e,type:o}=t,{Document:r,Element:n,HTMLElement:i,HTMLIFrameElement:a,HTMLScriptElement:s,SVGElement:l,XSLTProcessor:c}=e,u=1===o?ArrayConcat$LWS(internalDistortionFactories$LWS,internalKeyedDistortionFactories$LWS):ArrayConcat$LWS(externalDistortionFactories$LWS,externalKeyedDistortionFactories$LWS);createBlockedPropertyDistortionFactories$LWS(CustomElementRegistry.prototype,CustomElementRegistryBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(r.prototype,DocumentBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(n.prototype,ElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(i.prototype,HTMLElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(a.prototype,HTMLIFrameElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(HTMLEmbedElement.prototype,HTMLEmbedElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(HTMLObjectElement.prototype,HTMLObjectElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(s.prototype,HTMLScriptElementBlockedProperties$LWS,u),createBlockedPropertyDistortionFactories$LWS(l.prototype,SVGElementBlockedProperties$LWS,u),"function"==typeof c&&createBlockedPropertyDistortionFactories$LWS(c.prototype,XSLTProcessorBlockedProperties$LWS,u);return u}(t)){const{BASIC_INSTRUMENTATION_DATA:r,LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG:i,instrumentation:a,key:s}=t,{error:l}=a,c=i?a.startActivity:void 0,u=[];let f=0;for(let a=0,{length:d}=o;a<d;a+=1){const d=o[a],y=d(t);if(!ArrayIsArray$LWS(y))continue;const{0:p,1:S}=y;if(!isObjectLike$LWS(p))continue;let h=S;if("function"==typeof S){let t;if(i){const{name:e}=d;t=e?ReflectApply$LWS(StringProtoReplace$LWS,e,[LOCKER_IDENTIFIER_MARKER$LWS,""]):"<unknown>";}const e=new ProxyCtor$LWS(p,ObjectFreeze$LWS({apply(o,a,u){let f;a===e&&(a=S),i&&(f=c(t,r));try{return ReflectApply$LWS(S,a,u)}catch(t){throw l({sandboxKey:s,error:t}),t}finally{i&&f.stop();}},construct(o,n,a){let u;a===e&&(a=S),i&&(u=c(t,r));try{return ReflectConstruct$LWS(S,n,a)}catch(t){throw l({sandboxKey:s,error:t}),t}finally{i&&u.stop();}}}));h=e;}u[f++]=[p,h];}return u}function getSandboxRecord$LWS({context:t,document:e,endowments:o,globalObject:r,instrumentation:i,key:a,opaque:s,type:l,verboseInstrumentation:c},u){let f=yo.get(e);void 0===f&&(f={__proto__:null},yo.set(e,f));let d=f[a];if(d)return d;const y="object"==typeof i&&null!==i;let lazyVirtualEnvironmentEvaluator$LWS=t=>{const e=function(t){const{LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG:e,Zt:o,endowments:r,globalObject:i,instrumentation:a,key:s,type:l,top:c,top:{Zt:u}}=t,f=t===c,d=createIframeVirtualEnvironment$LWS(i,{distortionCallback(t){const r=u.get(t);if(r)return f?r:o.get(t)||r;if("function"==typeof t)return t;try{if(!ObjectHasOwn$LWS(t,"location"))return t}catch(e){return t}let i,d,y=!1;if(ObjectHasOwn$LWS(t,"window")&&t.window===t)try{i=ReflectApply$LWS(WindowDocumentGetter$LWS,t,[]),d=t;}catch(e){try{ReflectApply$LWS(WindowLocationGetter$LWS,t,[])&&(y=!0,i=ReflectConstruct$LWS(DocumentCtor$LWS,[]),d=t);}catch(t){}}else if("defaultView"in t){let e;try{e=ReflectApply$LWS(DocumentProtoDefaultViewGetter$LWS,t,[]);}catch(t){}e&&(i=t,d=e);}return d&&getSandboxRecord$LWS({context:void 0,document:i,endowments:void 0,globalObject:d,instrumentation:a,key:s,opaque:y,type:l,verboseInstrumentation:e},c),t},endowments:ObjectAssign$LWS({},uo,r?ObjectGetOwnPropertyDescriptors$LWS(r):void 0),qt:!1,instrumentation:e?a:void 0});return t=>d.evaluate(t)}(d);lazyVirtualEnvironmentEvaluator$LWS=e;const o=clearEvalContext$LWS();return setEvalContext$LWS(t=>{ObjectAssign$LWS(d.Jt,t({Qt:po}));}),e(lo),setEvalContext$LWS(o),e(t)};d={BASIC_INSTRUMENTATION_DATA:y?{sandboxKey:a}:void 0,LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG:y,LOCKER_VERBOSE_DEBUG_MODE_INSTRUMENTATION_FLAG:c&&y,UNCOMPILED_CONTEXT:{[UNCOMPILED_LOCATION_NAME$LWS]:r.location},context:t,document:e,Zt:fo?toSafeWeakMap$LWS$1(new WeakMapCtor$LWS):toSafeMap$LWS(new MapCtor$LWS),endowments:o,globalObject:r,Jt:{},instrumentation:i,key:a,sandboxEvaluator:(t,o,n=r,s=e)=>internalEvaluateInSandbox$LWS({context:o,document:s,endowments:void 0,globalObject:n,instrumentation:i,key:a,source:t,sourceType:0,type:l,verboseInstrumentation:c}),top:u,type:l,virtualEnvironmentEvaluator:t=>lazyVirtualEnvironmentEvaluator$LWS(t)},f[a]=d,void 0===u&&(u=d,d.top=d);const{Zt:p}=u;if(p.set(e,e),p.set(r,r),s){So.add(r);const t=createDistortionFactoryEntries$LWS(d,opaqueDistortionFactories$LWS);for(let e=0,{length:o}=t;e<o;e+=1){const{0:o,1:r}=t[e];p.set(o,r);}}else {const t=function(t){distortBlockedAttributes$LWS(t,HTMLElement,HTMLElementBlockedAttributes$LWS),distortBlockedAttributes$LWS(t,HTMLIFrameElement,HTMLIFrameElementBlockedAttributes$LWS),distortBlockedAttributes$LWS(t,HTMLScriptElement,HTMLScriptElementBlockedAttributes$LWS),distortBlockedAttributes$LWS(t,SVGElement,SVGElementBlockedAttributes$LWS);const e=createDistortionFactoryEntries$LWS(t);return createAttributeDistortions$LWS(t,e),e}(d);for(let e=0,{length:o}=t;e<o;e+=1){const{0:o,1:r}=t[e];p.set(o,r);}if(d===u)return d;const{Zt:e}=d,o=createDistortionFactoryEntries$LWS(d,evaluationDistortionFactories$LWS);for(let t=0,{length:r}=o;t<r;t+=1){const{0:r,1:n}=o[t];p.set(r,n),e.set(r,r);}}if(So.has(r))return d;So.add(r);const onDOMContentLoadedOrWindowLoad$LWS=()=>{try{getSandboxRecord$LWS({context:void 0,document:r.document,endowments:void 0,globalObject:r,instrumentation:i,key:a,opaque:s,type:l,verboseInstrumentation:c},u);}catch(t){}},S=ReflectApply$LWS(WindowFrameElementGetter$LWS,r,[]);return S?(ReflectApply$LWS(EventTargetProtoAddEventListener$LWS,S,["load",onDOMContentLoadedOrWindowLoad$LWS,!0]),d):(ReflectApply$LWS(EventTargetProtoAddEventListener$LWS,r,["unload",function onWindowUnload$LWS(){WindowQueueMicrotask$LWS(()=>{try{ReflectApply$LWS(EventTargetProtoAddEventListener$LWS,r,["DOMContentLoaded",onDOMContentLoadedOrWindowLoad$LWS,!0]),ReflectApply$LWS(EventTargetProtoAddEventListener$LWS,r,["unload",onWindowUnload$LWS,!0]);}catch(t){}});},!0]),d)}function internalEvaluateInSandbox$LWS(t){const{context:e,document:o,endowments:r,globalObject:i,instrumentation:a,key:s,source:l,sourceType:c,type:u,verboseInstrumentation:f}=t;if("string"!=typeof s)throw new LockerSecurityError$LWS("Invalid sandbox key.");const d=getSandboxRecord$LWS({context:e,document:o,endowments:r,globalObject:i,instrumentation:a,key:s,opaque:!1,type:u,verboseInstrumentation:f});var y;let p;setEvalContext$LWS(e),y=d.Jt,Lo=y;const S=function(t,e=1){let o="function"==typeof t?extractFunctionBodySource$LWS(t):toString$LWS(t);return o=ReflectApply$LWS(StringProtoReplace$LWS,o,[/\/\/# sandbox(?=MappingURL=.*?\s*$)/,"//# source"]),1===e&&-1===indexOfPragma$LWS(o,"use strict")?`'use strict';${o}`:o}(l,c),{BASIC_INSTRUMENTATION_DATA:h,LOCKER_DEBUG_MODE_INSTRUMENTATION_FLAG:L}=d,g=L?a.startActivity:void 0;let $;L&&($=g("evaluateInSandbox",h));try{p=d.virtualEnvironmentEvaluator(S);}catch(t){throw L&&$.error({sandboxKey:s,error:t}),t}finally{clearEvalContext$LWS(),clearEvalHelpers$LWS();}return L&&$.stop(),p}function setEvalContext$LWS(t){ho=t;}function evaluateInSandbox$LWS(t,e,o,r,n=defaultInstrumentation$LWS,i=!1){return internalEvaluateInSandbox$LWS({context:o,document:document,endowments:r,globalObject:window,instrumentation:n,key:t,source:e,sourceType:1,type:0,verboseInstrumentation:i})}

const loaderDefine = globalThis.LWR.define;
/**
 * Mark an exports object as "live", see https://github.com/caridy/secure-javascript-environment/pull/87.
 *
 * @returns the marked object
 */
function markLiveObject(object) {
    Reflect.defineProperty(object, Symbol.for('@@lockerLiveValue'), {});
    return object;
}
/**
 * Evaluate the given exporter in a sandbox of the given namespace
 */
function vNextEvaluateModule(namespace, specifier, exporter) {
    let out;
    // first, stringify the exporter, wrapping it with Locker context
    // note: sourceMap does not work for now
    const src = `"use strict";$lockerEvalContext$(${exporter.toString()});\n//# sourceURL=modules/${specifier}.js\n`;
    evaluateInSandbox$LWS(namespace, src, (def) => {
        out = def;
    });
    return out;
}
/**
 * Return a "secure" version of the given exporter, either
 * the given exporter as is if the module is from a trusted
 * namespace/component, or a "lockerized" version of the exporter if not.
 */
function secureExporter(specifier, dependencies, exporter, trustedNamespaces) {
    const [namespace, name] = specifier.split('/');
    // return the exporter as is if it's from a trusted component or namespace
    if (trustedNamespaces.includes(namespace) ||
        trustedNamespaces.includes(`${namespace}/*`) ||
        trustedNamespaces.includes(`${namespace}/${name}`)) {
        return exporter;
    }
    // not a trusted namespace/component, let's lockerize the exporter
    const out = vNextEvaluateModule(namespace, specifier, exporter);
    // mark the exports object as "live" if needed
    const exportsIndex = dependencies.indexOf('exports');
    if (exportsIndex >= 0) {
        return function (...args) {
            const modifiedArgs = args.map((arg, index) => {
                return (index === exportsIndex && markLiveObject(arg)) || arg;
            });
            return out.apply(this, modifiedArgs);
        };
    }
    return out;
}
function registerLockerDefine(trustedNamespaces) {
    // override the global LWR.define() for Locker
    globalThis.LWR = Object.freeze(Object.assign(Object.assign({}, globalThis.LWR), {
        define: function (specifier, dependencies, exporter, signature) {
            if (typeof dependencies === 'function') {
                // when the module has no dependency, the bundler only passes 3 parameters, the specifier, exporter and signature
                // e.g. LWR.define('my/cmp', function() { return 1; }, {ownhash})
                signature = exporter;
                exporter = dependencies;
                dependencies = [];
            }
            loaderDefine(specifier, dependencies, secureExporter(specifier, dependencies, exporter, trustedNamespaces), signature);
        },
    }));
}

export { registerLockerDefine };
